% Copyright (c) 2000  The PARI Group
%
% This file is part of the PARI/GP documentation
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU General Public License
\chapter{Functions and Operations Available in PARI and GP}
\label{se:functions}

The functions and operators available in PARI and in the GP/PARI calculator
are numerous and ever-expanding. Here is a description of the ones available
in version \vers. It should be noted that many of these functions accept
quite different types as arguments, but others are more restricted. The list
of acceptable types will be given for each function or class of functions.
Except when stated otherwise, it is understood that a function or operation
which should make natural sense is legal. In this chapter, we will describe
the functions according to a rough classification. The general entry looks
something like:

\key{foo}$(x,\{\fl=0\})$: short description.

The library syntax is \kbd{GEN foo(GEN x, long fl = 0)}.

\noindent
This means that the GP function \kbd{foo} has one mandatory argument $x$, and
an optional one, $\fl$, whose default value is 0. (The $\{\}$ should not be
typed, it is just a convenient notation we will use throughout to denote
optional arguments.) That is, you can type \kbd{foo(x,2)}, or \kbd{foo(x)},
which is then understood to mean \kbd{foo(x,0)}. As well, a comma or closing
parenthesis, where an optional argument should have been, signals to GP it
should use the default. Thus, the syntax \kbd{foo(x,)} is also accepted as a
synonym for our last expression. When a function has more than one optional
argument, the argument list is filled with user supplied values, in order.
When none are left, the defaults are used instead. Thus, assuming that
\kbd{foo}'s prototype had been
$$\hbox{%
\key{foo}$(\{x=1\},\{y=2\},\{z=3\})$,%
}$$
typing in \kbd{foo(6,4)} would give
you \kbd{foo(6,4,3)}. In the rare case when you want to set some far away
argument, and leave the defaults in between as they stand, you can use the
``empty arg'' trick alluded to above: \kbd{foo(6,,1)} would yield
\kbd{foo(6,2,1)}. By the way, \kbd{foo()} by itself yields
\kbd{foo(1,2,3)} as was to be expected.

In this rather special case of a function having no mandatory argument, you
can even omit the $()$: a standalone \kbd{foo} would be enough (though we
do not recommend it for your scripts, for the sake of clarity). In defining
GP syntax, we strove to put optional arguments at the end of the argument
list (of course, since they would not make sense otherwise), and in order of
decreasing usefulness so that, most of the time, you will be able to ignore
them.

Finally, an optional argument (between braces) followed by a star, like
$\{\var{x}\}*$, means that any number of such arguments (possibly none) can
be given. This is in particular used by the various \kbd{print} routines.

\misctitle{Flags} A \tev{flag} is an argument which, rather than conveying
actual information to the routine, instructs it to change its default
behavior, e.g.~return more or less information. All such
flags are optional, and will be called \fl\ in the function descriptions to
follow. There are two different kind of flags

\item generic: all valid values for the flag are individually
described (``If \fl\ is equal to $1$, then\dots'').

\item binary:\sidx{binary flag} use customary binary notation as a
compact way to represent many toggles with just one integer. Let
$(p_0,\dots,p_n)$ be a list of switches (i.e.~of properties which take either
the value $0$ or~$1$), the number $2^3 + 2^5 = 40$ means that $p_3$ and $p_5$
are set (that is, set to $1$), and none of the others are (that is, they
are set to $0$). This is announced as ``The binary digits of $\fl$ mean 1:
$p_0$, 2: $p_1$, 4: $p_2$'', and so on, using the available consecutive
powers of~$2$.

\misctitle{Mnemonics for flags} Numeric flags as mentioned above are
obscure, error-prone, and quite rigid: should the authors
want to adopt a new flag numbering scheme (for instance when noticing
flags with the same meaning but different numeric values across a set of
routines), it would break backward compatibility. The only advantage of
explicit numeric values is that they are fast to type, so their use is only
advised when using the calculator \kbd{gp}.

As an alternative, one can replace a numeric flag by a character string
containing symbolic identifiers. For a generic flag, the mnemonic
corresponding to the numeric identifier is given after it as in

\bprog
fun(x, {flag = 0} ):

  If flag is equal to 1 = AGM, use an agm formula ...
@eprog\noindent
which means that one can use indifferently \kbd{fun($x$, 1)} or
\kbd{fun($x$, "AGM")}.

For a binary flag, mnemonics corresponding to the various toggles are given
after each of them. They can be negated by prepending \kbd{no\_} to the
mnemonic, or by removing such a prefix. These toggles are grouped together
using any punctuation character (such as ',' or ';'). For instance (taken
from description of $\tet{ploth}(X=a,b,\var{expr},\{\fl=0\},\{n=0\})$)

\centerline{Binary digits of flags mean: $1=\kbd{Parametric}$,
$2=\kbd{Recursive}$, \dots}

\noindent so that, instead of $1$, one could use the mnemonic
\kbd{"Parametric; no\_Recursive"}, or simply \kbd{"Parametric"} since
\kbd{Recursive} is unset by default (default value of $\fl$ is $0$,
i.e.~everything unset). People used to the bit-or notation in languages like
C may also use the form \kbd{"Parametric | no\_Recursive"}.

\misctitle{Pointers} \varsidx{pointer} If a parameter in the function
prototype is prefixed with a \& sign, as in

\key{foo}$(x,\&e)$

\noindent it means that, besides the normal return value, the function may
assign a value to $e$ as a side effect. When passing the argument, the \&
sign has to be typed in explicitly. As of version \vers, this \tev{pointer}
argument is optional for all documented functions, hence the \& will always
appear between brackets as in \kbd{Z\_issquare}$(x,\{\&e\})$.

\misctitle{About library programming}
The \var{library} function \kbd{foo}, as defined at the beginning of this
section, is seen to have two mandatory arguments, $x$ and \fl: no function
seen in the present chapter has been implemented so as to accept a variable
number of arguments, so all arguments are mandatory when programming with the
library (usually, variants are provided corresponding to the various flag values).
We include an \kbd{= default value} token in the prototype to signal how a missing
argument should be encoded. Most of the time, it will be a \kbd{NULL} pointer, or
-1 for a variable number. Refer to the \emph{User's Guide to the PARI library}
for general background and details.

\section{Standard monadic or dyadic operators}

\subseckbd{+$/$-} The expressions \kbd{+}$x$ and \kbd{-}$x$ refer
to monadic operators (the first does nothing, the second negates $x$).

The library syntax is \fun{GEN}{gneg}{GEN x} for \kbd{-}$x$.

\subseckbd{+} The expression $x$ \kbd{+} $y$ is the \idx{sum} of $x$ and $y$.
Addition between a scalar type $x$ and a \typ{COL} or \typ{MAT} $y$ returns
respectively $[y[1] + x, y[2],\dots]$ and $y + x \text{Id}$. Other additions
between a scalar type and a vector or a matrix, or between vector/matrices of
incompatible sizes are forbidden.

The library syntax is \fun{GEN}{gadd}{GEN x, GEN y}.

\subseckbd{-} The expression $x$ \kbd{-} $y$ is the \idx{difference} of $x$
and $y$. Subtraction between a scalar type $x$ and a \typ{COL} or \typ{MAT}
$y$ returns respectively $[y[1] - x, y[2],\dots]$ and $y - x \text{Id}$.
Other subtractions between a scalar type and a vector or a matrix, or
between vector/matrices of incompatible sizes are forbidden.

The library syntax is \fun{GEN}{gsub}{GEN x, GEN y} for $x$ \kbd{-} $y$.

\subseckbd{*} The expression $x$ \kbd{*} $y$ is the \idx{product} of $x$
and $y$. Among the prominent impossibilities are multiplication between
vector/matrices of incompatible sizes, between a \typ{INTMOD} or \typ{PADIC}
Restricted to scalars, \kbd{*} is commutative; because of vector and matrix
operations, it is not commutative in general.

Multiplication between two \typ{VEC}s or two \typ{COL}s is not
allowed; to take the \idx{scalar product} of two vectors of the same length,
transpose one of the vectors (using the operator \kbd{\til} or the function
\kbd{mattranspose}, see \secref{se:linear_algebra}) and multiply a line vector
by a column vector:
\bprog
? a = [1,2,3];
? a * a
  ***   at top-level: a*a
  ***                  ^--
  *** _*_: forbidden multiplication t_VEC * t_VEC.
? a * a~
%2 = 14
@eprog

If $x,y$ are binary quadratic forms, compose them; see also
\kbd{qfbnucomp} and \kbd{qfbnupow}. If $x,y$ are \typ{VECSMALL} of the same
length, understand them as permutations and compose them.

The library syntax is \fun{GEN}{gmul}{GEN x, GEN y} for $x$ \kbd{*} $y$.
Also available is \fun{GEN}{gsqr}{GEN x} for $x$ \kbd{*} $x$.

\subseckbd{/} The expression $x$ \kbd{/} $y$ is the \idx{quotient} of $x$
and $y$. In addition to the impossibilities for multiplication, note that if
the divisor is a matrix, it must be an invertible square matrix, and in that
case the result is $x*y^{-1}$. Furthermore note that the result is as exact
as possible: in particular, division of two integers always gives a rational
number (which may be an integer if the quotient is exact) and \emph{not} the
Euclidean quotient (see $x$ \kbd{\bs} $y$ for that), and similarly the
quotient of two polynomials is a rational function in general. To obtain the
approximate real value of the quotient of two integers, add \kbd{0.} to the
result; to obtain the approximate $p$-adic value of the quotient of two
integers, add \kbd{O(p\pow k)} to the result; finally, to obtain the
\idx{Taylor series} expansion of the quotient of two polynomials, add
\kbd{O(X\pow k)} to the result or use the \kbd{taylor} function
(see \secref{se:taylor}). \label{se:gdiv}

The library syntax is \fun{GEN}{gdiv}{GEN x, GEN y} for $x$ \kbd{/} $y$.

\subseckbd{\bs} The expression \kbd{$x$ \bs\ $y$} is the \idx{Euclidean
quotient} of $x$ and $y$. If $y$ is a real scalar, this is defined as
\kbd{floor($x$/$y$)} if $y > 0$, and \kbd{ceil($x$/$y$)} if $y < 0$ and
the division is not exact. Hence the remainder \kbd{$x$ - ($x$\bs$y$)*$y$}
is in $[0, |y|[$.

Note that when $y$ is an integer and $x$ a polynomial, $y$ is first promoted
to a polynomial of degree $0$. When $x$ is a vector or matrix, the operator
is applied componentwise.

The library syntax is \fun{GEN}{gdivent}{GEN x, GEN y}
for $x$ \kbd{\bs} $y$.

\subseckbd{\bs/} The expression $x$ \b{/} $y$ evaluates to the rounded
\idx{Euclidean quotient} of $x$ and $y$. This is the same as \kbd{$x$ \bs\ $y$}
except for scalar division: the quotient is such that the corresponding
remainder is smallest in absolute value and in case of a tie the quotient
closest to $+\infty$ is chosen (hence the remainder would belong to
$]{-}|y|/2, |y|/2]$).

When $x$ is a vector or matrix, the operator is applied componentwise.

The library syntax is \fun{GEN}{gdivround}{GEN x, GEN y}
for $x$ \b{/} $y$.

\subseckbd{\%} The expression \kbd{$x$ \% $y$} evaluates to the modular
\idx{Euclidean remainder} of $x$ and $y$, which we now define. When $x$ or $y$
is a non-integral real number, \kbd{$x$\%$y$} is defined as \kbd{$x$ -
($x$\bs$y$)*$y$}. Otherwise, if $y$ is an integer, this is the smallest
non-negative integer congruent to $x$ modulo $y$. (This actually coincides with
the previous definition if and only if $x$ is an integer.) If $y$ is a
polynomial, this is the polynomial of smallest degree congruent to $x$ modulo
$y$. For instance:
\bprog
? (1/2) % 3
%1 = 2
? 0.5 % 3
%2 = 0.5000000000000000000000000000
? (1/2) % 3.0
%3 = 1/2
@eprog
Note that when $y$ is an integer and $x$ a polynomial, $y$ is first promoted
to a polynomial of degree $0$. When $x$ is a vector or matrix, the operator
is applied componentwise.

The library syntax is \fun{GEN}{gmod}{GEN x, GEN y}
for $x$ \kbd{\%} $y$.

\subseckbd{\pow} The expression $x\hbox{\kbd{\pow}}n$ is \idx{powering}.
If the exponent is an integer, then exact operations are performed using
binary (left-shift) powering techniques. In particular, in this case $x$
cannot be a vector or matrix unless it is a square matrix (invertible
if the exponent is negative). If $x$ is a $p$-adic number, its
precision will increase if $v_p(n) > 0$. Powering a binary quadratic form
(types \typ{QFI} and \typ{QFR}) returns a reduced representative of the
class, provided the input is reduced. In particular, $x\hbox{\kbd{\pow}}1$ is
identical to $x$.

PARI is able to rewrite the multiplication $x * x$ of two \emph{identical}
objects as $x^2$, or $\kbd{sqr}(x)$. Here, identical means the operands are
two different labels referencing the same chunk of memory; no equality test
is performed. This is no longer true when more than two arguments are
involved.

If the exponent is not of type integer, this is treated as a transcendental
function (see \secref{se:trans}), and in particular has the effect of
componentwise powering on vector or matrices.

As an exception, if the exponent is a rational number $p/q$ and $x$ an
integer modulo a prime or a $p$-adic number, return a solution $y$ of
$y^q=x^p$ if it exists. Currently, $q$ must not have large prime factors.
Beware that
\bprog
? Mod(7,19)^(1/2)
%1 = Mod(11, 19) /* is any square root */
? sqrt(Mod(7,19))
%2 = Mod(8, 19)  /* is the smallest square root */
? Mod(7,19)^(3/5)
%3 = Mod(1, 19)
? %3^(5/3)
%4 = Mod(1, 19)  /* Mod(7,19) is just another cubic root */
@eprog

If the exponent is a negative integer, an \idx{inverse} must be computed.
For non-invertible \typ{INTMOD}, this will fail and implicitly exhibit a
non trivial factor of the modulus:
\bprog
? Mod(4,6)^(-1)
  ***   at top-level: Mod(4,6)^(-1)
  ***                         ^-----
  *** _^_: impossible inverse modulo: Mod(2, 6).
@eprog\noindent
(Here, a factor 2 is obtained directly. In general, take the gcd of the
representative and the modulus.) This is most useful when performing
complicated operations modulo an integer $N$ whose factorization is
unknown. Either the computation succeeds and all is well, or a factor $d$
is discovered and the computation may be restarted modulo $d$ or $N/d$.

For non-invertible \typ{POLMOD}, this will fail without exhibiting a
factor.
\bprog
? Mod(x^2, x^3-x)^(-1)
  ***   at top-level: Mod(x^2,x^3-x)^(-1)
  ***                               ^-----
  *** _^_: non-invertible polynomial in RgXQ_inv.
? a = Mod(3,4)*y^3 + Mod(1,4); b = y^6+y^5+y^4+y^3+y^2+y+1;
? Mod(a, b)^(-1);
  ***   at top-level: Mod(a,b)^(-1)
  ***                         ^-----
  *** _^_: impossible inverse modulo: Mod(0, 4).
@eprog\noindent
In fact the latter polynomial is invertible, but the algorithm used
(subresultant) assumes the base ring is a domain. If it is not the case,
as here for $\Z/4\Z$, a result will be correct but chances are an error
will occur first. In this specific case, one should work with $2$-adics.
In general, one can try the following approach
\bprog
? inversemod(a, b) =
{ my(m);
  m = polsylvestermatrix(polrecip(a), polrecip(b));
  m = matinverseimage(m, matid(#m)[,1]);
  Polrev( vecextract(m, Str("..", poldegree(b))), variable(b) )
}
? inversemod(a,b)
%2 = Mod(2,4)*y^5 + Mod(3,4)*y^3 + Mod(1,4)*y^2 + Mod(3,4)*y + Mod(2,4)
@eprog\noindent
This is not guaranteed to work either since it must invert pivots. See
\secref{se:linear_algebra}.

The library syntax is \fun{GEN}{gpow}{GEN x, GEN n, long prec}
for $x\hbox{\kbd{\pow}}n$.


\subsec{cmp$(x,y)$}\kbdsidx{cmp}\label{se:cmp}
Gives the result of a comparison between arbitrary objects $x$ and $y$
(as $-1$, $0$ or $1$). The underlying order relation is transitive,
the function returns $0$ if and only if $x~\kbd{===}~y$, and its
restriction to integers coincides with the customary one. Besides that,
it has no useful mathematical meaning.

In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix $>$ vector $>$ scalar.
For example:
\bprog
? cmp(1, 2)
%1 = -1
? cmp(2, 1)
%2 = 1
? cmp(1, 1.0)   \\ note that 1 == 1.0, but (1===1.0) is false.
%3 = -1
? cmp(x + Pi, [])
%4 = -1
@eprog\noindent This function is mostly useful to handle sorted lists or
vectors of arbitrary objects. For instance, if $v$ is a vector, the
construction \kbd{vecsort(v, cmp)} is equivalent to \kbd{Set(v)}.

The library syntax is \fun{GEN}{cmp_universal}{GEN x, GEN y}.

\subsec{divrem$(x,y,\{v\})$}\kbdsidx{divrem}\label{se:divrem}
Creates a column vector with two components, the first being the Euclidean
quotient (\kbd{$x$ \bs\ $y$}), the second the Euclidean remainder
(\kbd{$x$ - ($x$\bs$y$)*$y$}), of the division of $x$ by $y$. This avoids the
need to do two divisions if one needs both the quotient and the remainder.
If $v$ is present, and $x$, $y$ are multivariate
polynomials, divide with respect to the variable $v$.

Beware that \kbd{divrem($x$,$y$)[2]} is in general not the same as
\kbd{$x$ \% $y$}; no GP operator corresponds to it:
\bprog
? divrem(1/2, 3)[2]
%1 = 1/2
? (1/2) % 3
%2 = 2
? divrem(Mod(2,9), 3)[2]
 ***   at top-level: divrem(Mod(2,9),3)[2
 ***                 ^--------------------
 ***   forbidden division t_INTMOD \ t_INT.
? Mod(2,9) % 6
%3 = Mod(2,3)
@eprog

The library syntax is \fun{GEN}{divrem}{GEN x, GEN y, long v = -1}, where \kbd{v} is a variable number.
Also available is \fun{GEN}{gdiventres}{GEN x, GEN y} when $v$ is
not needed.

\subsec{lex$(x,y)$}\kbdsidx{lex}\label{se:lex}
Gives the result of a lexicographic comparison
between $x$ and $y$ (as $-1$, $0$ or $1$). This is to be interpreted in quite
a wide sense: It is admissible to compare objects of different types
(scalars, vectors, matrices), provided the scalars can be compared, as well
as vectors/matrices of different lengths. The comparison is recursive.

In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix $>$ vector $>$ scalar.
For example:
\bprog
? lex([1,3], [1,2,5])
%1 = 1
? lex([1,3], [1,3,-1])
%2 = -1
? lex([1], [[1]])
%3 = -1
? lex([1], [1]~)
%4 = 0
@eprog

The library syntax is \fun{GEN}{lexcmp}{GEN x, GEN y}.

\subsec{max$(x,y)$}\kbdsidx{max}\label{se:max}
Creates the maximum of $x$ and $y$ when they can be compared.

The library syntax is \fun{GEN}{gmax}{GEN x, GEN y}.

\subsec{min$(x,y)$}\kbdsidx{min}\label{se:min}
Creates the minimum of $x$ and $y$ when they can be compared.

The library syntax is \fun{GEN}{gmin}{GEN x, GEN y}.

\subsec{shift$(x,n)$}\kbdsidx{shift}\label{se:shift}
Shifts $x$ componentwise left by $n$ bits if $n\ge0$ and right by $|n|$
bits if $n<0$. May be abbreviated as $x$ \kbd{<<} $n$ or $x$ \kbd{>>} $(-n)$.
A left shift by $n$ corresponds to multiplication by $2^n$. A right shift of an
integer $x$ by $|n|$ corresponds to a Euclidean division of $x$ by $2^{|n|}$
with a remainder of the same sign as $x$, hence is not the same (in general) as
$x \kbd{\bs} 2^n$.

The library syntax is \fun{GEN}{gshift}{GEN x, long n}.

\subsec{shiftmul$(x,n)$}\kbdsidx{shiftmul}\label{se:shiftmul}
Multiplies $x$ by $2^n$. The difference with
\kbd{shift} is that when $n<0$, ordinary division takes place, hence for
example if $x$ is an integer the result may be a fraction, while for shifts
Euclidean division takes place when $n<0$ hence if $x$ is an integer the result
is still an integer.

The library syntax is \fun{GEN}{gmul2n}{GEN x, long n}.

\subsec{sign$(x)$}\kbdsidx{sign}\label{se:sign}
\idx{sign} ($0$, $1$ or $-1$) of $x$, which must be of
type integer, real or fraction.

The library syntax is \fun{GEN}{gsigne}{GEN x}.

\subsec{vecmax$(x,\{\&v\})$}\kbdsidx{vecmax}\label{se:vecmax}
If $x$ is a vector or a matrix, returns the largest entry of $x$,
otherwise returns a copy of $x$. Error if $x$ is empty.

If $v$ is given, set it to the index of a largest entry (indirect maximum),
when $x$ is a vector. If $x$ is a matrix, set $v$ to coordinates $[i,j]$
such that $x[i,j]$ is a largest entry. This flag is ignored if $x$ is not a
vector or matrix.

\bprog
? vecmax([10, 20, -30, 40])
%1 = 40
? vecmax([10, 20, -30, 40], &v); v
%2 = 4
? vecmax([10, 20; -30, 40], &v); v
%3 = [2, 2]
@eprog

The library syntax is \fun{GEN}{vecmax0}{GEN x, GEN *v = NULL}.
Also available is \fun{GEN}{vecmax}{GEN x}.

\subsec{vecmin$(x,\{\&v\})$}\kbdsidx{vecmin}\label{se:vecmin}
If $x$ is a vector or a matrix, returns the smallest entry of $x$,
otherwise returns a copy of $x$. Error if $x$ is empty.

If $v$ is given, set it to the index of a smallest entry (indirect minimum),
when $x$ is a vector. If $x$ is a matrix, set $v$ to coordinates $[i,j]$ such
that $x[i,j]$ is a smallest entry. This is ignored if $x$ is not a vector or
matrix.

\bprog
? vecmin([10, 20, -30, 40])
%1 = -30
? vecmin([10, 20, -30, 40], &v); v
%2 = 3
? vecmin([10, 20; -30, 40], &v); v
%3 = [2, 1]
@eprog

The library syntax is \fun{GEN}{vecmin0}{GEN x, GEN *v = NULL}.
Also available is \fun{GEN}{vecmin}{GEN x}.
%SECTION: operators

\subsec{Comparison and Boolean operators}\sidx{Boolean operators} The six
standard \idx{comparison operators} \kbd{<=}, \kbd{<}, \kbd{>=}, \kbd{>},
\kbd{==}, \kbd{!=} are available in GP. The result is 1 if the comparison is
true, 0 if it is false. The operator \kbd{==} is quite liberal : for
instance, the integer 0, a 0 polynomial, and a vector with 0 entries are all
tested equal.

The extra operator \kbd{===} tests whether two objects are identical and is
much stricter than \kbd{==} : objects of different type or length are never
identical.

For the purpose of comparison, \typ{STR} objects are strictly larger than any
other non-string type; two \typ{STR} objects are compared using the standard
lexicographic order.

GP accepts \kbd{<>} as a synonym for \kbd{!=}. On the other hand, \kbd{=} is
definitely \emph{not} a synonym for \kbd{==}: it is the assignment statement.

The standard boolean operators \kbd{||} (\idx{inclusive or}), \kbd{\&\&}
(\idx{and})\sidx{or} and \kbd{!} (\idx{not}) are also available.

\section{Conversions and similar elementary functions or commands}
\label{se:conversion}

\noindent
Many of the conversion functions are rounding or truncating operations. In
this case, if the argument is a rational function, the result is the
Euclidean quotient of the numerator by the denominator, and if the argument
is a vector or a matrix, the operation is done componentwise. This will not
be restated for every function.


\subsec{Col$(x, \{n\})$}\kbdsidx{Col}\label{se:Col}
Transforms the object $x$ into a column vector. The dimension of the
resulting vector can be optionally specified via the extra parameter $n$.

If $n$ is omitted or $0$, the dimension depends on the type of $x$; the
vector has a single component, except when $x$ is

\item a vector or a quadratic form (in which case the resulting vector
is simply the initial object considered as a row vector),

\item a polynomial or a power series. In the case of a polynomial, the
coefficients of the vector start with the leading coefficient of the
polynomial, while for power series only the significant coefficients are
taken into account, but this time by increasing order of degree.
In this last case, \kbd{Vec} is the reciprocal function of \kbd{Pol} and
\kbd{Ser} respectively,

\item a matrix (the column of row vector comprising the matrix is returned),

\item a character string (a vector of individual characters is returned).

In the last two cases (matrix and character string), $n$ is meaningless and
must be omitted or an error is raised. Otherwise, if $n$ is given, $0$
entries are appended at the end of the vector if $n > 0$, and prepended at
the beginning if $n < 0$. The dimension of the resulting vector is $|n|$.

Note that the function \kbd{Colrev} does not exist, use \kbd{Vecrev}.

The library syntax is \fun{GEN}{gtocol0}{GEN x, long n}.
\fun{GEN}{gtocol}{GEN x} is also available.

\subsec{Colrev$(x, \{n\})$}\kbdsidx{Colrev}\label{se:Colrev}
As $\kbd{Col}(x, n)$, then reverse the result. In particular

The library syntax is \fun{GEN}{gtocolrev0}{GEN x, long n}.
\fun{GEN}{gtocolrev}{GEN x} is also available.

\subsec{List$(\{x=[\,]\})$}\kbdsidx{List}\label{se:List}
Transforms a (row or column) vector $x$ into a list, whose components are
the entries of $x$. Similarly for a list, but rather useless in this case.
For other types, creates a list with the single element $x$. Note that,
except when $x$ is omitted, this function creates a small memory leak; so,
either initialize all lists to the empty list, or use them sparingly.

The library syntax is \fun{GEN}{gtolist}{GEN x = NULL}.
The variant \fun{GEN}{listcreate}{void} creates an empty list.

\subsec{Mat$(\{x=[\,]\})$}\kbdsidx{Mat}\label{se:Mat}
Transforms the object $x$ into a matrix.
If $x$ is already a matrix, a copy of $x$ is created.
If $x$ is a row (resp. column) vector, this creates a 1-row (resp.
1-column) matrix, \emph{unless} all elements are column (resp.~row) vectors
of the same length, in which case the vectors are concatenated sideways
and the associated big matrix is returned.
If $x$ is a binary quadratic form, creates the associated $2\times 2$
matrix. Otherwise, this creates a $1\times 1$ matrix containing $x$.

\bprog
? Mat(x + 1)
%1 =
[x + 1]
? Vec( matid(3) )
%2 = [[1, 0, 0]~, [0, 1, 0]~, [0, 0, 1]~]
? Mat(%)
%3 =
[1 0 0]

[0 1 0]

[0 0 1]
? Col( [1,2; 3,4] )
%4 = [[1, 2], [3, 4]]~
? Mat(%)
%5 =
[1 2]

[3 4]
? Mat(Qfb(1,2,3))
%6 =
[1 1]

[1 3]
@eprog

The library syntax is \fun{GEN}{gtomat}{GEN x = NULL}.

\subsec{Mod$(a,b)$}\kbdsidx{Mod}\label{se:Mod}
In its basic form, creates an intmod or a polmod $(a \mod b)$; $b$ must
be an integer or a polynomial. We then obtain a \typ{INTMOD} and a
\typ{POLMOD} respectively:
\bprog
? t = Mod(2,17); t^8
%1 = Mod(1, 17)
? t = Mod(x,x^2+1); t^2
%2 = Mod(-1, x^2+1)
@eprog\noindent If $a \% b$ makes sense and yields a result of the
appropriate type (\typ{INT} or scalar/\typ{POL}), the operation succeeds as
well:
\bprog
? Mod(1/2, 5)
%3 = Mod(3, 5)
? Mod(7 + O(3^6), 3)
%4 = Mod(1, 3)
? Mod(Mod(1,12), 9)
%5 = Mod(1, 3)
? Mod(1/x, x^2+1)
%6 = Mod(-1, x^2+1)
? Mod(exp(x), x^4)
%7 = Mod(1/6*x^3 + 1/2*x^2 + x + 1, x^4)
@eprog
If $a$ is a complex object, ``base change'' it to $\Z/b\Z$ or $K[x]/(b)$,
which is equivalent to, but faster than, multiplying it by \kbd{Mod(1,b)}:
\bprog
? Mod([1,2;3,4], 2)
%8 =
[Mod(1, 2) Mod(0, 2)]

[Mod(1, 2) Mod(0, 2)]
? Mod(3*x+5, 2)
%9 = Mod(1, 2)*x + Mod(1, 2)
? Mod(x^2 + y*x + y^3, y^2+1)
%10 = Mod(1, y^2 + 1)*x^2 + Mod(y, y^2 + 1)*x + Mod(-y, y^2 + 1)
@eprog

This function is not the same as $x$ \kbd{\%} $y$, the result of which
has no knowledge of the intended modulus $y$. Compare
\bprog
? x = 4 % 5; x + 1
%1 = 5
? x = Mod(4,5); x + 1
%2 = Mod(0,5)
@eprog

The library syntax is \fun{GEN}{gmodulo}{GEN a, GEN b}.

\subsec{Pol$(t,\{v='x\})$}\kbdsidx{Pol}\label{se:Pol}
Transforms the object $t$ into a polynomial with main variable $v$. If $t$
is a scalar, this gives a constant polynomial. If $t$ is a power series with
non-negative valuation or a rational function, the effect is similar to
\kbd{truncate}, i.e.~we chop off the $O(X^k)$ or compute the Euclidean
quotient of the numerator by the denominator, then change the main variable
of the result to $v$.

The main use of this function is when $t$ is a vector: it creates the
polynomial whose coefficients are given by $t$, with $t[1]$ being the leading
coefficient (which can be zero). It is much faster to evaluate
\kbd{Pol} on a vector of coefficients in this way, than the corresponding
formal expression $a_n X^n + \dots + a_0$, which is evaluated naively exactly
as written (linear versus quadratic time in $n$). \tet{Polrev} can be used if
one wants $x[1]$ to be the constant coefficient:
\bprog
? Pol([1,2,3])
%1 = x^2 + 2*x + 3
? Polrev([1,2,3])
%2 = 3*x^2 + 2*x + 1
@eprog\noindent
The reciprocal function of \kbd{Pol} (resp.~\kbd{Polrev}) is \kbd{Vec} (resp.~
\kbd{Vecrev}).
\bprog
? Vec(Pol([1,2,3]))
%1 = [1, 2, 3]
? Vecrev( Polrev([1,2,3]) )
%2 = [1, 2, 3]
@eprog\noindent

\misctitle{Warning} This is \emph{not} a substitution function. It will not
transform an object containing variables of higher priority than~$v$.
\bprog
? Pol(x + y, y)
  ***   at top-level: Pol(x+y,y)
  ***                 ^----------
  *** Pol: variable must have higher priority in gtopoly.
@eprog

The library syntax is \fun{GEN}{gtopoly}{GEN t, long v = -1}, where \kbd{v} is a variable number.

\subsec{Polrev$(t,\{v='x\})$}\kbdsidx{Polrev}\label{se:Polrev}
Transform the object $t$ into a polynomial
with main variable $v$. If $t$ is a scalar, this gives a constant polynomial.
If $t$ is a power series, the effect is identical to \kbd{truncate}, i.e.~it
chops off the $O(X^k)$.

The main use of this function is when $t$ is a vector: it creates the
polynomial whose coefficients are given by $t$, with $t[1]$ being the
constant term. \tet{Pol} can be used if one wants $t[1]$ to be the leading
coefficient:
\bprog
? Polrev([1,2,3])
%1 = 3*x^2 + 2*x + 1
? Pol([1,2,3])
%2 = x^2 + 2*x + 3
@eprog
The reciprocal function of \kbd{Pol} (resp.~\kbd{Polrev}) is \kbd{Vec} (resp.~
\kbd{Vecrev}).

The library syntax is \fun{GEN}{gtopolyrev}{GEN t, long v = -1}, where \kbd{v} is a variable number.

\subsec{Qfb$(a,b,c,\{D=0.\})$}\kbdsidx{Qfb}\label{se:Qfb}
Creates the binary quadratic form\sidx{binary quadratic form}
$ax^2+bxy+cy^2$. If $b^2-4ac>0$, initialize \idx{Shanks}' distance
function to $D$. Negative definite forms are not implemented,
use their positive definite counterpart instead.

The library syntax is \fun{GEN}{Qfb0}{GEN a, GEN b, GEN c, GEN D = NULL, long prec}.
Also available are
\fun{GEN}{qfi}{GEN a, GEN b, GEN c} (assumes $b^2-4ac<0$) and
\fun{GEN}{qfr}{GEN a, GEN b, GEN c, GEN D} (assumes $b^2-4ac>0$).

\subsec{Ser$(s,\{v='x\},\{d=\var{seriesprecision}\})$}\kbdsidx{Ser}\label{se:Ser}
Transforms the object $s$ into a power series with main variable $v$
($x$ by default) and precision (number of significant terms) equal to
$d$ (= the default \kbd{seriesprecision} by default). If $s$ is a
scalar, this gives a constant power series in $v$ with precision \kbd{d}.
If $s$ is a polynomial, the polynomial is truncated to $d$ terms if needed
\bprog
? Ser(1, 'y, 5)
%1 = 1 + O(y^5)
? Ser(x^2,, 5)
%2 = x^2 + O(x^7)
? T = polcyclo(100)
%3 = x^40 - x^30 + x^20 - x^10 + 1
? Ser(T, 'x, 11)
%4 = 1 - x^10 + O(x^11)
@eprog\noindent The function is more or less equivalent with multiplication by
$1 + O(v^d)$ in theses cases, only faster.

If $s$ is a vector, on the other hand, the coefficients of the vector are
understood to be the coefficients of the power series starting from the
constant term (as in \tet{Polrev}$(x)$), and the precision $d$ is ignored:
in other words, in this case, we convert \typ{VEC} / \typ{COL} to the power
series whose significant terms are exactly given by the vector entries.
Finally, if $s$ is already a power series in $v$, we return it verbatim,
ignoring $d$ again. If $d$ significant terms are desired in the last two
cases, convert/truncate to \typ{POL} first.
\bprog
? v = [1,2,3]; Ser(v, t, 7)
%5 = 1 + 2*t + 3*t^2 + O(t^3)  \\ 3 terms: 7 is ignored!
? Ser(Polrev(v,t), t, 7)
%6 = 1 + 2*t + 3*t^2 + O(t^7)
? s = 1+x+O(x^2); Ser(s, x, 7)
%7 = 1 + x + O(x^2)  \\ 2 terms: 7 ignored
? Ser(truncate(s), x, 7)
%8 = 1 + x + O(x^7)
@eprog\noindent
The warning given for \kbd{Pol} also applies here: this is not a substitution
function.

The library syntax is \fun{GEN}{gtoser}{GEN s, long v = -1, long precdl}, where \kbd{v} is a variable number.

\subsec{Set$(\{x=[\,]\})$}\kbdsidx{Set}\label{se:Set}
Converts $x$ into a set, i.e.~into a row vector, with strictly increasing
entries with respect to the (somewhat arbitrary) universal comparison function
\tet{cmp}. Standard container types \typ{VEC}, \typ{COL}, \typ{LIST} and
\typ{VECSMALL} are converted to the set with corresponding elements. All
others are converted to a set with one element.
\bprog
? Set([1,2,4,2,1,3])
%1 = [1, 2, 3, 4]
? Set(x)
%2 = [x]
? Set(Vecsmall([1,3,2,1,3]))
%3 = [1, 2, 3]
@eprog

The library syntax is \fun{GEN}{gtoset}{GEN x = NULL}.

\subsec{Str$(\{x\}*)$}\kbdsidx{Str}\label{se:Str}
Converts its argument list into a
single character string (type \typ{STR}, the empty string if $x$ is omitted).
To recover an ordinary \kbd{GEN} from a string, apply \kbd{eval} to it. The
arguments of \kbd{Str} are evaluated in string context, see \secref{se:strings}.

\bprog
? x2 = 0; i = 2; Str(x, i)
%1 = "x2"
? eval(%)
%2 = 0
@eprog\noindent
This function is mostly useless in library mode. Use the pair
\tet{strtoGEN}/\tet{GENtostr} to convert between \kbd{GEN} and \kbd{char*}.
The latter returns a malloced string, which should be freed after usage.
%\syn{NO}

\subsec{Strchr$(x)$}\kbdsidx{Strchr}\label{se:Strchr}
Converts $x$ to a string, translating each integer
into a character.
\bprog
? Strchr(97)
%1 = "a"
? Vecsmall("hello world")
%2 = Vecsmall([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])
? Strchr(%)
%3 = "hello world"
@eprog

The library syntax is \fun{GEN}{Strchr}{GEN x}.

\subsec{Strexpand$(\{x\}*)$}\kbdsidx{Strexpand}\label{se:Strexpand}
Converts its argument list into a
single character string (type \typ{STR}, the empty string if $x$ is omitted).
Then perform \idx{environment expansion}, see \secref{se:envir}.
This feature can be used to read \idx{environment variable} values.
\bprog
? Strexpand("$HOME/doc")
%1 = "/home/pari/doc"
@eprog

The individual arguments are read in string context, see \secref{se:strings}.
%\syn{NO}

\subsec{Strtex$(\{x\}*)$}\kbdsidx{Strtex}\label{se:Strtex}
Translates its arguments to TeX
format, and concatenates the results into a single character string (type
\typ{STR}, the empty string if $x$ is omitted).

The individual arguments are read in string context, see \secref{se:strings}.
%\syn{NO}

\subsec{Vec$(x, \{n\})$}\kbdsidx{Vec}\label{se:Vec}
Transforms the object $x$ into a row vector. The dimension of the
resulting vector can be optionally specified via the extra parameter $n$.

If $n$ is omitted or $0$, the dimension depends on the type of $x$; the
vector has a single component, except when $x$ is

\item a vector or a quadratic form (in which case the resulting vector
is simply the initial object considered as a row vector),

\item a polynomial or a power series. In the case of a polynomial, the
coefficients of the vector start with the leading coefficient of the
polynomial, while for power series only the significant coefficients are
taken into account, but this time by increasing order of degree.
In this last case, \kbd{Vec} is the reciprocal function of \kbd{Pol} and
\kbd{Ser} respectively,

\item a matrix: return the vector of columns comprising the matrix.

\item a character string: return the vector of individual characters.

\item an error context (\typ{ERROR}): return the error components, see
\tet{iferr}.

In the last three cases (matrix, character string, error), $n$ is
meaningless and must be omitted or an error is raised. Otherwise, if $n$ is
given, $0$ entries are appended at the end of the vector if $n > 0$, and
prepended at the beginning if $n < 0$. The dimension of the resulting vector
is $|n|$. Variant: \fun{GEN}{gtovec}{GEN x} is also available.

The library syntax is \fun{GEN}{gtovec0}{GEN x, long n}.

\subsec{Vecrev$(x, \{n\})$}\kbdsidx{Vecrev}\label{se:Vecrev}
As $\kbd{Vec}(x, n)$, then reverse the result. In particular
In this case, \kbd{Vecrev} is the reciprocal function of \kbd{Polrev}: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.

The library syntax is \fun{GEN}{gtovecrev0}{GEN x, long n}.
\fun{GEN}{gtovecrev}{GEN x} is also available.

\subsec{Vecsmall$(x, \{n\})$}\kbdsidx{Vecsmall}\label{se:Vecsmall}
Transforms the object $x$ into a row vector of type \typ{VECSMALL}. The
dimension of the resulting vector can be optionally specified via the extra
parameter $n$.

This acts as \kbd{Vec}$(x,n)$, but only on a limited set of objects:
the result must be representable as a vector of small integers.
If $x$ is a character string, a vector of individual characters in ASCII
encoding is returned (\tet{Strchr} yields back the character string).

The library syntax is \fun{GEN}{gtovecsmall0}{GEN x, long n}.
\fun{GEN}{gtovecsmall}{GEN x} is also available.

\subsec{binary$(x)$}\kbdsidx{binary}\label{se:binary}
Outputs the vector of the binary digits of $|x|$.
Here $x$ can be an integer, a real number (in which case the result has two
components, one for the integer part, one for the fractional part) or a
vector/matrix.

The library syntax is \fun{GEN}{binaire}{GEN x}.

\subsec{bitand$(x,y)$}\kbdsidx{bitand}\label{se:bitand}
Bitwise \tet{and}
\sidx{bitwise and}of two integers $x$ and $y$, that is the integer
$$\sum_i (x_i~\kbd{and}~y_i) 2^i$$

Negative numbers behave $2$-adically, i.e.~the result is the $2$-adic limit
of \kbd{bitand}$(x_n,y_n)$, where $x_n$ and $y_n$ are non-negative integers
tending to $x$ and $y$ respectively. (The result is an ordinary integer,
possibly negative.)

\bprog
? bitand(5, 3)
%1 = 1
? bitand(-5, 3)
%2 = 3
? bitand(-5, -3)
%3 = -7
@eprog

The library syntax is \fun{GEN}{gbitand}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitand}{GEN x, GEN y}, which returns the bitwise \emph{and}
of $|x|$ and $|y|$, two integers.

\subsec{bitneg$(x,\{n=-1\})$}\kbdsidx{bitneg}\label{se:bitneg}
\idx{bitwise negation} of an integer $x$,
truncated to $n$ bits, $n\geq 0$, that is the integer
$$\sum_{i=0}^{n-1} \kbd{not}(x_i) 2^i.$$
The special case $n=-1$ means no truncation: an infinite sequence of
leading $1$ is then represented as a negative number.

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitneg}{GEN x, long n}.

\subsec{bitnegimply$(x,y)$}\kbdsidx{bitnegimply}\label{se:bitnegimply}
Bitwise negated imply of two integers $x$ and
$y$ (or \kbd{not} $(x \Rightarrow y)$), that is the integer $$\sum
(x_i~\kbd{and not}(y_i)) 2^i$$

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitnegimply}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitnegimply}{GEN x, GEN y}, which returns the bitwise negated
imply of $|x|$ and $|y|$, two integers.

\subsec{bitor$(x,y)$}\kbdsidx{bitor}\label{se:bitor}
\sidx{bitwise inclusive or}bitwise (inclusive)
\tet{or} of two integers $x$ and $y$, that is the integer $$\sum
(x_i~\kbd{or}~y_i) 2^i$$

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitor}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitor}{GEN x, GEN y}, which returns the bitwise \emph{ir}
of $|x|$ and $|y|$, two integers.

\subsec{bittest$(x,n)$}\kbdsidx{bittest}\label{se:bittest}
Outputs the $n^{\text{th}}$ bit of $x$ starting
from the right (i.e.~the coefficient of $2^n$ in the binary expansion of $x$).
The result is 0 or 1.
\bprog
? bittest(7, 3)
%1 = 1 \\ the 3rd bit is 1
? bittest(7, 4)
%2 = 0 \\ the 4th bit is 0
@eprog\noindent
See \secref{se:bitand} for the behavior at negative arguments.

The library syntax is \fun{GEN}{gbittest}{GEN x, long n}.
For a \typ{INT} $x$, the variant \fun{long}{bittest}{GEN x, long n} is
generally easier to use, and if furthermore $n\ge 0$ the low-level function
\fun{ulong}{int_bit}{GEN x, long n} returns \kbd{bittest(abs(x),n)}.

\subsec{bitxor$(x,y)$}\kbdsidx{bitxor}\label{se:bitxor}
Bitwise (exclusive) \tet{or}
\sidx{bitwise exclusive or}of two integers $x$ and $y$, that is the integer
$$\sum (x_i~\kbd{xor}~y_i) 2^i$$

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitxor}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitxor}{GEN x, GEN y}, which returns the bitwise \emph{xor}
of $|x|$ and $|y|$, two integers.

\subsec{ceil$(x)$}\kbdsidx{ceil}\label{se:ceil}
Ceiling of $x$. When $x$ is in $\R$, the result is the
smallest integer greater than or equal to $x$. Applied to a rational
function, $\kbd{ceil}(x)$ returns the Euclidean quotient of the numerator by
the denominator.

The library syntax is \fun{GEN}{gceil}{GEN x}.

\subsec{centerlift$(x,\{v\})$}\kbdsidx{centerlift}\label{se:centerlift}
Same as \tet{lift}, except that \typ{INTMOD} and \typ{PADIC} components
are lifted using centered residues:

\item for a \typ{INTMOD} $x\in \Z/n\Z$, the lift $y$ is such that
$-n/2<y\le n/2$.

\item  a \typ{PADIC} $x$ is lifted in the same way as above (modulo
$p^\kbd{padicprec(x)}$) if its valuation $v$ is non-negative; if not, returns
the fraction $p^v$ \kbd{centerlift}$(x p^{-v})$; in particular, rational
reconstruction is not attempted. Use \tet{bestappr} for this.

For backward compatibility, \kbd{centerlift(x,'v)} is allowed as an alias
for \kbd{lift(x,'v)}.

\synt{centerlift}{GEN x}.

\subsec{characteristic$(x)$}\kbdsidx{characteristic}\label{se:characteristic}
Returns the characteristic of the base ring over which $x$ is defined (as
defined by \typ{INTMOD} and \typ{FFELT} components). The function raises an
exception if incompatible primes arise from \typ{FFELT} and \typ{PADIC}
components.
\bprog
? characteristic(Mod(1,24)*x + Mod(1,18)*y)
%1 = 6
@eprog

The library syntax is \fun{GEN}{characteristic}{GEN x}.

\subsec{component$(x,n)$}\kbdsidx{component}\label{se:component}
Extracts the $n^{\text{th}}$-component of $x$. This is to be understood
as follows: every PARI type has one or two initial \idx{code words}. The
components are counted, starting at 1, after these code words. In particular
if $x$ is a vector, this is indeed the $n^{\text{th}}$-component of $x$, if
$x$ is a matrix, the $n^{\text{th}}$ column, if $x$ is a polynomial, the
$n^{\text{th}}$ coefficient (i.e.~of degree $n-1$), and for power series,
the $n^{\text{th}}$ significant coefficient.

For polynomials and power series, one should rather use \tet{polcoeff}, and
for vectors and matrices, the \kbd{[$\,$]} operator. Namely, if $x$ is a
vector, then \tet{x[n]} represents the $n^{\text{th}}$ component of $x$. If
$x$ is a matrix, \tet{x[m,n]} represents the coefficient of row \kbd{m} and
column \kbd{n} of the matrix, \tet{x[m,]} represents the $m^{\text{th}}$
\emph{row} of $x$, and \tet{x[,n]} represents the $n^{\text{th}}$
\emph{column} of $x$.

Using of this function requires detailed knowledge of the structure of the
different PARI types, and thus it should almost never be used directly.
Some useful exceptions:
\bprog
    ? x = 3 + O(3^5);
    ? component(x, 2)
    %2 = 81   \\ p^(p-adic accuracy)
    ? component(x, 1)
    %3 = 3    \\ p
    ? q = Qfb(1,2,3);
    ? component(q, 1)
    %5 = 1
@eprog

The library syntax is \fun{GEN}{compo}{GEN x, long n}.

\subsec{conj$(x)$}\kbdsidx{conj}\label{se:conj}
Conjugate of $x$. The meaning of this
is clear, except that for real quadratic numbers, it means conjugation in the
real quadratic field. This function has no effect on integers, reals,
intmods, fractions or $p$-adics. The only forbidden type is polmod
(see \kbd{conjvec} for this).

The library syntax is \fun{GEN}{gconj}{GEN x}.

\subsec{conjvec$(z)$}\kbdsidx{conjvec}\label{se:conjvec}
Conjugate vector representation of $z$. If $z$ is a
polmod, equal to \kbd{Mod}$(a,T)$, this gives a vector of length
$\text{degree}(T)$ containing:

\item the complex embeddings of $z$ if $T$ has rational coefficients,
i.e.~the $a(r[i])$ where $r = \kbd{polroots}(T)$;

\item the conjugates of $z$ if $T$ has some intmod coefficients;

\noindent if $z$ is a finite field element, the result is the vector of
conjugates $[z,z^p,z^{p^2},\ldots,z^{p^{n-1}}]$ where $n=\text{degree}(T)$.

\noindent If $z$ is an integer or a rational number, the result is~$z$. If
$z$ is a (row or column) vector, the result is a matrix whose columns are
the conjugate vectors of the individual elements of $z$.

The library syntax is \fun{GEN}{conjvec}{GEN z, long prec}.

\subsec{denominator$(x)$}\kbdsidx{denominator}\label{se:denominator}
Denominator of $x$. The meaning of this
is clear when $x$ is a rational number or function. If $x$ is an integer
or a polynomial, it is treated as a rational number or function,
respectively, and the result is equal to $1$. For polynomials, you
probably want to use
\bprog
denominator( content(x) )
@eprog\noindent
instead. As for modular objects, \typ{INTMOD} and \typ{PADIC} have
denominator $1$, and the denominator of a \typ{POLMOD} is the denominator
of its (minimal degree) polynomial representative.

If $x$ is a recursive structure, for instance a vector or matrix, the lcm
of the denominators of its components (a common denominator) is computed.
This also applies for \typ{COMPLEX}s and \typ{QUAD}s.

\misctitle{Warning} Multivariate objects are created according to variable
priorities, with possibly surprising side effects ($x/y$ is a polynomial, but
$y/x$ is a rational function). See \secref{se:priority}.

The library syntax is \fun{GEN}{denom}{GEN x}.

\subsec{digits$(x,\{b={10}\})$}\kbdsidx{digits}\label{se:digits}
Outputs the vector of the digits of $|x|$ in base $b$, where $x$ and $b$ are integers.

The library syntax is \fun{GEN}{digits}{GEN x, GEN b = NULL}.

\subsec{floor$(x)$}\kbdsidx{floor}\label{se:floor}
Floor of $x$. When $x$ is in $\R$, the result is the
largest integer smaller than or equal to $x$. Applied to a rational function,
$\kbd{floor}(x)$ returns the Euclidean quotient of the numerator by the
denominator.

The library syntax is \fun{GEN}{gfloor}{GEN x}.

\subsec{frac$(x)$}\kbdsidx{frac}\label{se:frac}
Fractional part of $x$. Identical to
$x-\text{floor}(x)$. If $x$ is real, the result is in $[0,1[$.

The library syntax is \fun{GEN}{gfrac}{GEN x}.

\subsec{hammingweight$(x)$}\kbdsidx{hammingweight}\label{se:hammingweight}
If $x$ is a \typ{INT}, return the binary Hamming weight of $|x|$. Otherwise
$x$ must be of type \typ{POL}, \typ{VEC}, \typ{COL}, \typ{VECSMALL}, or
\typ{MAT} and the function returns the number of non-zero coefficients of
$x$.
\bprog
? hammingweight(15)
%1 = 4
? hammingweight(x^100 + 2*x + 1)
%2 = 3
? hammingweight([Mod(1,2), 2, Mod(0,3)])
%3 = 2
? hammingweight(matid(100))
%4 = 100
@eprog

The library syntax is \fun{long}{hammingweight}{GEN x}.

\subsec{imag$(x)$}\kbdsidx{imag}\label{se:imag}
Imaginary part of $x$. When $x$ is a quadratic number, this is the
coefficient of $\omega$ in the ``canonical'' integral basis $(1,\omega)$.

The library syntax is \fun{GEN}{gimag}{GEN x}.

\subsec{length$(x)$}\kbdsidx{length}\label{se:length}
Length of $x$; \kbd{\#}$x$ is a shortcut for \kbd{length}$(x)$.
This is mostly useful for

\item vectors: dimension (0 for empty vectors),

\item lists: number of entries (0 for empty lists),

\item matrices: number of columns,

\item character strings: number of actual characters (without
trailing \kbd{\bs 0}, should you expect it from $C$ \kbd{char*}).
\bprog
 ? #"a string"
 %1 = 8
 ? #[3,2,1]
 %2 = 3
 ? #[]
 %3 = 0
 ? #matrix(2,5)
 %4 = 5
 ? L = List([1,2,3,4]); #L
 %5 = 4
@eprog

The routine is in fact defined for arbitrary GP types, but is awkward and
useless in other cases: it returns the number of non-code words in $x$, e.g.
the effective length minus 2 for integers since the \typ{INT} type has two code
words.

The library syntax is \fun{long}{glength}{GEN x}.

\subsec{lift$(x,\{v\})$}\kbdsidx{lift}\label{se:lift}
If $v$ is omitted, lifts intmods from $\Z/n\Z$ in $\Z$,
$p$-adics from $\Q_p$ to $\Q$ (as \tet{truncate}), and polmods to
polynomials. Otherwise, lifts only polmods whose modulus has main
variable~$v$. \typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(lift,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? lift(Mod(5,3))
%1 = 2
? lift(3 + O(3^9))
%2 = 3
? lift(Mod(x,x^2+1))
%3 = x
? lift(Mod(x,x^2+1))
%4 = x
@eprog
Lifts are performed recursively on an object components, but only
by \emph{one level}: once a \typ{POLMOD} is lifted, the components of
the result are \emph{not} lifted further.
\bprog
? lift(x * Mod(1,3) + Mod(2,3))
%4 = x + 2
? lift(x * Mod(y,y^2+1) + Mod(2,3))
%5 = y*x + Mod(2, 3)   \\@com do you understand this one?
? lift(x * Mod(y,y^2+1) + Mod(2,3), 'x)
%6 = Mod(y, y^2 + 1)*x + Mod(Mod(2, 3), y^2 + 1)
? lift(%, y)
%7 = y*x + Mod(2, 3)
@eprog\noindent To recursively lift all components not only by one level,
but as long as possible, use \kbd{liftall}. To lift only \typ{INTMOD}s and
\typ{PADIC}s components, use \tet{liftint}. To lift only \typ{POLMOD}s
components, use \tet{liftpol}. Finally, \tet{centerlift} allows to lift
\typ{INTMOD}s and \typ{PADIC}s using centered residues (lift of smallest
absolute value).

The library syntax is \fun{GEN}{lift0}{GEN x, long v = -1}, where \kbd{v} is a variable number.
Also available is \fun{GEN}{lift}{GEN x} corresponding to
\kbd{lift0(x,-1)}.

\subsec{liftall$(x)$}\kbdsidx{liftall}\label{se:liftall}
Recursively lift all components of $x$ from $\Z/n\Z$ to $\Z$,
from $\Q_p$ to $\Q$ (as \tet{truncate}), and polmods to
polynomials. \typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(liftall,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? liftall(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftall(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + 2*z
@eprog

The library syntax is \fun{GEN}{liftall}{GEN x}.

\subsec{liftint$(x)$}\kbdsidx{liftint}\label{se:liftint}
Recursively lift all components of $x$ from $\Z/n\Z$ to $\Z$ and
from $\Q_p$ to $\Q$ (as \tet{truncate}).
\typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(liftint,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? liftint(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftint(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = Mod(y, y^2 + 1)*x + Mod(Mod(2*z, z^2), y^2 + 1)
@eprog

The library syntax is \fun{GEN}{liftint}{GEN x}.

\subsec{liftpol$(x)$}\kbdsidx{liftpol}\label{se:liftpol}
Recursively lift all components of $x$ which are polmods to
polynomials. \typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(liftpol,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? liftpol(x * (1 + O(3)) + Mod(2,3))
%1 = (1 + O(3))*x + Mod(2, 3)
? liftpol(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + Mod(2, 3)*z
@eprog

The library syntax is \fun{GEN}{liftpol}{GEN x}.

\subsec{norm$(x)$}\kbdsidx{norm}\label{se:norm}
Algebraic norm of $x$, i.e.~the product of $x$ with
its conjugate (no square roots are taken), or conjugates for polmods. For
vectors and matrices, the norm is taken componentwise and hence is not the
$L^2$-norm (see \kbd{norml2}). Note that the norm of an element of
$\R$ is its square, so as to be compatible with the complex norm.

The library syntax is \fun{GEN}{gnorm}{GEN x}.

\subsec{numerator$(x)$}\kbdsidx{numerator}\label{se:numerator}
Numerator of $x$. The meaning of this
is clear when $x$ is a rational number or function. If $x$ is an integer
or a polynomial, it is treated as a rational number or function,
respectively, and the result is $x$ itself. For polynomials, you
probably want to use
\bprog
numerator( content(x) )
@eprog\noindent
instead.

In other cases, \kbd{numerator(x)} is defined to be
\kbd{denominator(x)*x}. This is the case when $x$ is a vector or a
matrix, but also for \typ{COMPLEX} or \typ{QUAD}. In particular since a
\typ{PADIC} or \typ{INTMOD} has  denominator $1$, its numerator is
itself.

\misctitle{Warning} Multivariate objects are created according to variable
priorities, with possibly surprising side effects ($x/y$ is a polynomial, but
$y/x$ is a rational function). See \secref{se:priority}.

The library syntax is \fun{GEN}{numer}{GEN x}.

\subsec{numtoperm$(n,k)$}\kbdsidx{numtoperm}\label{se:numtoperm}
Generates the $k$-th permutation (as a row vector of length $n$) of the
numbers $1$ to $n$. The number $k$ is taken modulo $n!\,$, i.e.~inverse
function of \tet{permtonum}. The numbering used is the standard lexicographic
ordering, starting at $0$.

The library syntax is \fun{GEN}{numtoperm}{long n, GEN k}.

\subsec{padicprec$(x,p)$}\kbdsidx{padicprec}\label{se:padicprec}
Absolute $p$-adic precision of the object $x$. This is the minimum
precision of the components of $x$. The result is \tet{LONG_MAX}
($2^{31}-1$ for 32-bit machines or $2^{63}-1$ for 64-bit machines) if $x$ is
an exact object.

The library syntax is \fun{long}{padicprec}{GEN x, GEN p}.

\subsec{permtonum$(x)$}\kbdsidx{permtonum}\label{se:permtonum}
Given a permutation $x$ on $n$ elements, gives the number $k$ such that
$x=\kbd{numtoperm(n,k)}$, i.e.~inverse function of \tet{numtoperm}.
The numbering used is the standard lexicographic ordering, starting at $0$.

The library syntax is \fun{GEN}{permtonum}{GEN x}.

\subsec{precision$(x,\{n\})$}\kbdsidx{precision}\label{se:precision}
The function has two different behaviors according to whether $n$ is present or not.

If $n$ is missing, the function returns the precision in decimal digits of the
PARI object $x$. If $x$ is
an exact object, the largest single precision integer is returned.
\bprog
? precision(exp(1e-100))
%1 = 134                \\ 134 significant decimal digits
? precision(2 + x)
%2 = 2147483647         \\ exact object
? precision(0.5 + O(x))
%3 = 28                 \\ floating point accuracy, NOT series precision
? precision( [ exp(1e-100), 0.5 ] )
%4 = 28                 \\ minimal accuracy among components
@eprog\noindent
The return value for exact objects is meaningless since it is not even the
same on 32 and 64-bit machines. The proper way to test whether an object is
exact is
\bprog
? isexact(x) = precision(x) == precision(0)
@eprog

If $n$ is present, the function creates a new object equal to $x$ with a new
``precision'' $n$. (This never changes the type of the result. In particular
it is not possible to use it to obtain a polynomial from a power series; for
that, see \tet{truncate}.) Now the meaning of precision is different from the
above (floating point accuracy), and depends on the type of $x$:

For exact types, no change. For $x$ a vector or a matrix, the operation is
done componentwise.

For real $x$, $n$ is the number of desired significant \emph{decimal}
digits. If $n$ is smaller than the precision of $x$, $x$ is truncated,
otherwise $x$ is extended with zeros.

For $x$ a $p$-adic or a power series, $n$ is the desired number of
\emph{significant} $p$-adic or $X$-adic digits, where $X$ is the main
variable of $x$. (Note: yes, this is inconsistent.)
Note that the precision is a priori distinct from the exponent $k$ appearing
in $O(*^k)$; it is indeed equal to $k$ if and only if $x$ is a $p$-adic
or $X$-adic \emph{unit}.
\bprog
? precision(1 + O(x), 10)
%1 = 1 + O(x^10)
? precision(x^2 + O(x^10), 3)
%2 = x^2 + O(x^5)
? precision(7^2 + O(7^10), 3)
%3 = 7^2 + O(7^5)
@eprog\noindent
For the last two examples, note that $x^2 + O(x^5) = x^2(1 + O(x^3))$
indeed has 3 significant coefficients

The library syntax is \fun{GEN}{precision0}{GEN x, long n}.
Also available are \fun{GEN}{gprec}{GEN x, long n} and
\fun{long}{precision}{GEN x}. In both, the accuracy is expressed in
\emph{words} (32-bit or 64-bit depending on the architecture).

\subsec{random$(\{N=2^{{31}}\})$}\kbdsidx{random}\label{se:random}
Returns a random element in various natural sets depending on the
argument $N$.

\item \typ{INT}: returns an integer
uniformly distributed between $0$ and $N-1$. Omitting the argument
is equivalent to \kbd{random(2\pow31)}.

\item \typ{REAL}: returns a real number in $[0,1[$ with the same accuracy as
$N$ (whose mantissa has the same number of significant words).

\item \typ{INTMOD}: returns a random intmod for the same modulus.

\item \typ{FFELT}: returns a random element in the same finite field.

\item \typ{VEC} of length $2$, $N = [a,b]$: returns an integer uniformly
distributed between $a$ and $b$.

\item \typ{VEC} generated by \kbd{ellinit} over a finite field $k$
(coefficients are \typ{INTMOD}s modulo a prime or \typ{FFELT}s): returns a
``random'' $k$-rational \emph{affine} point on the curve. More precisely
if the curve has a single point (at infinity!) we return it; otherwise
we return an affine point by drawing an abscissa uniformly at
random until \tet{ellordinate} succeeds. Note that this is definitely not a
uniform distribution over $E(k)$, but it should be good enough for
applications.

\item \typ{POL} return a random polynomial of degree at most the degree of $N$.
The coefficients are drawn by applying \kbd{random} to the leading
coefficient of $N$.

\bprog
? random(10)
%1 = 9
? random(Mod(0,7))
%2 = Mod(1, 7)
? a = ffgen(ffinit(3,7), 'a); random(a)
%3 = a^6 + 2*a^5 + a^4 + a^3 + a^2 + 2*a
? E = ellinit([3,7]*Mod(1,109)); random(E)
%4 = [Mod(103, 109), Mod(10, 109)]
? E = ellinit([1,7]*a^0); random(E)
%5 = [a^6 + a^5 + 2*a^4 + 2*a^2, 2*a^6 + 2*a^4 + 2*a^3 + a^2 + 2*a]
? random(Mod(1,7)*x^4)
%6 = Mod(5, 7)*x^4 + Mod(6, 7)*x^3 + Mod(2, 7)*x^2 + Mod(2, 7)*x + Mod(5, 7)

@eprog
These variants all depend on a single internal generator, and are
independent from your operating system's random number generators.
A random seed may be obtained via \tet{getrand}, and reset
using \tet{setrand}: from a given seed, and given sequence of \kbd{random}s,
the exact same values will be generated. The same seed is used at each
startup, reseed the generator yourself if this is a problem. Note that
internal functions also call the random number generator; adding such a
function call in the middle of your code will change the numbers produced.

\misctitle{Technical note}
Up to
version 2.4 included, the internal generator produced pseudo-random numbers
by means of linear congruences, which were not well distributed in arithmetic
progressions. We now
use Brent's XORGEN algorithm, based on Feedback Shift Registers, see
\kbd{http://wwwmaths.anu.edu.au/\til{}brent/random.html}. The generator has period
$2^{4096}-1$, passes the Crush battery of statistical tests of L'Ecuyer and
Simard, but is not suitable for cryptographic purposes: one can reconstruct
the state vector from a small sample of consecutive values, thus predicting
the entire sequence.

The library syntax is \fun{GEN}{genrand}{GEN N = NULL}.

 Also available: \fun{GEN}{ellrandom}{GEN E} and \fun{GEN}{ffrandom}{GEN a}.

\subsec{real$(x)$}\kbdsidx{real}\label{se:real}
Real part of $x$. In the case where $x$ is a quadratic number, this is the
coefficient of $1$ in the ``canonical'' integral basis $(1,\omega)$.

The library syntax is \fun{GEN}{greal}{GEN x}.

\subsec{round$(x,\{\&e\})$}\kbdsidx{round}\label{se:round}
If $x$ is in $\R$, rounds $x$ to the nearest integer (rounding to
$+\infty$ in case of ties), then and sets $e$ to the number of error bits,
that is the binary exponent of the difference between the original and the
rounded value (the ``fractional part''). If the exponent of $x$ is too large
compared to its precision (i.e.~$e>0$), the result is undefined and an error
occurs if $e$ was not given.

\misctitle{Important remark} Contrary to the other truncation functions,
this function operates on every coefficient at every level of a PARI object.
For example
$$\text{truncate}\left(\dfrac{2.4*X^2-1.7}{X}\right)=2.4*X,$$
whereas
$$\text{round}\left(\dfrac{2.4*X^2-1.7}{X}\right)=\dfrac{2*X^2-2}{X}.$$
An important use of \kbd{round} is to get exact results after an approximate
computation, when theory tells you that the coefficients must be integers.

The library syntax is \fun{GEN}{round0}{GEN x, GEN *e = NULL}.
Also available are \fun{GEN}{grndtoi}{GEN x, long *e} and
\fun{GEN}{ground}{GEN x}.

\subsec{simplify$(x)$}\kbdsidx{simplify}\label{se:simplify}
This function simplifies $x$ as much as it can. Specifically, a complex or
quadratic number whose imaginary part is the integer 0 (i.e.~not \kbd{Mod(0,2)}
or \kbd{0.E-28}) is converted to its real part, and a polynomial of degree $0$
is converted to its constant term. Simplifications occur recursively.

This function is especially useful before using arithmetic functions,
which expect integer arguments:
\bprog
? x = 2 + y - y
%1 = 2
? isprime(x)
  ***   at top-level: isprime(x)
  ***                 ^----------
  *** isprime: not an integer argument in an arithmetic function
? type(x)
%2 = "t_POL"
? type(simplify(x))
%3 = "t_INT"
@eprog
Note that GP results are simplified as above before they are stored in the
history. (Unless you disable automatic simplification with \b{y}, that is.)
In particular
\bprog
? type(%1)
%4 = "t_INT"
@eprog

The library syntax is \fun{GEN}{simplify}{GEN x}.

\subsec{sizebyte$(x)$}\kbdsidx{sizebyte}\label{se:sizebyte}
Outputs the total number of bytes occupied by the tree representing the
PARI object $x$.

The library syntax is \fun{long}{gsizebyte}{GEN x}.
Also available is \fun{long}{gsizeword}{GEN x} returning a
number of \emph{words}.

\subsec{sizedigit$(x)$}\kbdsidx{sizedigit}\label{se:sizedigit}
Outputs a quick bound for the number of decimal
digits of (the components of) $x$, off by at most $1$. If you want the
exact value, you can use \kbd{\#Str(x)}, which is slower.

The library syntax is \fun{long}{sizedigit}{GEN x}.

\subsec{truncate$(x,\{\&e\})$}\kbdsidx{truncate}\label{se:truncate}
Truncates $x$ and sets $e$ to the number of
error bits. When $x$ is in $\R$, this means that the part after the decimal
point is chopped away, $e$ is the binary exponent of the difference between
the original and the truncated value (the ``fractional part''). If the
exponent of $x$ is too large compared to its precision (i.e.~$e>0$), the
result is undefined and an error occurs if $e$ was not given. The function
applies componentwise on vector / matrices; $e$ is then the maximal number of
error bits. If $x$ is a rational function, the result is the ``integer part''
(Euclidean quotient of numerator by denominator) and $e$ is not set.

Note a very special use of \kbd{truncate}: when applied to a power series, it
transforms it into a polynomial or a rational function with denominator
a power of $X$, by chopping away the $O(X^k)$. Similarly, when applied to
a $p$-adic number, it transforms it into an integer or a rational number
by chopping away the $O(p^k)$.

The library syntax is \fun{GEN}{trunc0}{GEN x, GEN *e = NULL}.
The following functions are also available: \fun{GEN}{gtrunc}{GEN x}
and \fun{GEN}{gcvtoi}{GEN x, long *e}.

\subsec{valuation$(x,p)$}\kbdsidx{valuation}\label{se:valuation}
Computes the highest
exponent of $p$ dividing $x$. If $p$ is of type integer, $x$ must be an
integer, an intmod whose modulus is divisible by $p$, a fraction, a
$q$-adic number with $q=p$, or a polynomial or power series in which case the
valuation is the minimum of the valuation of the coefficients.

If $p$ is of type polynomial, $x$ must be of type polynomial or rational
function, and also a power series if $x$ is a monomial. Finally, the
valuation of a vector, complex or quadratic number is the minimum of the
component valuations.

If $x=0$, the result is \tet{LONG_MAX} ($2^{31}-1$ for 32-bit machines or
$2^{63}-1$ for 64-bit machines) if $x$ is an exact object. If $x$ is a
$p$-adic numbers or power series, the result is the exponent of the zero.
Any other type combinations gives an error.

The library syntax is \fun{long}{gvaluation}{GEN x, GEN p}.

\subsec{variable$(\{x\})$}\kbdsidx{variable}\label{se:variable}
Gives the main variable of the object $x$ (the variable with the highest
priority used in $x$), and $p$ if $x$ is a $p$-adic number. Return $0$ if
$x$ has no variable associated to it.
\bprog
? variable(x^2 + y)
%1 = x
? variable(1 + O(5^2))
%2 = 5
? variable([x,y,z,t])
%3 = x
? variable(1)
%4 = 0
@eprog\noindent The construction
\bprog
   if (!variable(x),...)
@eprog\noindent can be used to test whether a variable is attached to $x$.

If $x$ is omitted, returns the list of user variables known to the
interpreter, by order of decreasing priority. (Highest priority is $x$,
which always come first.)

The library syntax is \fun{GEN}{gpolvar}{GEN x = NULL}.
However, in library mode, this function should not be used for $x$
non-\kbd{NULL}, since \tet{gvar} is more appropriate. Instead, for
$x$ a $p$-adic (type \typ{PADIC}), $p$ is $gel(x,2)$; otherwise, use
\fun{long}{gvar}{GEN x} which returns the variable number of $x$ if
it exists, \kbd{NO\_VARIABLE} otherwise, which satisfies the property
$\kbd{varncmp}(\kbd{NO\_VARIABLE}, v) > 0$ for all valid variable number
$v$, i.e. it has lower priority than any variable.
%SECTION: conversions

\section{Transcendental functions}\label{se:trans}

Since the values of transcendental functions cannot be exactly represented,
these functions will always return an inexact object: a real number,
a complex number, a $p$-adic number or a power series.  All these objects
have a certain finite precision.

As a general rule, which of course in some cases may have exceptions,
transcendental functions operate in the following way:

\item If the argument is either a real number or an inexact complex number
(like \kbd{1.0 + I} or \kbd{Pi*I} but not \kbd{2 - 3*I}), then the
computation is done with the precision of the argument.
In the example below, we see that changing the precision to $50$ digits does
not matter, because $x$ only had a precision of $19$ digits.
\bprog
? \p 15
   realprecision = 19 significant digits (15 digits displayed)
? x = Pi/4
%1 = 0.785398163397448
? \p 50
   realprecision = 57 significant digits (50 digits displayed)
? sin(x)
%2 = 0.7071067811865475244
@eprog

Note that even if the argument is real, the result may be complex
(e.g.~$\text{acos}(2.0)$ or $\text{acosh}(0.0)$). See each individual
function help for the definition of the branch cuts and choice of principal
value.

\item If the argument is either an integer, a rational, an exact complex
number or a quadratic number, it is first converted to a real
or complex number using the current \idx{precision} held in the default
\tet{realprecision}.  This precision (the number of decimal digits) can be
changed using \b{p} or \kbd{default(realprecision,...)}).
After this conversion, the computation proceeds as above for real or complex
arguments.

In library mode, the \kbd{realprecision} does not matter; instead the
precision is taken from the \kbd{prec} parameter which every transcendental
function has.  As in \kbd{gp}, this \kbd{prec} is not used when the
argument to a function is already inexact.
Note that the argument \var{prec} stands for the length in words of a real
number, including codewords. Hence we must have $\var{prec} \geq 3$.

Some accuracies attainable on 32-bit machines cannot be attained
on 64-bit machines for parity reasons. For example the default \kbd{gp} accuracy
is 28 decimal digits on 32-bit machines, corresponding to \var{prec} having
the value 5, but this cannot be attained on 64-bit machines.

\item If the argument is a polmod (representing an algebraic number),
then the function is evaluated for every possible complex embedding of that
algebraic number.  A column vector of results is returned, with one component
for each complex embedding.  Therefore, the number of components equals
the degree of the \typ{POLMOD} modulus.

\item If the argument is an intmod or a $p$-adic, at present only a
few functions like \kbd{sqrt} (square root), \kbd{sqr} (square), \kbd{log},
\kbd{exp}, powering, \kbd{teichmuller} (Teichm\"uller character) and
\kbd{agm} (arithmetic-geometric mean) are implemented.

Note that in the case of a $2$-adic number, $\kbd{sqr}(x)$ may not be
identical to $x*x$: for example if $x = 1+O(2^5)$ and $y = 1+O(2^5)$ then
$x*y = 1+O(2^5)$ while $\kbd{sqr}(x) = 1+O(2^6)$. Here, $x * x$ yields the
same result as $\kbd{sqr}(x)$ since the two operands are known to be
\emph{identical}. The same statement holds true for $p$-adics raised to the
power $n$, where $v_p(n) > 0$.

\misctitle{Remark} If we wanted to be strictly consistent with
the PARI philosophy, we should have $x*y = (4 \mod 8)$ and $\kbd{sqr}(x) =
(4 \mod 32)$ when both $x$ and $y$ are congruent to $2$ modulo $4$.
However, since intmod is an exact object, PARI assumes that the modulus
must not change, and the result is hence $(0\, \mod\, 4)$ in both cases. On
the other hand, $p$-adics are not exact objects, hence are treated
differently.

\item If the argument is a polynomial, a power series or a rational function,
it is, if necessary, first converted to a power series using the current
series precision, held in the default \tet{seriesprecision}. This precision
(the number of significant terms) can be changed using \b{ps} or
\kbd{default(seriesprecision,...)}. Then the Taylor series expansion of the
function around $X=0$ (where $X$ is the main variable) is computed to a
number of terms depending on the number of terms of the argument and the
function being computed.

Under \kbd{gp} this again is transparent to the user. When programming in
library mode, however, it is \emph{strongly} advised to perform an explicit
conversion to a power series first, as in \kbd{x = gtoser(x, seriesprec)},
where the number of significant terms \kbd{seriesprec} can be specified
explicitly. If you do not do this, a global variable \kbd{precdl} is used
instead, to convert polynomials and rational functions to a power series with
a reasonable number of terms; tampering with the value of this global
variable is \emph{deprecated} and strongly discouraged.


\item If the argument is a vector or a matrix, the result is the
componentwise evaluation of the function. In particular, transcendental
functions on square matrices, which are not implemented in the present
version \vers, will have a different name if they are implemented some day.

\subseckbd{\pow} If $y$ is not of type integer, \kbd{x\pow y} has the same
effect as \kbd{exp(y*log(x))}. It can be applied to $p$-adic numbers as well
as to the more usual types.\sidx{powering}

The library syntax is \fun{GEN}{gpow}{GEN x, GEN n, long prec}
for $x\hbox{\kbd{\pow}}n$.


\subsec{Catalan}\kbdsidx{Catalan}\label{se:Catalan}
Catalan's constant $G = \sum_{n>=0}\dfrac{(-1)^n}{(2n+1)^2}=0.91596\cdots$.
Note that \kbd{Catalan} is one of the few reserved names which cannot be
used for user variables.

The library syntax is \fun{GEN}{mpcatalan}{long prec}.

\subsec{Euler}\kbdsidx{Euler}\label{se:Euler}
Euler's constant $\gamma=0.57721\cdots$. Note that
\kbd{Euler} is one of the few reserved names which cannot be used for
user variables.

The library syntax is \fun{GEN}{mpeuler}{long prec}.

\subsec{I}\kbdsidx{I}\label{se:I}
The complex number $\sqrt{-1}$.

The library syntax is \fun{GEN}{gen_I}{}.

\subsec{Pi}\kbdsidx{Pi}\label{se:Pi}
The constant $\pi$ ($3.14159\cdots$). Note that \kbd{Pi} is one of the few
reserved names which cannot be used for user variables.

The library syntax is \fun{GEN}{mppi}{long prec}.

\subsec{abs$(x)$}\kbdsidx{abs}\label{se:abs}
Absolute value of $x$ (modulus if $x$ is complex).
Rational functions are not allowed. Contrary to most transcendental
functions, an exact argument is \emph{not} converted to a real number before
applying \kbd{abs} and an exact result is returned if possible.
\bprog
? abs(-1)
%1 = 1
? abs(3/7 + 4/7*I)
%2 = 5/7
? abs(1 + I)
%3 = 1.414213562373095048801688724
@eprog\noindent
If $x$ is a polynomial, returns $-x$ if the leading coefficient is
real and negative else returns $x$. For a power series, the constant
coefficient is considered instead.

The library syntax is \fun{GEN}{gabs}{GEN x, long prec}.

\subsec{acos$(x)$}\kbdsidx{acos}\label{se:acos}
Principal branch of $\text{cos}^{-1}(x) = -i \log (x + i\sqrt{1-x^2})$.
In particular, $\text{Re(acos}(x))\in [0,\pi]$ and if $x\in \R$ and $|x|>1$,
then $\text{acos}(x)$ is complex. The branch cut is in two pieces:
$]-\infty,-1]$ , continuous with quadrant II, and $[1,+\infty[$, continuous
with quadrant IV. We have $\text{acos}(x) = \pi/2 - \text{asin}(x)$ for all
$x$.

The library syntax is \fun{GEN}{gacos}{GEN x, long prec}.

\subsec{acosh$(x)$}\kbdsidx{acosh}\label{se:acosh}
Principal branch of $\text{cosh}^{-1}(x) = 2
 \log(\sqrt{(x+1)/2} + \sqrt{(x-1)/2})$. In particular,
$\text{Re}(\text{acosh}(x))\geq 0$ and
$\text{In}(\text{acosh}(x))\in ]-\pi,\pi]0$; if $x\in \R$ and $x<1$, then
$\text{acosh}(x)$ is complex.

The library syntax is \fun{GEN}{gacosh}{GEN x, long prec}.

\subsec{agm$(x,y)$}\kbdsidx{agm}\label{se:agm}
Arithmetic-geometric mean of $x$ and $y$. In the
case of complex or negative numbers, the optimal AGM is returned
(the largest in absolute value over all choices of the signs of the square
roots).  $p$-adic or power series arguments are also allowed. Note that
a $p$-adic agm exists only if $x/y$ is congruent to 1 modulo $p$ (modulo
16 for $p=2$). $x$ and $y$ cannot both be vectors or matrices.

The library syntax is \fun{GEN}{agm}{GEN x, GEN y, long prec}.

\subsec{arg$(x)$}\kbdsidx{arg}\label{se:arg}
Argument of the complex number $x$, such that $-\pi<\text{arg}(x)\le\pi$.

The library syntax is \fun{GEN}{garg}{GEN x, long prec}.

\subsec{asin$(x)$}\kbdsidx{asin}\label{se:asin}
Principal branch of $\text{sin}^{-1}(x) = -i \log(ix + \sqrt{1 - x^2})$.
In particular, $\text{Re(asin}(x))\in [-\pi/2,\pi/2]$ and if $x\in \R$ and
$|x|>1$ then $\text{asin}(x)$ is complex. The branch cut is in two pieces:
$]-\infty,-1]$, continuous with quadrant II, and $[1,+\infty[$ continuous
with quadrant IV. The function satisfies $i \text{asin}(x) =
\text{asinh}(ix)$.

The library syntax is \fun{GEN}{gasin}{GEN x, long prec}.

\subsec{asinh$(x)$}\kbdsidx{asinh}\label{se:asinh}
Principal branch of $\text{sinh}^{-1}(x) = \log(x + \sqrt{1+x^2})$. In
particular $\text{Im(asinh}(x))\in [-\pi/2,\pi/2]$.
The branch cut is in two pieces: [-i oo ,-i],  continuous with quadrant III
and [i,+i oo [ continuous with quadrant I.

The library syntax is \fun{GEN}{gasinh}{GEN x, long prec}.

\subsec{atan$(x)$}\kbdsidx{atan}\label{se:atan}
Principal branch of $\text{tan}^{-1}(x) = \log ((1+ix)/(1-ix)) /
2i$. In particular the real part of $\text{atan}(x))$ belongs to
$]-\pi/2,\pi/2[$.
The branch cut is in two pieces:
$]-i\infty,-i[$, continuous with quadrant IV, and $]i,+i \infty[$ continuous
with quadrant II. The function satisfies $i \text{atan}(x) =
-i\text{atanh}(ix)$ for all $x\neq \pm i$.

The library syntax is \fun{GEN}{gatan}{GEN x, long prec}.

\subsec{atanh$(x)$}\kbdsidx{atanh}\label{se:atanh}
Principal branch of $\text{tanh}^{-1}(x) = log ((1+x)/(1-x)) / 2$. In
particular the imaginary part of $\text{atanh}(x)$ belongs to
$[-\pi/2,\pi/2]$; if $x\in \R$ and $|x|>1$ then $\text{atanh}(x)$ is complex.

The library syntax is \fun{GEN}{gatanh}{GEN x, long prec}.

\subsec{bernfrac$(x)$}\kbdsidx{bernfrac}\label{se:bernfrac}
Bernoulli number\sidx{Bernoulli numbers} $B_x$,
where $B_0=1$, $B_1=-1/2$, $B_2=1/6$,\dots, expressed as a rational number.
The argument $x$ should be of type integer.

The library syntax is \fun{GEN}{bernfrac}{long x}.

\subsec{bernpol$(n, \{v = 'x\})$}\kbdsidx{bernpol}\label{se:bernpol}
\idx{Bernoulli polynomial} $B_n$ in variable $v$.
\bprog
? bernpol(1)
%1 = x - 1/2
? bernpol(3)
%2 = x^3 - 3/2*x^2 + 1/2*x
@eprog

The library syntax is \fun{GEN}{bernpol}{long n, long v  = -1}, where \kbd{v } is a variable number.

\subsec{bernreal$(x)$}\kbdsidx{bernreal}\label{se:bernreal}
Bernoulli number\sidx{Bernoulli numbers}
$B_x$, as \kbd{bernfrac}, but $B_x$ is returned as a real number
(with the current precision).

The library syntax is \fun{GEN}{bernreal}{long x, long prec}.

\subsec{bernvec$(x)$}\kbdsidx{bernvec}\label{se:bernvec}
Creates a vector containing, as rational numbers,
the \idx{Bernoulli numbers} $B_0$, $B_2$,\dots, $B_{2x}$.
This routine is obsolete. Use \kbd{bernfrac} instead each time you need a
Bernoulli number in exact form.

\misctitle{Note} This routine is implemented using repeated independent
calls to \kbd{bernfrac}, which is faster than the standard recursion in exact
arithmetic. It is only kept for backward compatibility: it is not faster than
individual calls to \kbd{bernfrac}, its output uses a lot of memory space,
and coping with the index shift is awkward.

The library syntax is \fun{GEN}{bernvec}{long x}.

\subsec{besselh1$(\var{nu},x)$}\kbdsidx{besselh1}\label{se:besselh1}
$H^1$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{hbessel1}{GEN nu, GEN x, long prec}.

\subsec{besselh2$(\var{nu},x)$}\kbdsidx{besselh2}\label{se:besselh2}
$H^2$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{hbessel2}{GEN nu, GEN x, long prec}.

\subsec{besseli$(\var{nu},x)$}\kbdsidx{besseli}\label{se:besseli}
$I$-Bessel function of index \var{nu} and
argument $x$. If $x$ converts to a power series, the initial factor
$(x/2)^\nu/\Gamma(\nu+1)$ is omitted (since it cannot be represented in PARI
when $\nu$ is not integral).

The library syntax is \fun{GEN}{ibessel}{GEN nu, GEN x, long prec}.

\subsec{besselj$(\var{nu},x)$}\kbdsidx{besselj}\label{se:besselj}
$J$-Bessel function of index \var{nu} and
argument $x$. If $x$ converts to a power series, the initial factor
$(x/2)^\nu/\Gamma(\nu+1)$ is omitted (since it cannot be represented in PARI
when $\nu$ is not integral).

The library syntax is \fun{GEN}{jbessel}{GEN nu, GEN x, long prec}.

\subsec{besseljh$(n,x)$}\kbdsidx{besseljh}\label{se:besseljh}
$J$-Bessel function of half integral index.
More precisely, $\kbd{besseljh}(n,x)$ computes $J_{n+1/2}(x)$ where $n$
must be of type integer, and $x$ is any element of $\C$. In the
present version \vers, this function is not very accurate when $x$ is small.

The library syntax is \fun{GEN}{jbesselh}{GEN n, GEN x, long prec}.

\subsec{besselk$(\var{nu},x)$}\kbdsidx{besselk}\label{se:besselk}
$K$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{kbessel}{GEN nu, GEN x, long prec}.

\subsec{besseln$(\var{nu},x)$}\kbdsidx{besseln}\label{se:besseln}
$N$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{nbessel}{GEN nu, GEN x, long prec}.

\subsec{cos$(x)$}\kbdsidx{cos}\label{se:cos}
Cosine of $x$.

The library syntax is \fun{GEN}{gcos}{GEN x, long prec}.

\subsec{cosh$(x)$}\kbdsidx{cosh}\label{se:cosh}
Hyperbolic cosine of $x$.

The library syntax is \fun{GEN}{gcosh}{GEN x, long prec}.

\subsec{cotan$(x)$}\kbdsidx{cotan}\label{se:cotan}
Cotangent of $x$.

The library syntax is \fun{GEN}{gcotan}{GEN x, long prec}.

\subsec{dilog$(x)$}\kbdsidx{dilog}\label{se:dilog}
Principal branch of the dilogarithm of $x$,
i.e.~analytic continuation of the power series $\log_2(x)=\sum_{n\ge1}x^n/n^2$.

The library syntax is \fun{GEN}{dilog}{GEN x, long prec}.

\subsec{eint1$(x,\{n\})$}\kbdsidx{eint1}\label{se:eint1}
Exponential integral $\int_x^\infty \dfrac{e^{-t}}{t}\,dt =
\kbd{incgam}(0, x)$, where the latter expression extends the function
definition from real $x > 0$ to all complex $x \neq 0$.

If $n$ is present, we must have $x > 0$; the function returns the
$n$-dimensional vector $[\kbd{eint1}(x),\dots,\kbd{eint1}(nx)]$. Contrary to
other transcendental functions, and to the default case ($n$ omitted), the
values are correct up to a bounded \emph{absolute}, rather than relative,
error $10^-n$, where $n$ is \kbd{precision}$(x)$ if $x$ is a \typ{REAL}
and defaults to \kbd{realprecision} otherwise. (In the most important
application, to the computation of $L$-functions via approximate functional
equations, those values appear as weights in long sums and small individual
relative errors are less useful than controlling the absolute error.) This is
faster than repeatedly calling \kbd{eint1($i$ * x)}, but less precise.

The library syntax is \fun{GEN}{veceint1}{GEN x, GEN n = NULL, long prec}.
Also available is \fun{GEN}{eint1}{GEN x, long prec}.

\subsec{erfc$(x)$}\kbdsidx{erfc}\label{se:erfc}
Complementary error function, analytic continuation of
$(2/\sqrt\pi)\int_x^\infty e^{-t^2}\,dt = \kbd{incgam}(1/2,x^2)/\sqrt\pi$,
where the latter expression extends the function definition from real $x$ to
all complex $x \neq 0$.

The library syntax is \fun{GEN}{gerfc}{GEN x, long prec}.

\subsec{eta$(z,\{\fl=0\})$}\kbdsidx{eta}\label{se:eta}
Variants of \idx{Dedekind}'s $\eta$ function.
If $\fl = 0$, return $\prod_{n=1}^\infty(1-q^n)$, where $q$ depends on $x$
in the following way:

\item $q = e^{2i\pi x}$ if $x$ is a \emph{complex number} (which must then
have positive imaginary part); notice that the factor $q^{1/24}$ is
missing!

\item $q = x$ if $x$ is a \typ{PADIC}, or can be converted to a
\emph{power series} (which must then have positive valuation).

If $\fl$ is non-zero, $x$ is converted to a complex number and we return the
true $\eta$ function, $q^{1/24}\prod_{n=1}^\infty(1-q^n)$,
where $q = e^{2i\pi x}$.

The library syntax is \fun{GEN}{eta0}{GEN z, long flag, long prec}.

Also available is \fun{GEN}{trueeta}{GEN x, long prec} ($\fl=1$).

\subsec{exp$(x)$}\kbdsidx{exp}\label{se:exp}
Exponential of $x$.
$p$-adic arguments with positive valuation are accepted.

The library syntax is \fun{GEN}{gexp}{GEN x, long prec}.
For a \typ{PADIC} $x$, the function
\fun{GEN}{Qp_exp}{GEN x} is also available.

\subsec{expm1$(x)$}\kbdsidx{expm1}\label{se:expm1}
Return $\exp(x)-1$, computed in a way that is also accurate
when the real part of $x$ is near $0$. Only accept real or complex arguments.
A naive direct computation would suffer from catastrophic cancellation;
PARI's direct computation of $\exp(x)$ alleviates this well known problem at
the expense of computing $\exp(x)$ to a higher accuracy when $x$ is small.
Using \kbd{expm1} is recommended instead:
\bprog
? default(realprecision, 10000); x = 1e-100;
? a = expm1(x);
time = 4 ms.
? b = exp(x)-1;
time = 28 ms.
? default(realprecision, 10040); x = 1e-100;
? c = expm1(x);  \\ reference point
? abs(a-c)/c  \\ relative error in expm1(x)
%7 = 0.E-10017
? abs(b-c)/c  \\ relative error in exp(x)-1
%8 = 1.7907031188259675794 E-9919
@eprog\noindent As the example above shows, when $x$ is near $0$,
\kbd{expm1} is both faster and more accurate than \kbd{exp(x)-1}.

The library syntax is \fun{GEN}{gexpm1}{GEN x, long prec}.

\subsec{gamma$(s)$}\kbdsidx{gamma}\label{se:gamma}
For $s$ a complex number, evaluates Euler's gamma
function \sidx{gamma-function}
$$\Gamma(s)=\int_0^\infty t^{s-1}\exp(-t)\,dt.$$
Error if $s$ is a non-positive integer, where $\Gamma$ has a pole.

For $s$ a \typ{PADIC}, evaluates the Morita gamma function at $s$, that
is the unique continuous $p$-adic function on the $p$-adic integers
extending $\Gamma_p(k)=(-1)^k \prod_{j<k}'j$, where the prime means that $p$
does not divide $j$.
\bprog
? gamma(1/4 + O(5^10))
%1= 1 + 4*5 + 3*5^4 + 5^6 + 5^7 + 4*5^9 + O(5^10)
? algdep(%,4)
%2 = x^4 + 4*x^2 + 5
@eprog

The library syntax is \fun{GEN}{ggamma}{GEN s, long prec}.
For a \typ{PADIC} $x$, the function \fun{GEN}{Qp_gamma}{GEN x} is
also available.

\subsec{gammah$(x)$}\kbdsidx{gammah}\label{se:gammah}
Gamma function evaluated at the argument $x+1/2$.

The library syntax is \fun{GEN}{ggammah}{GEN x, long prec}.

\subsec{hyperu$(a,b,x)$}\kbdsidx{hyperu}\label{se:hyperu}
$U$-confluent hypergeometric function with
parameters $a$ and $b$. The parameters $a$ and $b$ can be complex but
the present implementation requires $x$ to be positive.

The library syntax is \fun{GEN}{hyperu}{GEN a, GEN b, GEN x, long prec}.

\subsec{incgam$(s,x,\{g\})$}\kbdsidx{incgam}\label{se:incgam}
Incomplete gamma function $\int_x^\infty e^{-t}t^{s-1}\,dt$, extended by
analytic continuation to all complex $x, s$ not both $0$. The relative error
is bounded in terms of the precision of $s$ (the accuracy of $x$ is ignored
when determining the output precision). When $g$ is given, assume that
$g=\Gamma(s)$. For small $|x|$, this will speed up the computation.

The library syntax is \fun{GEN}{incgam0}{GEN s, GEN x, GEN g = NULL, long prec}.
Also available is \fun{GEN}{incgam}{GEN s, GEN x, long prec}.

\subsec{incgamc$(s,x)$}\kbdsidx{incgamc}\label{se:incgamc}
Complementary incomplete gamma function.
The arguments $x$ and $s$ are complex numbers such that $s$ is not a pole of
$\Gamma$ and $|x|/(|s|+1)$ is not much larger than 1 (otherwise the
convergence is very slow). The result returned is $\int_0^x
e^{-t}t^{s-1}\,dt$.

The library syntax is \fun{GEN}{incgamc}{GEN s, GEN x, long prec}.

\subsec{lambertw$(y)$}\kbdsidx{lambertw}\label{se:lambertw}
Lambert $W$ function, solution of the implicit equation $xe^x=y$,
for $y > 0$.

The library syntax is \fun{GEN}{glambertW}{GEN y, long prec}.

\subsec{lngamma$(x)$}\kbdsidx{lngamma}\label{se:lngamma}
Principal branch of the logarithm of the gamma function of $x$. This
function is analytic on the complex plane with non-positive integers
removed, and can have much larger arguments than \kbd{gamma} itself.

For $x$ a power series such that $x(0)$ is not a pole of \kbd{gamma},
compute the Taylor expansion. (PARI only knows about regular power series
and can't include logarithmic terms.)
\bprog
? lngamma(1+x+O(x^2))
%1 = -0.57721566490153286060651209008240243104*x + O(x^2)
? lngamma(x+O(x^2))
 ***   at top-level: lngamma(x+O(x^2))
 ***                 ^-----------------
 *** lngamma: domain error in lngamma: valuation != 0
? lngamma(-1+x+O(x^2))
 *** lngamma: Warning: normalizing a series with 0 leading term.
 ***   at top-level: lngamma(-1+x+O(x^2))
 ***                 ^--------------------
 *** lngamma: domain error in intformal: residue(series, pole) != 0
@eprog

The library syntax is \fun{GEN}{glngamma}{GEN x, long prec}.

\subsec{log$(x)$}\kbdsidx{log}\label{se:log}
Principal branch of the natural logarithm of
$x \in \C^*$, i.e.~such that $\text{Im(log}(x))\in{} ]-\pi,\pi]$.
The branch cut lies
along the negative real axis, continuous with quadrant 2, i.e.~such that
$\lim_{b\to 0^+} \log (a+bi) = \log a$ for $a \in\R^*$. The result is complex
(with imaginary part equal to $\pi$) if $x\in \R$ and $x < 0$. In general,
the algorithm uses the formula
$$\log(x) \approx {\pi\over 2\text{agm}(1, 4/s)} - m \log 2, $$
if $s = x 2^m$ is large enough. (The result is exact to $B$ bits provided
$s > 2^{B/2}$.) At low accuracies, the series expansion near $1$ is used.

$p$-adic arguments are also accepted for $x$, with the convention that
$\log(p)=0$. Hence in particular $\exp(\log(x))/x$ is not in general equal to
1 but to a $(p-1)$-th root of unity (or $\pm1$ if $p=2$) times a power of $p$.

The library syntax is \fun{GEN}{glog}{GEN x, long prec}.
For a \typ{PADIC} $x$, the function
\fun{GEN}{Qp_log}{GEN x} is also available.

\subsec{polylog$(m,x,\{\fl=0\})$}\kbdsidx{polylog}\label{se:polylog}
One of the different polylogarithms, depending on \fl:

If $\fl=0$ or is omitted: $m^\text{th}$ polylogarithm of $x$, i.e.~analytic
continuation of the power series $\text{Li}_m(x)=\sum_{n\ge1}x^n/n^m$
($x < 1$). Uses the functional equation linking the values at $x$ and $1/x$
to restrict to the case $|x|\leq 1$, then the power series when
$|x|^2\le1/2$, and the power series expansion in $\log(x)$ otherwise.

Using $\fl$, computes a modified $m^\text{th}$ polylogarithm of $x$.
We use Zagier's notations; let $\Re_m$ denote $\Re$ or $\Im$ depending
on whether $m$ is odd or even:

If $\fl=1$: compute $\tilde D_m(x)$, defined for $|x|\le1$ by
$$\Re_m\left(\sum_{k=0}^{m-1} \dfrac{(-\log|x|)^k}{k!}\text{Li}_{m-k}(x)
+\dfrac{(-\log|x|)^{m-1}}{m!}\log|1-x|\right).$$

If $\fl=2$: compute $D_m(x)$, defined for $|x|\le1$ by
$$\Re_m\left(\sum_{k=0}^{m-1}\dfrac{(-\log|x|)^k}{k!}\text{Li}_{m-k}(x)
-\dfrac{1}{2}\dfrac{(-\log|x|)^m}{m!}\right).$$

If $\fl=3$: compute $P_m(x)$, defined for $|x|\le1$ by
$$\Re_m\left(\sum_{k=0}^{m-1}\dfrac{2^kB_k}{k!}(\log|x|)^k\text{Li}_{m-k}(x)
-\dfrac{2^{m-1}B_m}{m!}(\log|x|)^m\right).$$

These three functions satisfy the functional equation
$f_m(1/x) = (-1)^{m-1}f_m(x)$.

The library syntax is \fun{GEN}{polylog0}{long m, GEN x, long flag, long prec}.
Also available is
\fun{GEN}{gpolylog}{long m, GEN x, long prec} (\fl = 0).

\subsec{psi$(x)$}\kbdsidx{psi}\label{se:psi}
The $\psi$-function of $x$, i.e.~the logarithmic derivative
$\Gamma'(x)/\Gamma(x)$.

The library syntax is \fun{GEN}{gpsi}{GEN x, long prec}.

\subsec{sin$(x)$}\kbdsidx{sin}\label{se:sin}
Sine of $x$.

The library syntax is \fun{GEN}{gsin}{GEN x, long prec}.

\subsec{sinh$(x)$}\kbdsidx{sinh}\label{se:sinh}
Hyperbolic sine of $x$.

The library syntax is \fun{GEN}{gsinh}{GEN x, long prec}.

\subsec{sqr$(x)$}\kbdsidx{sqr}\label{se:sqr}
Square of $x$. This operation is not completely
straightforward, i.e.~identical to $x * x$, since it can usually be
computed more efficiently (roughly one-half of the elementary
multiplications can be saved). Also, squaring a $2$-adic number increases
its precision. For example,
\bprog
? (1 + O(2^4))^2
%1 = 1 + O(2^5)
? (1 + O(2^4)) * (1 + O(2^4))
%2 = 1 + O(2^4)
@eprog\noindent
Note that this function is also called whenever one multiplies two objects
which are known to be \emph{identical}, e.g.~they are the value of the same
variable, or we are computing a power.
\bprog
? x = (1 + O(2^4)); x * x
%3 = 1 + O(2^5)
? (1 + O(2^4))^4
%4 = 1 + O(2^6)
@eprog\noindent
(note the difference between \kbd{\%2} and \kbd{\%3} above).

The library syntax is \fun{GEN}{gsqr}{GEN x}.

\subsec{sqrt$(x)$}\kbdsidx{sqrt}\label{se:sqrt}
Principal branch of the square root of $x$, defined as $\sqrt{x} =
\exp(\log x / 2)$. In particular, we have
$\text{Arg}(\text{sqrt}(x))\in{} ]-\pi/2, \pi/2]$, and if $x\in \R$ and $x<0$,
then the result is complex with positive imaginary part.

Intmod a prime $p$, \typ{PADIC} and \typ{FFELT} are allowed as arguments. In
the first 2 cases (\typ{INTMOD}, \typ{PADIC}), the square root (if it
exists) which is returned is the one whose first $p$-adic digit is in the
interval $[0,p/2]$. For other arguments, the result is undefined.

The library syntax is \fun{GEN}{gsqrt}{GEN x, long prec}.
For a \typ{PADIC} $x$, the function
\fun{GEN}{Qp_sqrt}{GEN x} is also available.

\subsec{sqrtn$(x,n,\{\&z\})$}\kbdsidx{sqrtn}\label{se:sqrtn}
Principal branch of the $n$th root of $x$,
i.e.~such that $\text{Arg}(\text{sqrt}(x))\in{} ]-\pi/n, \pi/n]$. Intmod
a prime and $p$-adics are allowed as arguments.

If $z$ is present, it is set to a suitable root of unity allowing to
recover all the other roots. If it was not possible, z is
set to zero. In the case this argument is present and no square root exist,
$0$ is returned instead or raising an error.
\bprog
? sqrtn(Mod(2,7), 2)
%1 = Mod(4, 7)
? sqrtn(Mod(2,7), 2, &z); z
%2 = Mod(6, 7)
? sqrtn(Mod(2,7), 3)
  ***   at top-level: sqrtn(Mod(2,7),3)
  ***                 ^-----------------
  *** sqrtn: nth-root does not exist in gsqrtn.
? sqrtn(Mod(2,7), 3,  &z)
%2 = 0
? z
%3 = 0
@eprog

The following script computes all roots in all possible cases:
\bprog
sqrtnall(x,n)=
{ my(V,r,z,r2);
  r = sqrtn(x,n, &z);
  if (!z, error("Impossible case in sqrtn"));
  if (type(x) == "t_INTMOD" || type(x)=="t_PADIC",
    r2 = r*z; n = 1;
    while (r2!=r, r2*=z;n++));
  V = vector(n); V[1] = r;
  for(i=2, n, V[i] = V[i-1]*z);
  V
}
addhelp(sqrtnall,"sqrtnall(x,n):compute the vector of nth-roots of x");
@eprog\noindent

The library syntax is \fun{GEN}{gsqrtn}{GEN x, GEN n, GEN *z = NULL, long prec}.
If $x$ is a \typ{PADIC}, the function
\fun{GEN}{Qp_sqrt}{GEN x, GEN n, GEN *z} is also available.

\subsec{tan$(x)$}\kbdsidx{tan}\label{se:tan}
Tangent of $x$.

The library syntax is \fun{GEN}{gtan}{GEN x, long prec}.

\subsec{tanh$(x)$}\kbdsidx{tanh}\label{se:tanh}
Hyperbolic tangent of $x$.

The library syntax is \fun{GEN}{gtanh}{GEN x, long prec}.

\subsec{teichmuller$(x)$}\kbdsidx{teichmuller}\label{se:teichmuller}
Teichm\"uller character of the $p$-adic number $x$, i.e. the unique
$(p-1)$-th root of unity congruent to $x / p^{v_p(x)}$ modulo $p$.

The library syntax is \fun{GEN}{teich}{GEN x}.

\subsec{theta$(q,z)$}\kbdsidx{theta}\label{se:theta}
Jacobi sine theta-function
$$ \theta_1(z, q) = 2q^{1/4} \sum_{n\geq 0} (-1)^n q^{n(n+1)} \sin((2n+1)z).$$

The library syntax is \fun{GEN}{theta}{GEN q, GEN z, long prec}.

\subsec{thetanullk$(q,k)$}\kbdsidx{thetanullk}\label{se:thetanullk}
$k$-th derivative at $z=0$ of $\kbd{theta}(q,z)$.

The library syntax is \fun{GEN}{thetanullk}{GEN q, long k, long prec}.

\fun{GEN}{vecthetanullk}{GEN q, long k, long prec} returns the vector
of all $\dfrac{d^i\theta}{dz^i}(q,0)$ for all odd $i = 1, 3, \dots, 2k-1$.
\fun{GEN}{vecthetanullk_tau}{GEN tau, long k, long prec} returns
\kbd{vecthetanullk\_tau} at $q = \exp(2i\pi \kbd{tau})$.

\subsec{weber$(x,\{\fl=0\})$}\kbdsidx{weber}\label{se:weber}
One of Weber's three $f$ functions.
If $\fl=0$, returns
$$f(x)=\exp(-i\pi/24)\cdot\eta((x+1)/2)\,/\,\eta(x) \quad\hbox{such that}\quad
j=(f^{24}-16)^3/f^{24}\,,$$
where $j$ is the elliptic $j$-invariant  (see the function \kbd{ellj}).
If $\fl=1$, returns
$$f_1(x)=\eta(x/2)\,/\,\eta(x)\quad\hbox{such that}\quad
j=(f_1^{24}+16)^3/f_1^{24}\,.$$
Finally, if $\fl=2$, returns
$$f_2(x)=\sqrt{2}\eta(2x)\,/\,\eta(x)\quad\hbox{such that}\quad
j=(f_2^{24}+16)^3/f_2^{24}.$$
Note the identities $f^8=f_1^8+f_2^8$ and $ff_1f_2=\sqrt2$.

The library syntax is \fun{GEN}{weber0}{GEN x, long flag, long prec}.
Also available are \fun{GEN}{weberf}{GEN x, long prec},
\fun{GEN}{weberf1}{GEN x, long prec} and \fun{GEN}{weberf2}{GEN x, long prec}.

\subsec{zeta$(s)$}\kbdsidx{zeta}\label{se:zeta}
For $s$ a complex number, Riemann's zeta
function \sidx{Riemann zeta-function} $\zeta(s)=\sum_{n\ge1}n^{-s}$,
computed using the \idx{Euler-Maclaurin} summation formula, except
when $s$ is of type integer, in which case it is computed using
Bernoulli numbers\sidx{Bernoulli numbers} for $s\le0$ or $s>0$ and
even, and using modular forms for $s>0$ and odd.

For $s$ a $p$-adic number, Kubota-Leopoldt zeta function at $s$, that
is the unique continuous $p$-adic function on the $p$-adic integers
that interpolates the values of $(1 - p^{-k}) \zeta(k)$ at negative
integers $k$ such that $k \equiv 1 \pmod{p-1}$ (resp. $k$ is odd) if
$p$ is odd (resp. $p = 2$).

The library syntax is \fun{GEN}{gzeta}{GEN s, long prec}.
%SECTION: transcendental

\section{Arithmetic functions}\label{se:arithmetic}

These functions are by definition functions whose natural domain of
definition is either $\Z$ (or $\Z_{>0}$). The way these functions are used is
completely different from transcendental functions in that there are no
automatic type conversions: in general only integers are accepted as
arguments. An integer argument $N$ can be given in the following alternate
formats:

\item \typ{MAT}: its factorization \kbd{fa = factor($N$)},

\item \typ{VEC}: a pair \kbd{[$N$, fa]} giving both the integer and
  its factorization.

This allows to compute different arithmetic functions at a given $N$
while factoring the latter only once.

\bprog
  ? N = 10!; faN = factor(N);
  ? eulerphi(N)
  %2 = 829440
  ? eulerphi(faN)
  %3 = 829440
  ? eulerphi(S = [N, faN])
  %4 = 829440
  ? sigma(S)
  %5 = 15334088
@eprog

\subsec{Arithmetic functions and the factoring engine}
All arithmetic functions in the narrow sense of the word~--- Euler's
totient\sidx{Euler totient function} function, the \idx{Moebius} function,
the sums over divisors or powers of divisors etc.--- call, after trial
division by small primes, the same versatile factoring machinery described
under \kbd{factorint}. It includes \idx{Shanks SQUFOF}, \idx{Pollard Rho},
\idx{ECM} and \idx{MPQS} stages, and has an early exit option for the
functions \teb{moebius} and (the integer function underlying)
\teb{issquarefree}. This machinery relies on a fairly strong
probabilistic primality test, see \kbd{ispseudoprime}, but you may also set
\bprog
  default(factor_proven, 1)
@eprog\noindent to ensure that all tentative factorizations are fully proven.
This should not slow down PARI too much, unless prime numbers with
hundreds of decimal digits occur frequently in your application.

\subsec{Orders in finite groups and Discrete Logarithm functions}
\label{se:DLfun}

The following functions compute the order of an element in a finite group:
\kbd{ellorder} (the rational points on an elliptic curve defined over a
finite field), \kbd{fforder} (the multiplicative group of a finite field),
\kbd{znorder} (the invertible elements in $\Z/n\Z$). The following functions
compute discrete logarithms in the same groups (whenever this is meaningful)
\kbd{elllog}, \kbd{fflog}, \kbd{znlog}.

All such functions allow an optional argument specifying an integer
$N$, representing the order of the group. (The \emph{order} functions also
allows any non-zero multiple of the order, with a minor loss of efficiency.)
That optional argument follows the same format as given above:

\item \typ{INT}: the integer $N$,

\item \typ{MAT}: the factorization \kbd{fa = factor($N$)},

\item \typ{VEC}: this is the preferred format and provides both the
integer $N$ and its factorization in a two-component vector
\kbd{[$N$, fa]}.

When the group is fixed and many orders or discrete logarithms will be
computed, it is much more efficient to initialize this data once and for all
and pass it to the relevant functions, as in
\bprog
? p = nextprime(10^40);
? v = [p-1, factor(p-1)]; \\ data for discrete log & order computations
? znorder(Mod(2,p), v)
%3 = 500000000000000000000000000028
? g = znprimroot(p);
? znlog(2, g, v)
%5 = 543038070904014908801878611374
@eprog
\bigskip


\subsec{addprimes$(\{x=[\,]\})$}\kbdsidx{addprimes}\label{se:addprimes}
Adds the integers contained in the
vector $x$ (or the single integer $x$) to a special table of
``user-defined primes'', and returns that table. Whenever \kbd{factor} is
subsequently called, it will trial divide by the elements in this table.
If $x$ is empty or omitted, just returns the current list of extra
primes.

The entries in $x$ must be primes: there is no internal check, even if
the \tet{factor_proven} default is set. To remove primes from the list use
\kbd{removeprimes}.

The library syntax is \fun{GEN}{addprimes}{GEN x = NULL}.

\subsec{bestappr$(x, \{B\})$}\kbdsidx{bestappr}\label{se:bestappr}
Using variants of the extended Euclidean algorithm, returns a rational
approximation $a/b$ to $x$, whose denominator is limited
by $B$, if present. If $B$ is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
numbers, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, $B$ must be a positive real scalar (impose
$0 < b \leq B$).

\item If $x$ is a \typ{REAL} or a \typ{FRAC}, this function uses continued
fractions.
\bprog
? bestappr(Pi, 100)
%1 = 22/7
? bestappr(0.1428571428571428571428571429)
%2 = 1/7
? bestappr([Pi, sqrt(2) + 'x], 10^3)
%3 = [355/113, x + 1393/985]
@eprog
By definition, $a/b$ is the best rational approximation to $x$ if
$|b x - a| < |v x - u|$ for all integers $(u,v)$ with $0 < v \leq B$.
(Which implies that $n/d$ is a convergent of the continued fraction of $x$.)

\item If $x$ is a \typ{INTMOD} modulo $N$ or a \typ{PADIC} of precision $N =
p^k$, this function performs rational modular reconstruction modulo $N$. The
routine then returns the unique rational number $a/b$ in coprime integers
$|a| < N/2B$ and $b\leq B$ which is congruent to $x$ modulo $N$. Omitting
$B$ amounts to choosing it of the order of $\sqrt{N/2}$. If rational
reconstruction is not possible (no suitable $a/b$ exists), returns $[]$.
\bprog
? bestappr(Mod(18526731858, 11^10))
%1 = 1/7
? bestappr(Mod(18526731858, 11^20))
%2 = []
? bestappr(3 + 5 + 3*5^2 + 5^3 + 3*5^4 + 5^5 + 3*5^6 + O(5^7))
%2 = -1/3
@eprog\noindent In most concrete uses, $B$ is a prime power and we performed
Hensel lifting to obtain $x$.

The function applies recursively to components of complex objects
(polynomials, vectors, \dots). If rational reconstruction fails for even a
single entry, return $[]$.

The library syntax is \fun{GEN}{bestappr}{GEN x, GEN B = NULL}.

\subsec{bestapprPade$(x, \{B\})$}\kbdsidx{bestapprPade}\label{se:bestapprPade}
Using variants of the extended Euclidean algorithm, returns a rational
function approximation $a/b$ to $x$, whose denominator is limited
by $B$, if present. If $B$ is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
functions, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, $B$ must be a non-negative real (impose
$0 \leq \text{degree}(b) \leq B$).

\item If $x$ is a \typ{RFRAC} or \typ{SER}, this function uses continued
fractions.
\bprog
? bestapprPade((1-x^11)/(1-x)+O(x^11))
%1 = 1/(-x + 1)
? bestapprPade([1/(1+x+O(x^10)), (x^3-2)/(x^3+1)], 1)
%2 =  [1/(x + 1), -2]
@eprog

\item If $x$ is a \typ{POLMOD} modulo $N$ or a \typ{SER} of precision $N =
t^k$, this function performs rational modular reconstruction modulo $N$. The
routine then returns the unique rational function $a/b$ in coprime
polynomials, with $\text{degree}(b)\leq B$ which is congruent to $x$ modulo
$N$. Omitting $B$ amounts to choosing it of the order of $N/2$. If rational
reconstruction is not possible (no suitable $a/b$ exists), returns $[]$.
\bprog
? bestapprPade(Mod(1+x+x^2+x^3+x^4, x^4-2))
%1 = (2*x - 1)/(x - 1)
? % * Mod(1,x^4-2)
%2 = Mod(x^3 + x^2 + x + 3, x^4 - 2)
? bestapprPade(Mod(1+x+x^2+x^3+x^5, x^9))
%2 = []
? bestapprPade(Mod(1+x+x^2+x^3+x^5, x^10))
%3 = (2*x^4 + x^3 - x - 1)/(-x^5 + x^3 + x^2 - 1)
@eprog\noindent
The function applies recursively to components of complex objects
(polynomials, vectors, \dots). If rational reconstruction fails for even a
single entry, return $[]$.

The library syntax is \fun{GEN}{bestapprPade}{GEN x, long B}.

\subsec{bezout$(x,y)$}\kbdsidx{bezout}\label{se:bezout}
Deprecated alias for \kbd{gcdext}

The library syntax is \fun{GEN}{gcdext0}{GEN x, GEN y}.

\subsec{bigomega$(x)$}\kbdsidx{bigomega}\label{se:bigomega}
Number of prime divisors of the integer $|x|$ counted with
multiplicity:
\bprog
? factor(392)
%1 =
[2 3]

[7 2]

? bigomega(392)
%2 = 5;  \\ = 3+2
? omega(392)
%3 = 2;  \\ without multiplicity
@eprog

The library syntax is \fun{long}{bigomega}{GEN x}.

\subsec{binomial$(x,y)$}\kbdsidx{binomial}\label{se:binomial}
\idx{binomial coefficient} $\binom{x}{y}$.
Here $y$ must be an integer, but $x$ can be any PARI object.

The library syntax is \fun{GEN}{binomial}{GEN x, long y}.
The function
\fun{GEN}{binomialuu}{ulong n, ulong k} is also available, and so is
\fun{GEN}{vecbinome}{long n}, which returns a vector $v$
with $n+1$ components such that $v[k+1] = \kbd{binomial}(n,k)$ for $k$ from
$0$ up to $n$.

\subsec{chinese$(x,\{y\})$}\kbdsidx{chinese}\label{se:chinese}
If $x$ and $y$ are both intmods or both polmods, creates (with the same
type) a $z$ in the same residue class as $x$ and in the same residue class as
$y$, if it is possible.
\bprog
? chinese(Mod(1,2), Mod(2,3))
%1 = Mod(5, 6)
? chinese(Mod(x,x^2-1), Mod(x+1,x^2+1))
%2 = Mod(-1/2*x^2 + x + 1/2, x^4 - 1)
@eprog\noindent
This function also allows vector and matrix arguments, in which case the
operation is recursively applied to each component of the vector or matrix.
\bprog
? chinese([Mod(1,2),Mod(1,3)], [Mod(1,5),Mod(2,7)])
%3 = [Mod(1, 10), Mod(16, 21)]
@eprog\noindent
For polynomial arguments in the same variable, the function is applied to each
coefficient; if the polynomials have different degrees, the high degree terms
are copied verbatim in the result, as if the missing high degree terms in the
polynomial of lowest degree had been \kbd{Mod(0,1)}. Since the latter
behavior is usually \emph{not} the desired one, we propose to convert the
polynomials to vectors of the same length first:
\bprog
 ? P = x+1; Q = x^2+2*x+1;
 ? chinese(P*Mod(1,2), Q*Mod(1,3))
 %4 = Mod(1, 3)*x^2 + Mod(5, 6)*x + Mod(3, 6)
 ? chinese(Vec(P,3)*Mod(1,2), Vec(Q,3)*Mod(1,3))
 %5 = [Mod(1, 6), Mod(5, 6), Mod(4, 6)]
 ? Pol(%)
 %6 = Mod(1, 6)*x^2 + Mod(5, 6)*x + Mod(4, 6)
@eprog

If $y$ is omitted, and $x$ is a vector, \kbd{chinese} is applied recursively
to the components of $x$, yielding a residue belonging to the same class as all
components of $x$.

Finally $\kbd{chinese}(x,x) = x$ regardless of the type of $x$; this allows
vector arguments to contain other data, so long as they are identical in both
vectors.

The library syntax is \fun{GEN}{chinese}{GEN x, GEN y = NULL}.
\fun{GEN}{chinese1}{GEN x} is also available.

\subsec{content$(x)$}\kbdsidx{content}\label{se:content}
Computes the gcd of all the coefficients of $x$,
when this gcd makes sense. This is the natural definition
if $x$ is a polynomial (and by extension a power series) or a
vector/matrix. This is in general a weaker notion than the \emph{ideal}
generated by the coefficients:
\bprog
? content(2*x+y)
%1 = 1            \\ = gcd(2,y) over Q[y]
@eprog

If $x$ is a scalar, this simply returns the absolute value of $x$ if $x$ is
rational (\typ{INT} or \typ{FRAC}), and either $1$ (inexact input) or $x$
(exact input) otherwise; the result should be identical to \kbd{gcd(x, 0)}.

The content of a rational function is the ratio of the contents of the
numerator and the denominator. In recursive structures, if a
matrix or vector \emph{coefficient} $x$ appears, the gcd is taken
not with $x$, but with its content:
\bprog
? content([ [2], 4*matid(3) ])
%1 = 2
@eprog

The library syntax is \fun{GEN}{content}{GEN x}.

\subsec{contfrac$(x,\{b\},\{\var{nmax}\})$}\kbdsidx{contfrac}\label{se:contfrac}
Returns the row vector whose components are the partial quotients of the
\idx{continued fraction} expansion of $x$. In other words, a result
$[a_0,\dots,a_n]$ means that $x \approx a_0+1/(a_1+\dots+1/a_n)$. The
output is normalized so that $a_n \neq 1$ (unless we also have $n = 0$).

The number of partial quotients $n+1$ is limited by \kbd{nmax}. If
\kbd{nmax} is omitted, the expansion stops at the last significant partial
quotient.
\bprog
? \p19
  realprecision = 19 significant digits
? contfrac(Pi)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2]
? contfrac(Pi,, 3)  \\ n = 2
%2 = [3, 7, 15]
@eprog\noindent
$x$ can also be a rational function or a power series.

If a vector $b$ is supplied, the numerators are equal to the coefficients
of $b$, instead of all equal to $1$ as above; more precisely, $x \approx
(1/b_0)(a_0+b_1/(a_1+\dots+b_n/a_n))$; for a numerical continued fraction
($x$ real), the $a_i$ are integers, as large as possible; if $x$ is a
rational function, they are polynomials with $\deg a_i = \deg b_i + 1$.
The length of the result is then equal to the length of $b$, unless the next
partial quotient cannot be reliably computed, in which case the expansion
stops. This happens when a partial remainder is equal to zero (or too small
compared to the available significant digits for $x$ a \typ{REAL}).

A direct implementation of the numerical continued fraction
\kbd{contfrac(x,b)} described above would be
\bprog
\\ "greedy" generalized continued fraction
cf(x, b) =
{ my( a= vector(#b), t );

  x *= b[1];
  for (i = 1, #b,
    a[i] = floor(x);
    t = x - a[i]; if (!t || i == #b, break);
    x = b[i+1] / t;
  ); a;
}
@eprog\noindent There is some degree of freedom when choosing the $a_i$; the
program above can easily be modified to derive variants of the standard
algorithm. In the same vein, although no builtin
function implements the related \idx{Engel expansion} (a special kind of
\idx{Egyptian fraction} decomposition: $x = 1/a_1 + 1/(a_1a_2) + \dots$ ),
it can be obtained as follows:
\bprog
\\ n terms of the Engel expansion of x
engel(x, n = 10) =
{ my( u = x, a = vector(n) );
  for (k = 1, n,
    a[k] = ceil(1/u);
    u = u*a[k] - 1;
    if (!u, break);
  ); a
}
@eprog

\misctitle{Obsolete hack} (don't use this): If $b$ is an integer, \var{nmax}
is ignored and the command is understood as \kbd{contfrac($x,, b$)}.

The library syntax is \fun{GEN}{contfrac0}{GEN x, GEN b = NULL, long nmax}.
Also available are \fun{GEN}{gboundcf}{GEN x, long nmax},
\fun{GEN}{gcf}{GEN x} and \fun{GEN}{gcf2}{GEN b, GEN x}.

\subsec{contfracpnqn$(x, \{n=-1\})$}\kbdsidx{contfracpnqn}\label{se:contfracpnqn}
When $x$ is a vector or a one-row matrix, $x$
is considered as the list of partial quotients $[a_0,a_1,\dots,a_n]$ of a
rational number, and the result is the 2 by 2 matrix
$[p_n,p_{n-1};q_n,q_{n-1}]$ in the standard notation of continued fractions,
so $p_n/q_n=a_0+1/(a_1+\dots+1/a_n)$. If $x$ is a matrix with two rows
$[b_0,b_1,\dots,b_n]$ and $[a_0,a_1,\dots,a_n]$, this is then considered as a
generalized continued fraction and we have similarly
$p_n/q_n=(1/b_0)(a_0+b_1/(a_1+\dots+b_n/a_n))$. Note that in this case one
usually has $b_0=1$.

If $n \geq 0$ is present, returns all convergents from $p_0/q_0$ up to
$p_n/q_n$. (All convergents if $x$ is too small to compute the $n+1$
requested convergents.)
\bprog
? a=contfrac(Pi,20)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2]
? contfracpnqn(a,3)
%2 =
[3 22 333 355]

[1  7 106 113]

? contfracpnqn(a,7)
%3 =
[3 22 333 355 103993 104348 208341 312689]

[1  7 106 113  33102  33215  66317  99532]
@eprog

The library syntax is \fun{GEN}{contfracpnqn}{GEN x, long n}.
also available is \fun{GEN}{pnqn}{GEN x} for $n = -1$.

\subsec{core$(n,\{\fl=0\})$}\kbdsidx{core}\label{se:core}
If $n$ is an integer written as
$n=df^2$ with $d$ squarefree, returns $d$. If $\fl$ is non-zero,
returns the two-element row vector $[d,f]$. By convention, we write $0 = 0
\times 1^2$, so \kbd{core(0, 1)} returns $[0,1]$.

The library syntax is \fun{GEN}{core0}{GEN n, long flag}.
Also available are \fun{GEN}{core}{GEN n} ($\fl = 0$) and
\fun{GEN}{core2}{GEN n} ($\fl = 1$)

\subsec{coredisc$(n,\{\fl=0\})$}\kbdsidx{coredisc}\label{se:coredisc}
A \emph{fundamental discriminant} is an integer of the form $t\equiv 1
\mod 4$ or $4t \equiv 8,12 \mod 16$, with $t$ squarefree (i.e.~$1$ or the
discriminant of a quadratic number field). Given a non-zero integer
$n$, this routine returns the (unique) fundamental discriminant $d$
such that $n=df^2$, $f$ a positive rational number. If $\fl$ is non-zero,
returns the two-element row vector $[d,f]$. If $n$ is congruent to
0 or 1 modulo 4, $f$ is an integer, and a half-integer otherwise.

By convention, \kbd{coredisc(0, 1))} returns $[0,1]$.

Note that \tet{quaddisc}$(n)$ returns the same value as \kbd{coredisc}$(n)$,
and also works with rational inputs $n\in\Q^*$.

The library syntax is \fun{GEN}{coredisc0}{GEN n, long flag}.
Also available are \fun{GEN}{coredisc}{GEN n} ($\fl = 0$) and
\fun{GEN}{coredisc2}{GEN n} ($\fl = 1$)

\subsec{dirdiv$(x,y)$}\kbdsidx{dirdiv}\label{se:dirdiv}
$x$ and $y$ being vectors of perhaps different
lengths but with $y[1]\neq 0$ considered as \idx{Dirichlet series}, computes
the quotient of $x$ by $y$, again as a vector.

The library syntax is \fun{GEN}{dirdiv}{GEN x, GEN y}.

\subsec{direuler$(p=a,b,\var{expr},\{c\})$}\kbdsidx{direuler}\label{se:direuler}
Computes the \idx{Dirichlet series} associated to the
\idx{Euler product} of expression \var{expr} as $p$ ranges through the primes
from $a$
to $b$. \var{expr} must be a polynomial or rational function in another
variable than $p$ (say $X$) and $\var{expr}(X)$ is understood as the local
factor $\var{expr}(p^{-s})$.

The series is output as a vector of coefficients. If $c$ is present, output
only the first $c$ coefficients in the series. The following command computes
the \teb{sigma} function, associated to $\zeta(s)\zeta(s-1)$:
\bprog
? direuler(p=2, 10, 1/((1-X)*(1-p*X)))
%1 = [1, 3, 4, 7, 6, 12, 8, 15, 13, 18]
@eprog

\synt{direuler}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b}

\subsec{dirmul$(x,y)$}\kbdsidx{dirmul}\label{se:dirmul}
$x$ and $y$ being vectors of perhaps different lengths representing
the \idx{Dirichlet series} $\sum_n x_n n^{-s}$ and $\sum_n y_n n^{-s}$,
computes the product of $x$ by $y$, again as a vector.
\bprog
? dirmul(vector(10,n,1), vector(10,n,moebius(n)))
%1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
@eprog\noindent
The product
length is the minimum of $\kbd{\#}x\kbd{*}v(y)$ and $\kbd{\#}y\kbd{*}v(x)$,
where $v(x)$ is the index of the first non-zero coefficient.
\bprog
? dirmul([0,1], [0,1]);
%2 = [0, 0, 0, 1]
@eprog

The library syntax is \fun{GEN}{dirmul}{GEN x, GEN y}.

\subsec{divisors$(x)$}\kbdsidx{divisors}\label{se:divisors}
Creates a row vector whose components are the
divisors of $x$. The factorization of $x$ (as output by \tet{factor}) can
be used instead.

By definition, these divisors are the products of the irreducible
factors of $n$, as produced by \kbd{factor(n)}, raised to appropriate
powers (no negative exponent may occur in the factorization). If $n$ is
an integer, they are the positive divisors, in increasing order.

The library syntax is \fun{GEN}{divisors}{GEN x}.

\subsec{eulerphi$(x)$}\kbdsidx{eulerphi}\label{se:eulerphi}
Euler's $\phi$ (totient)\sidx{Euler totient function} function of the
integer $|x|$, in other words $|(\Z/x\Z)^*|$.
\bprog
? eulerphi(40)
%1 = 16
@eprog\noindent
According to this definition we let $\phi(0) := 2$, since $\Z^* = \{-1,1\}$;
this is consistent with \kbd{znstar(0)}: we have \kbd{znstar$(n)$.no =
eulerphi(n)} for all $n\in\Z$.

The library syntax is \fun{GEN}{eulerphi}{GEN x}.

\subsec{factor$(x,\{\var{lim}\})$}\kbdsidx{factor}\label{se:factor}
General factorization function, where $x$ is a
rational (including integers), a complex number with rational
real and imaginary parts, or a rational function (including polynomials).
The result is a two-column matrix: the first contains the irreducibles
dividing $x$ (rational or Gaussian primes, irreducible polynomials),
and the second the exponents. By convention, $0$ is factored as $0^1$.

\misctitle{$\Q$ and $\Q(i)$}
See \tet{factorint} for more information about the algorithms used.
The rational or Gaussian primes are in fact \var{pseudoprimes}
(see \kbd{ispseudoprime}), a priori not rigorously proven primes. In fact,
any factor which is $\leq 2^{64}$ (whose norm is $\leq 2^{64}$ for an
irrational Gaussian prime) is a genuine prime. Use \kbd{isprime} to prove
primality of other factors, as in
\bprog
? fa = factor(2^2^7 + 1)
%1 =
[59649589127497217 1]

[5704689200685129054721 1]

? isprime( fa[,1] )
%2 = [1, 1]~   \\ both entries are proven primes
@eprog\noindent
Another possibility is to set the global default \tet{factor_proven}, which
will perform a rigorous primality proof for each pseudoprime factor.

A \typ{INT} argument \var{lim} can be added, meaning that we look only for
prime factors $p < \var{lim}$. The limit \var{lim} must be non-negative.
In this case, all but the last factor are proven primes, but the remaining
factor may actually be a proven composite! If the remaining factor is less
than $\var{lim}^2$, then it is prime.
\bprog
? factor(2^2^7 +1, 10^5)
%3 =
[340282366920938463463374607431768211457 1]
@eprog\noindent
\misctitle{Deprecated feature} Setting $\var{lim}=0$ is the same
as setting it to $\kbd{primelimit} + 1$. Don't use this: it is unwise to
rely on global variables when you can specify an explicit argument.
\smallskip

This routine uses trial division and perfect power tests, and should not be
used for huge values of \var{lim} (at most $10^9$, say):
\kbd{factorint(, 1 + 8)} will in general be faster. The latter does not
guarantee that all small
prime factors are found, but it also finds larger factors, and in a much more
efficient way.
\bprog
? F = (2^2^7 + 1) * 1009 * 100003; factor(F, 10^5)  \\ fast, incomplete
time = 0 ms.
%4 =
[1009 1]

[34029257539194609161727850866999116450334371 1]

? factor(F, 10^9)    \\ very slow
time = 6,892 ms.
%6 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factorint(F, 1+8)  \\ much faster, all small primes were found
time = 12 ms.
%7 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factor(F)   \\ complete factorisation
time = 112 ms.
%8 =
[1009 1]

[100003 1]

[59649589127497217 1]

[5704689200685129054721 1]
@eprog\noindent Over $\Q$, the prime factors are sorted in increasing order.

\misctitle{Rational functions}
The polynomials or rational functions to be factored must have scalar
coefficients. In particular PARI does not know how to factor
\emph{multivariate} polynomials. The following domains are currently
supported: $\Q$, $\R$, $\C$, $\Q_p$, finite fields and number fields.
See \tet{factormod} and \tet{factorff} for
the algorithms used over finite fields, \tet{factornf} for the algorithms
over number fields. Over $\Q$, \idx{van Hoeij}'s method is used, which is
able to cope with hundreds of modular factors.

The routine guesses a sensible ring over which to factor: the
smallest ring containing all coefficients, taking into account quotient
structures induced by \typ{INTMOD}s and \typ{POLMOD}s (e.g.~if a coefficient
in $\Z/n\Z$ is known, all rational numbers encountered are first mapped to
$\Z/n\Z$; different moduli will produce an error). Factoring modulo a
non-prime number is not supported; to factor in $\Q_p$, use \typ{PADIC}
coefficients not \typ{INTMOD} modulo $p^n$.
\bprog
? T = x^2+1;
? factor(T);                         \\ over Q
? factor(T*Mod(1,3))                 \\ over F_3
? factor(T*ffgen(ffinit(3,2,'t))^0)  \\ over F_{3^2}
? factor(T*Mod(Mod(1,3), t^2+t+2))   \\ over F_{3^2}, again
? factor(T*(1 + O(3^6))              \\ over Q_3, precision 6
? factor(T*1.)                       \\ over R, current precision
? factor(T*(1.+0.*I))                \\ over C
? factor(T*Mod(1, y^3-2))            \\ over Q(2^{1/3})
@eprog\noindent In most cases, it is clearer and simpler to call an
explicit variant than to rely on the generic \kbd{factor} function and
the above detection mechanism:
\bprog
? factormod(T, 3)           \\ over F_3
? factorff(T, 3, t^2+t+2))  \\ over F_{3^2}
? factorpadic(T, 3,6)       \\ over Q_3, precision 6
? nffactor(y^3-2, T)        \\ over Q(2^{1/3})
? polroots(T)               \\ over C
@eprog

Note that factorization of polynomials is done up to
multiplication by a constant. In particular, the factors of rational
polynomials will have integer coefficients, and the content of a polynomial
or rational function is discarded and not included in the factorization. If
needed, you can always ask for the content explicitly:
\bprog
? factor(t^2 + 5/2*t + 1)
%1 =
[2*t + 1 1]

[t + 2 1]

? content(t^2 + 5/2*t + 1)
%2 = 1/2
@eprog\noindent
The irreducible factors are sorted by increasing degree.
See also \tet{nffactor}.

The library syntax is \fun{GEN}{gp_factor0}{GEN x, GEN lim = NULL}.
This function should only be used by the \kbd{gp} interface. Use
directly \fun{GEN}{factor}{GEN x} or \fun{GEN}{boundfact}{GEN x, ulong lim}.
The obsolete function \fun{GEN}{factor0}{GEN x, long lim} is kept for
backward compatibility.

\subsec{factorback$(f,\{e\})$}\kbdsidx{factorback}\label{se:factorback}
Gives back the factored object
corresponding to a factorization. The integer $1$ corresponds to the empty
factorization.

If $e$ is present, $e$ and $f$ must be vectors of the same length ($e$ being
integral), and the corresponding factorization is the product of the
$f[i]^{e[i]}$.

If not, and $f$ is vector, it is understood as in the preceding case with $e$
a vector of 1s: we return the product of the $f[i]$. Finally, $f$ can be a
regular factorization, as produced with any \kbd{factor} command. A few
examples:
\bprog
? factor(12)
%1 =
[2 2]

[3 1]

? factorback(%)
%2 = 12
? factorback([2,3], [2,1])   \\ 2^3 * 3^1
%3 = 12
? factorback([5,2,3])
%4 = 30
@eprog

The library syntax is \fun{GEN}{factorback2}{GEN f, GEN e = NULL}.
Also available is \fun{GEN}{factorback}{GEN f} (case $e = \kbd{NULL}$).

\subsec{factorcantor$(x,p)$}\kbdsidx{factorcantor}\label{se:factorcantor}
Factors the polynomial $x$ modulo the
prime $p$, using distinct degree plus
\idx{Cantor-Zassenhaus}\sidx{Zassenhaus}. The coefficients of $x$ must be
operation-compatible with $\Z/p\Z$. The result is a two-column matrix, the
first column being the irreducible polynomials dividing $x$, and the second
the exponents. If you want only the \emph{degrees} of the irreducible
polynomials (for example for computing an $L$-function), use
$\kbd{factormod}(x,p,1)$. Note that the \kbd{factormod} algorithm is
usually faster than \kbd{factorcantor}.

The library syntax is \fun{GEN}{factcantor}{GEN x, GEN p}.

\subsec{factorff$(x,\{p\},\{a\})$}\kbdsidx{factorff}\label{se:factorff}
Factors the polynomial $x$ in the field
$\F_q$ defined by the irreducible polynomial $a$ over $\F_p$. The
coefficients of $x$ must be operation-compatible with $\Z/p\Z$. The result
is a two-column matrix: the first column contains the irreducible factors of
$x$, and the second their exponents. If all the coefficients of $x$ are in
$\F_p$, a much faster algorithm is applied, using the computation of
isomorphisms between finite fields.

Either $a$ or $p$ can omitted (in which case both are ignored) if x has
\typ{FFELT} coefficients; the function then becomes identical to \kbd{factor}:
\bprog
? factorff(x^2 + 1, 5, y^2+3)  \\ over F_5[y]/(y^2+3) ~ F_25
%1 =
[Mod(Mod(1, 5), Mod(1, 5)*y^2 + Mod(3, 5))*x
 + Mod(Mod(2, 5), Mod(1, 5)*y^2 + Mod(3, 5)) 1]

[Mod(Mod(1, 5), Mod(1, 5)*y^2 + Mod(3, 5))*x
 + Mod(Mod(3, 5), Mod(1, 5)*y^2 + Mod(3, 5)) 1]
? t = ffgen(y^2 + Mod(3,5), 't); \\ a generator for F_25 as a t_FFELT
? factorff(x^2 + 1)   \\ not enough information to determine the base field
 ***   at top-level: factorff(x^2+1)
 ***                 ^---------------
 *** factorff: incorrect type in factorff.
? factorff(x^2 + t^0) \\ make sure a coeff. is a t_FFELT
%3 =
[x + 2 1]

[x + 3 1]
? factorff(x^2 + t + 1)
%11 =
[x + (2*t + 1) 1]

[x + (3*t + 4) 1]
@eprog\noindent
Notice that the second syntax is easier to use and much more readable.

The library syntax is \fun{GEN}{factorff}{GEN x, GEN p = NULL, GEN a = NULL}.

\subsec{factorial$(x)$}\kbdsidx{factorial}\label{se:factorial}
Factorial of $x$. The expression $x!$ gives a result which is an integer,
while $\kbd{factorial}(x)$ gives a real number.

The library syntax is \fun{GEN}{mpfactr}{long x, long prec}.
\fun{GEN}{mpfact}{long x} returns $x!$ as a \typ{INT}.

\subsec{factorint$(x,\{\fl=0\})$}\kbdsidx{factorint}\label{se:factorint}
Factors the integer $n$ into a product of
pseudoprimes (see \kbd{ispseudoprime}), using a combination of the
\idx{Shanks SQUFOF} and \idx{Pollard Rho} method (with modifications due to
Brent), \idx{Lenstra}'s \idx{ECM} (with modifications by Montgomery), and
\idx{MPQS} (the latter adapted from the \idx{LiDIA} code with the kind
permission of the LiDIA maintainers), as well as a search for pure powers.
The output is a two-column matrix as for \kbd{factor}: the first column
contains the ``prime'' divisors of $n$, the second one contains the
(positive) exponents.

By convention $0$ is factored as $0^1$, and $1$ as the empty factorization;
also the divisors are by default not proven primes is they are larger than
$2^{64}$, they only failed the BPSW compositeness test (see
\tet{ispseudoprime}). Use \kbd{isprime} on the result if you want to
guarantee primality or set the \tet{factor_proven} default to $1$.
Entries of the private prime tables (see \tet{addprimes}) are also included
as is.

This gives direct access to the integer factoring engine called by most
arithmetical functions. \fl\ is optional; its binary digits mean 1: avoid
MPQS, 2: skip first stage ECM (we may still fall back to it later), 4: avoid
Rho and SQUFOF, 8: don't run final ECM (as a result, a huge composite may be
declared to be prime). Note that a (strong) probabilistic primality test is
used; thus composites might not be detected, although no example is known.

You are invited to play with the flag settings and watch the internals at
work by using \kbd{gp}'s \tet{debug} default parameter (level 3 shows
just the outline, 4 turns on time keeping, 5 and above show an increasing
amount of internal details).

The library syntax is \fun{GEN}{factorint}{GEN x, long flag}.

\subsec{factormod$(x,p,\{\fl=0\})$}\kbdsidx{factormod}\label{se:factormod}
Factors the polynomial $x$ modulo the prime integer $p$, using
\idx{Berlekamp}. The coefficients of $x$ must be operation-compatible with
$\Z/p\Z$. The result is a two-column matrix, the first column being the
irreducible polynomials dividing $x$, and the second the exponents. If $\fl$
is non-zero, outputs only the \emph{degrees} of the irreducible polynomials
(for example, for computing an $L$-function). A different algorithm for
computing the mod $p$ factorization is \kbd{factorcantor} which is sometimes
faster.

The library syntax is \fun{GEN}{factormod0}{GEN x, GEN p, long flag}.

\subsec{ffgen$(q,\{v\})$}\kbdsidx{ffgen}\label{se:ffgen}
Return a \typ{FFELT} generator for the finite field with $q$ elements;
$q = p^f$ must be a prime power. This functions computes an irreducible
monic polynomial $P\in\F_p[X]$ of degree~$f$ (via \tet{ffinit}) and
returns $g = X \pmod{P(X)}$. If \kbd{v} is given, the variable name is used
to display $g$, else the variable $x$ is used.
\bprog
? g = ffgen(8, 't);
? g.mod
%2 = t^3 + t^2 + 1
? g.p
%3 = 2
? g.f
%4 = 3
? ffgen(6)
 ***   at top-level: ffgen(6)
 ***                 ^--------
 *** ffgen: not a prime number in ffgen: 6.
@eprog\noindent Alternative syntax: instead of a prime power $q$, one may
input directly the polynomial $P$ (monic, irreducible, with \typ{INTMOD}
coefficients), and the function returns the generator $g = X \pmod{P(X)}$,
inferring $p$ from the coefficients of $P$. If \kbd{v} is given, the
variable name is used to display $g$, else the variable of the polynomial
$P$ is used. If $P$ is not irreducible, we create an invalid object and
behaviour of functions dealing with the resulting \typ{FFELT}
is undefined; in fact, it is much more costly to test $P$ for
irreducibility than it would be to produce it via \kbd{ffinit}.

The library syntax is \fun{GEN}{ffgen}{GEN q, long v = -1}, where \kbd{v} is a variable number.

To create a generator for a prime finite field, the function
\fun{GEN}{p_to_GEN}{GEN p, long v} returns \kbd{1+ffgen(x*Mod(1,p),v)}.

\subsec{ffinit$(p,n,\{v='x\})$}\kbdsidx{ffinit}\label{se:ffinit}
Computes a monic polynomial of degree $n$ which is irreducible over
 $\F_p$, where $p$ is assumed to be prime. This function uses a fast variant
 of Adleman and Lenstra's algorithm.

It is useful in conjunction with \tet{ffgen}; for instance if
\kbd{P = ffinit(3,2)}, you can represent elements in $\F_{3^2}$ in term of
\kbd{g = ffgen(P,'t)}. This can be abbreviated as
\kbd{g = ffgen(3\pow2, 't)}, where the defining polynomial $P$ can be later
recovered as \kbd{g.mod}.

The library syntax is \fun{GEN}{ffinit}{GEN p, long n, long v = -1}, where \kbd{v} is a variable number.

\subsec{fflog$(x,g,\{o\})$}\kbdsidx{fflog}\label{se:fflog}
Discrete logarithm of the finite field element $x$ in base $g$, i.e.~
an $e$ in $\Z$ such that $g^e = o$. If
present, $o$ represents the multiplicative order of $g$, see
\secref{se:DLfun}; the preferred format for
this parameter is \kbd{[ord, factor(ord)]}, where \kbd{ord} is the
order of $g$. It may be set as a side effect of calling \tet{ffprimroot}.

If no $o$ is given, assume that $g$ is a primitive root. The result is
undefined if $e$ does not exist. This function uses

\item a combination of generic discrete log algorithms (see \tet{znlog})

\item a cubic sieve index calculus algorithm for large fields of degree at
least $5$.

\item Coppersmith's algorithm for fields of characteristic at most $5$.

\bprog
? t = ffgen(ffinit(7,5));
? o = fforder(t)
%2 = 5602   \\@com \emph{not} a primitive root.
? fflog(t^10,t)
%3 = 10
? fflog(t^10,t, o)
%4 = 10
? g = ffprimroot(t, &o);
? o   \\ order is 16806, bundled with its factorization matrix
%6 = [16806, [2, 1; 3, 1; 2801, 1]]
? fforder(g, o)
%7 = 16806
? fflog(g^10000, g, o)
%8 = 10000
@eprog

The library syntax is \fun{GEN}{fflog}{GEN x, GEN g, GEN o = NULL}.

\subsec{ffnbirred$(q,n\{,\var{fl}=0\})$}\kbdsidx{ffnbirred}\label{se:ffnbirred}
Computes the number of monic irreducible polynomials over $\F_q$ of degree exactly $n$,
($\fl=0$ or omitted) or at most $n$ ($\fl=1$).

The library syntax is \fun{GEN}{ffnbirred0}{GEN q, long n, long fl}.
Also available are
 \fun{GEN}{ffnbirred}{GEN q, long n} (for $\fl=0$)
 and \fun{GEN}{ffsumnbirred}{GEN q, long n} (for $\fl=1$).

\subsec{fforder$(x,\{o\})$}\kbdsidx{fforder}\label{se:fforder}
Multiplicative order of the finite field element $x$.  If $o$ is
present, it represents a multiple of the order of the element,
see \secref{se:DLfun}; the preferred format for
this parameter is \kbd{[N, factor(N)]}, where \kbd{N} is the cardinality
of the multiplicative group of the underlying finite field.
\bprog
? t = ffgen(ffinit(nextprime(10^8), 5));
? g = ffprimroot(t, &o);  \\@com o will be useful!
? fforder(g^1000000, o)
time = 0 ms.
%5 = 5000001750000245000017150000600250008403
? fforder(g^1000000)
time = 16 ms. \\@com noticeably slower, same result of course
%6 = 5000001750000245000017150000600250008403
@eprog

The library syntax is \fun{GEN}{fforder}{GEN x, GEN o = NULL}.

\subsec{ffprimroot$(x, \{\&o\})$}\kbdsidx{ffprimroot}\label{se:ffprimroot}
Return a primitive root of the multiplicative
group of the definition field of the finite field element $x$ (not necessarily
the same as the field generated by $x$). If present, $o$ is set to
a vector \kbd{[ord, fa]}, where \kbd{ord} is the order of the group
and \kbd{fa} its factorisation \kbd{factor(ord)}. This last parameter is
useful in \tet{fflog} and \tet{fforder}, see \secref{se:DLfun}.
\bprog
? t = ffgen(ffinit(nextprime(10^7), 5));
? g = ffprimroot(t, &o);
? o[1]
%3 = 100000950003610006859006516052476098
? o[2]
%4 =
[2 1]

[7 2]

[31 1]

[41 1]

[67 1]

[1523 1]

[10498781 1]

[15992881 1]

[46858913131 1]

? fflog(g^1000000, g, o)
time = 1,312 ms.
%5 = 1000000
@eprog

The library syntax is \fun{GEN}{ffprimroot}{GEN x, GEN *o = NULL}.

\subsec{fibonacci$(x)$}\kbdsidx{fibonacci}\label{se:fibonacci}
$x^{\text{th}}$ Fibonacci number.

The library syntax is \fun{GEN}{fibo}{long x}.

\subsec{gcd$(x,\{y\})$}\kbdsidx{gcd}\label{se:gcd}
Creates the greatest common divisor of $x$ and $y$.
If you also need the $u$ and $v$ such that $x*u + y*v = \gcd(x,y)$,
use the \tet{bezout} function. $x$ and $y$ can have rather quite general
types, for instance both rational numbers. If $y$ is omitted and $x$ is a
vector, returns the $\text{gcd}$ of all components of $x$, i.e.~this is
equivalent to \kbd{content(x)}.

When $x$ and $y$ are both given and one of them is a vector/matrix type,
the GCD is again taken recursively on each component, but in a different way.
If $y$ is a vector, resp.~matrix, then the result has the same type as $y$,
and components equal to \kbd{gcd(x, y[i])}, resp.~\kbd{gcd(x, y[,i])}. Else
if $x$ is a vector/matrix the result has the same type as $x$ and an
analogous definition. Note that for these types, \kbd{gcd} is not
commutative.

The algorithm used is a naive \idx{Euclid} except for the following inputs:

\item integers: use modified right-shift binary (``plus-minus''
variant).

\item univariate polynomials with coefficients in the same number
field (in particular rational): use modular gcd algorithm.

\item general polynomials: use the \idx{subresultant algorithm} if
coefficient explosion is likely (non modular coefficients).

If $u$ and $v$ are polynomials in the same variable with \emph{inexact}
coefficients, their gcd is defined to be scalar, so that
\bprog
? a = x + 0.0; gcd(a,a)
%1 = 1
? b = y*x + O(y); gcd(b,b)
%2 = y
? c = 4*x + O(2^3); gcd(c,c)
%3 = 4
@eprog\noindent A good quantitative check to decide whether such a
gcd ``should be'' non-trivial, is to use \tet{polresultant}: a value
close to $0$ means that a small deformation of the inputs has non-trivial gcd.
You may also use \tet{gcdext}, which does try to compute an approximate gcd
$d$ and provides $u$, $v$ to check whether $u x + v y$ is close to $d$.

The library syntax is \fun{GEN}{ggcd0}{GEN x, GEN y = NULL}.
Also available are \fun{GEN}{ggcd}{GEN x, GEN y}, if \kbd{y} is not
\kbd{NULL}, and \fun{GEN}{content}{GEN x}, if $\kbd{y} = \kbd{NULL}$.

\subsec{gcdext$(x,y)$}\kbdsidx{gcdext}\label{se:gcdext}
Returns $[u,v,d]$ such that $d$ is the gcd of $x,y$,
$x*u+y*v=\gcd(x,y)$, and $u$ and $v$ minimal in a natural sense.
The arguments must be integers or polynomials. \sidx{extended gcd}
\sidx{Bezout relation}
\bprog
? [u, v, d] = gcdext(32,102)
%1 = [16, -5, 2]
? d
%2 = 2
? gcdext(x^2-x, x^2+x-2)
%3 = [-1/2, 1/2, x - 1]
@eprog

If $x,y$ are polynomials in the same variable and \emph{inexact}
coefficients, then compute $u,v,d$ such that $x*u+y*v = d$, where $d$
approximately divides both and $x$ and $y$; in particular, we do not obtain
\kbd{gcd(x,y)} which is \emph{defined} to be a scalar in this case:
\bprog
? a = x + 0.0; gcd(a,a)
%1 = 1

? gcdext(a,a)
%2 = [0, 1, x + 0.E-28]

? gcdext(x-Pi, 6*x^2-zeta(2))
%3 = [-6*x - 18.8495559, 1, 57.5726923]
@eprog\noindent For inexact inputs, the output is thus not well defined
mathematically, but you obtain explicit polynomials to check whether the
approximation is close enough for your needs.

The library syntax is \fun{GEN}{gcdext0}{GEN x, GEN y}.

\subsec{hilbert$(x,y,\{p\})$}\kbdsidx{hilbert}\label{se:hilbert}
\idx{Hilbert symbol} of $x$ and $y$ modulo the prime $p$, $p=0$ meaning
the place at infinity (the result is undefined if $p\neq 0$ is not prime).

It is possible to omit $p$, in which case we take $p = 0$ if both $x$
and $y$ are rational, or one of them is a real number. And take $p = q$
if one of $x$, $y$ is a \typ{INTMOD} modulo $q$ or a $q$-adic. (Incompatible
types will raise an error.)

The library syntax is \fun{long}{hilbert}{GEN x, GEN y, GEN p = NULL}.

\subsec{isfundamental$(x)$}\kbdsidx{isfundamental}\label{se:isfundamental}
True (1) if $x$ is equal to 1 or to the discriminant of a quadratic
field, false (0) otherwise.

The library syntax is \fun{long}{isfundamental}{GEN x}.

\subsec{ispolygonal$(x,s,\{\&N\})$}\kbdsidx{ispolygonal}\label{se:ispolygonal}
True (1) if the integer $x$ is an s-gonal number, false (0) if not.
The parameter $s > 2$ must be a \typ{INT}. If $N$ is given, set it to $n$
if $x$ is the $n$-th $s$-gonal number.
\bprog
? ispolygonal(36, 3, &N)
%1 = 1
? N
@eprog

The library syntax is \fun{long}{ispolygonal}{GEN x, GEN s, GEN *N = NULL}.

\subsec{ispower$(x,\{k\},\{\&n\})$}\kbdsidx{ispower}\label{se:ispower}
If $k$ is given, returns true (1) if $x$ is a $k$-th power, false
(0) if not.

If $k$ is omitted, only integers and fractions are allowed for $x$ and the
function returns the maximal $k \geq 2$ such that $x = n^k$ is a perfect
power, or 0 if no such $k$ exist; in particular \kbd{ispower(-1)},
\kbd{ispower(0)}, and \kbd{ispower(1)} all return $0$.

If a third argument $\&n$ is given and $x$ is indeed a $k$-th power, sets
$n$ to a $k$-th root of $x$.

\noindent For a \typ{FFELT} \kbd{x}, instead of omitting \kbd{k} (which is
not allowed for this type), it may be natural to set
\bprog
k = (x.p ^ poldegree(x.pol) - 1) / fforder(x)
@eprog

The library syntax is \fun{long}{ispower}{GEN x, GEN k = NULL, GEN *n = NULL}.
Also available is
\fun{long}{gisanypower}{GEN x, GEN *pty} ($k$ omitted).

\subsec{ispowerful$(x)$}\kbdsidx{ispowerful}\label{se:ispowerful}
True (1) if $x$ is a powerful integer, false (0) if not;
an integer is powerful if and only if its valuation at all primes is
greater than 1.
\bprog
? ispowerful(50)
%1 = 0
? ispowerful(100)
%2 = 1
? ispowerful(5^3*(10^1000+1)^2)
%3 = 1
@eprog

The library syntax is \fun{long}{ispowerful}{GEN x}.

\subsec{isprime$(x,\{\fl=0\})$}\kbdsidx{isprime}\label{se:isprime}
True (1) if $x$ is a prime
number, false (0) otherwise. A prime number is a positive integer having
exactly two distinct divisors among the natural numbers, namely 1 and
itself.

This routine proves or disproves rigorously that a number is prime, which can
be very slow when $x$ is indeed prime and has more than $1000$ digits, say.
Use \tet{ispseudoprime} to quickly check for compositeness. See also
\kbd{factor}. It accepts vector/matrices arguments, and is then applied
componentwise.

If $\fl=0$, use a combination of Baillie-PSW pseudo primality test (see
\tet{ispseudoprime}), Selfridge ``$p-1$'' test if $x-1$ is smooth enough, and
Adleman-Pomerance-Rumely-Cohen-Lenstra (APRCL) for general $x$.

If $\fl=1$, use Selfridge-Pocklington-Lehmer ``$p-1$'' test and output a
primality certificate as follows: return

\item 0 if $x$ is composite,

\item 1 if $x$ is small enough that passing Baillie-PSW test guarantees
its primality (currently $x < 2^{64}$, as checked by Jan Feitsma),

\item $2$ if $x$ is a large prime whose primality could only sensibly be
proven (given the algorithms implemented in PARI) using the APRCL test.

\item Otherwise ($x$ is large and $x-1$ is smooth) output a three column
matrix as a primality certificate. The first column contains prime
divisors $p$ of $x-1$ (such that $\prod p^{v_p(x-1)} > x^{1/3}$), the second
the corresponding elements $a_p$ as in Proposition~8.3.1 in GTM~138 , and the
third the output of isprime(p,1).

The algorithm fails if one of the pseudo-prime factors is not prime, which is
exceedingly unlikely and well worth a bug report. Note that if you monitor
\kbd{isprime} at a high enough debug level, you may see warnings about
untested integers being declared primes. This is normal: we ask for partial
factorisations (sufficient to prove primality if the unfactored part is not
too large), and \kbd{factor} warns us that the cofactor hasn't been tested.
It may or may not be tested later, and may or may not be prime. This does
not affect the validity of the whole \kbd{isprime} procedure.

If $\fl=2$, use APRCL.

The library syntax is \fun{GEN}{gisprime}{GEN x, long flag}.

\subsec{isprimepower$(x,\{\&n\})$}\kbdsidx{isprimepower}\label{se:isprimepower}
If $x = p^k$ is a prime power ($p$ prime, $k > 0$), return $k$, else
return 0. If a second argument $\&n$ is given and $x$ is indeed
the $k$-th power of a prime $p$, sets $n$ to $p$.

The library syntax is \fun{long}{isprimepower}{GEN x, GEN *n = NULL}.

\subsec{ispseudoprime$(x,\{\fl\})$}\kbdsidx{ispseudoprime}\label{se:ispseudoprime}
True (1) if $x$ is a strong pseudo
prime (see below), false (0) otherwise. If this function returns false, $x$
is not prime; if, on the other hand it returns true, it is only highly likely
that $x$ is a prime number. Use \tet{isprime} (which is of course much
slower) to prove that $x$ is indeed prime.
The function accepts vector/matrices arguments, and is then applied
componentwise.

If $\fl = 0$, checks whether $x$ is a Baillie-Pomerance-Selfridge-Wagstaff
pseudo prime (strong Rabin-Miller pseudo prime for base $2$, followed by
strong Lucas test for the sequence $(P,-1)$, $P$ smallest positive integer
such that $P^2 - 4$ is not a square mod $x$).

There are no known composite numbers passing this test, although it is
expected that infinitely many such numbers exist. In particular, all
composites $\leq 2^{64}$ are correctly detected (checked using
\kbd{http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html}).

If $\fl > 0$, checks whether $x$ is a strong Miller-Rabin pseudo prime  for
$\fl$ randomly chosen bases (with end-matching to catch square roots of $-1$).

The library syntax is \fun{GEN}{gispseudoprime}{GEN x, long flag}.

\subsec{issquare$(x,\{\&n\})$}\kbdsidx{issquare}\label{se:issquare}
True (1) if $x$ is a square, false (0)
if not. What ``being a square'' means depends on the type of $x$: all
\typ{COMPLEX} are squares, as well as all non-negative \typ{REAL}; for
exact types such as \typ{INT}, \typ{FRAC} and \typ{INTMOD}, squares are
numbers of the form $s^2$ with $s$ in $\Z$, $\Q$ and $\Z/N\Z$ respectively.
\bprog
? issquare(3)          \\ as an integer
%1 = 0
? issquare(3.)         \\ as a real number
%2 = 1
? issquare(Mod(7, 8))  \\ in Z/8Z
%3 = 0
? issquare( 5 + O(13^4) )  \\ in Q_13
%4 = 0
@eprog
If $n$ is given, a square root of $x$ is put into $n$.
\bprog
? issquare(4, &n)
%1 = 1
? n
%2 = 2
@eprog
For polynomials, either we detect that the characteristic is 2 (and check
directly odd and even-power monomials) or we assume that $2$ is invertible
and check whether squaring the truncated power series for the square root
yields the original input.

The library syntax is \fun{long}{issquareall}{GEN x, GEN *n = NULL}.
Also available is \fun{long}{issquare}{GEN x}. Deprecated
GP-specific functions \fun{GEN}{gissquare}{GEN x} and
\fun{GEN}{gissquareall}{GEN x, GEN *pt} return \kbd{gen\_0} and \kbd{gen\_1}
instead of a boolean value.

\subsec{issquarefree$(x)$}\kbdsidx{issquarefree}\label{se:issquarefree}
True (1) if $x$ is squarefree, false (0) if not. Here $x$ can be an
integer or a polynomial.

The library syntax is \fun{long}{issquarefree}{GEN x}.

\subsec{istotient$(x,\{\&N\})$}\kbdsidx{istotient}\label{se:istotient}
True (1) if $x = \phi(n)$ for some integer $n$, false (0)
if not.
\bprog
? istotient(14)
%1 = 0
? istotient(100)
%2 = 0
@eprog
If $N$ is given, set $N = n$ as well.
\bprog
? istotient(4, &n)
%1 = 1
? n
%2 = 10
@eprog

The library syntax is \fun{long}{istotient}{GEN x, GEN *N = NULL}.

\subsec{kronecker$(x,y)$}\kbdsidx{kronecker}\label{se:kronecker}
\idx{Kronecker symbol} $(x|y)$, where $x$ and $y$ must be of type integer. By
definition, this is the extension of \idx{Legendre symbol} to $\Z \times \Z$
by total multiplicativity in both arguments with the following special rules
for $y = 0, -1$ or $2$:

\item $(x|0) = 1$ if $|x| = 1$ and $0$ otherwise.

\item $(x|-1) = 1$ if $x \geq 0$ and $-1$ otherwise.

\item $(x|2) = 0$ if $x$ is even and $1$ if $x = 1,-1 \mod 8$ and $-1$
if $x=3,-3 \mod 8$.

The library syntax is \fun{long}{kronecker}{GEN x, GEN y}.

\subsec{lcm$(x,\{y\})$}\kbdsidx{lcm}\label{se:lcm}
Least common multiple of $x$ and $y$, i.e.~such
that $\lcm(x,y)*\gcd(x,y) = \text{abs}(x*y)$. If $y$ is omitted and $x$
is a vector, returns the $\text{lcm}$ of all components of $x$.

When $x$ and $y$ are both given and one of them is a vector/matrix type,
the LCM is again taken recursively on each component, but in a different way.
If $y$ is a vector, resp.~matrix, then the result has the same type as $y$,
and components equal to \kbd{lcm(x, y[i])}, resp.~\kbd{lcm(x, y[,i])}. Else
if $x$ is a vector/matrix the result has the same type as $x$ and an
analogous definition. Note that for these types, \kbd{lcm} is not
commutative.

Note that \kbd{lcm(v)} is quite different from
\bprog
l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
@eprog\noindent
Indeed, \kbd{lcm(v)} is a scalar, but \kbd{l} may not be (if one of
the \kbd{v[i]} is a vector/matrix). The computation uses a divide-conquer tree
and should be much more efficient, especially when using the GMP
multiprecision kernel (and more subquadratic algorithms become available):
\bprog
? v = vector(10^4, i, random);
? lcm(v);
time = 323 ms.
? l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
time = 833 ms.
@eprog

The library syntax is \fun{GEN}{glcm0}{GEN x, GEN y = NULL}.

\subsec{logint$(x,b,\&z)$}\kbdsidx{logint}\label{se:logint}
Return the largest integer $e$ so that $b^e \leq x$, where the
parameters $b > 1$ and $x > 0$ are both integers. If the parameter $z$ is
present, set it to $b^e$.
\bprog
? logint(1000, 2)
%1 = 9
? 2^9
%2 = 512
? logint(1000, 2, &z)
%3 = 9
? z
%4 = 512
@eprog\noindent The number of digits used to write $b$ in base $x$ is
\kbd{1 + logint(x,b)}:
\bprog
? #digits(1000!, 10)
%5 = 2568
? logint(1000!, 10)
%6 = 2567
@eprog\noindent This function may conveniently replace
\bprog
  floor( log(x) / log(b) )
@eprog\noindent which may not give the correct answer since PARI
does not guarantee exact rounding.

The library syntax is \fun{long}{logint0}{GEN x, GEN b, GEN *z = NULL}.

\subsec{moebius$(x)$}\kbdsidx{moebius}\label{se:moebius}
\idx{Moebius} $\mu$-function of $|x|$. $x$ must be of type integer.

The library syntax is \fun{long}{moebius}{GEN x}.

\subsec{nextprime$(x)$}\kbdsidx{nextprime}\label{se:nextprime}
Finds the smallest pseudoprime (see
\tet{ispseudoprime}) greater than or equal to $x$. $x$ can be of any real
type. Note that if $x$ is a pseudoprime, this function returns $x$ and not
the smallest pseudoprime strictly larger than $x$. To rigorously prove that
the result is prime, use \kbd{isprime}.

The library syntax is \fun{GEN}{nextprime}{GEN x}.

\subsec{numbpart$(n)$}\kbdsidx{numbpart}\label{se:numbpart}
Gives the number of unrestricted partitions of
$n$, usually called $p(n)$ in the literature; in other words the number of
nonnegative integer solutions to $a+2b+3c+\cdots=n$. $n$ must be of type
integer and $n<10^{15}$ (with trivial values $p(n) = 0$ for $n < 0$ and
$p(0) = 1$). The algorithm uses the Hardy-Ramanujan-Rademacher formula.
To explicitly enumerate them, see \tet{partitions}.

The library syntax is \fun{GEN}{numbpart}{GEN n}.

\subsec{numdiv$(x)$}\kbdsidx{numdiv}\label{se:numdiv}
Number of divisors of $|x|$. $x$ must be of type integer.

The library syntax is \fun{GEN}{numdiv}{GEN x}.

\subsec{omega$(x)$}\kbdsidx{omega}\label{se:omega}
Number of distinct prime divisors of $|x|$. $x$ must be of type integer.
\bprog
? factor(392)
%1 =
[2 3]

[7 2]

? omega(392)
%2 = 2;  \\ without multiplicity
? bigomega(392)
%3 = 5;  \\ = 3+2, with multiplicity
@eprog

The library syntax is \fun{long}{omega}{GEN x}.

\subsec{partitions$(k,\{a=k\},\{n=k\}))$}\kbdsidx{partitions}\label{se:partitions}
Returns the vector of partitions of the integer $k$ as a sum of positive
integers (parts); for $k < 0$, it returns the empty set \kbd{[]}, and for $k
= 0$ the trivial partition (no parts). A partition is given by a
\typ{VECSMALL}, where parts are sorted in nondecreasing order:
\bprog
? partitions(3)
%1 = [Vecsmall([3]), Vecsmall([1, 2]), Vecsmall([1, 1, 1])]
@eprog\noindent correspond to $3$, $1+2$ and $1+1+1$. The number
of (unrestricted) partitions of $k$ is given
by \tet{numbpart}:
\bprog
? #partitions(50)
%1 = 204226
? numbpart(50)
%2 = 204226
@eprog

\noindent Optional parameters $n$ and $a$ are as follows:

\item $n=\var{nmax}$ (resp. $n=[\var{nmin},\var{nmax}]$) restricts
partitions to length less than $\var{nmax}$ (resp. length between
$\var{nmin}$ and $nmax$), where the \emph{length} is the number of nonzero
entries.

\item $a=\var{amax}$ (resp. $a=[\var{amin},\var{amax}]$) restricts the parts
to integers less than $\var{amax}$ (resp. between $\var{amin}$ and
$\var{amax}$).
\bprog
? partitions(4, 2)  \\ parts bounded by 2
%1 = [Vecsmall([2, 2]), Vecsmall([1, 1, 2]), Vecsmall([1, 1, 1, 1])]
? partitions(4,, 2) \\ at most 2 parts
%2 = [Vecsmall([4]), Vecsmall([1, 3]), Vecsmall([2, 2])]
? partitions(4,[0,3], 2) \\ at most 2 parts
%3 = [Vecsmall([4]), Vecsmall([1, 3]), Vecsmall([2, 2])]
@eprog\noindent
By default, parts are positive and we remove zero entries unless
$amin\leq0$, in which case $nmin$ is ignored and $X$ is of constant length
$\var{nmax}$:
\bprog
? partitions(4, [0,3])  \\ parts between 0 and 3
%1 = [Vecsmall([0, 0, 1, 3]), Vecsmall([0, 0, 2, 2]),\
      Vecsmall([0, 1, 1, 2]), Vecsmall([1, 1, 1, 1])]
@eprog

The library syntax is \fun{GEN}{partitions}{long k, GEN a = NULL, GEN n) = NULL}.

\subsec{polrootsff$(x,\{p\},\{a\})$}\kbdsidx{polrootsff}\label{se:polrootsff}
Returns the vector of distinct roots of the polynomial $x$ in the field
$\F_q$ defined by the irreducible polynomial $a$ over $\F_p$. The
coefficients of $x$ must be operation-compatible with $\Z/p\Z$.
Either $a$ or $p$ can omitted (in which case both are ignored) if x has
\typ{FFELT} coefficients:
\bprog
? polrootsff(x^2 + 1, 5, y^2+3)  \\ over F_5[y]/(y^2+3) ~ F_25
%1 = [Mod(Mod(3, 5), Mod(1, 5)*y^2 + Mod(3, 5)),
      Mod(Mod(2, 5), Mod(1, 5)*y^2 + Mod(3, 5))]
? t = ffgen(y^2 + Mod(3,5), 't); \\ a generator for F_25 as a t_FFELT
? polrootsff(x^2 + 1)   \\ not enough information to determine the base field
 ***   at top-level: polrootsff(x^2+1)
 ***                 ^-----------------
 *** polrootsff: incorrect type in factorff.
? polrootsff(x^2 + t^0) \\ make sure one coeff. is a t_FFELT
%3 = [3, 2]
? polrootsff(x^2 + t + 1)
%4 = [2*t + 1, 3*t + 4]
@eprog\noindent
Notice that the second syntax is easier to use and much more readable.

The library syntax is \fun{GEN}{polrootsff}{GEN x, GEN p = NULL, GEN a = NULL}.

\subsec{precprime$(x)$}\kbdsidx{precprime}\label{se:precprime}
Finds the largest pseudoprime (see
\tet{ispseudoprime}) less than or equal to $x$. $x$ can be of any real type.
Returns 0 if $x\le1$. Note that if $x$ is a prime, this function returns $x$
and not the largest prime strictly smaller than $x$. To rigorously prove that
the result is prime, use \kbd{isprime}.

The library syntax is \fun{GEN}{precprime}{GEN x}.

\subsec{prime$(n)$}\kbdsidx{prime}\label{se:prime}
The $n^{\text{th}}$ prime number
\bprog
? prime(10^9)
%1 = 22801763489
@eprog\noindent Uses checkpointing and a naive $O(n)$ algorithm.

The library syntax is \fun{GEN}{prime}{long n}.

\subsec{primepi$(x)$}\kbdsidx{primepi}\label{se:primepi}
The prime counting function. Returns the number of
primes $p$, $p \leq x$.
\bprog
? primepi(10)
%1 = 4;
? primes(5)
%2 = [2, 3, 5, 7, 11]
? primepi(10^11)
%3 = 4118054813
@eprog\noindent Uses checkpointing and a naive $O(x)$ algorithm.

The library syntax is \fun{GEN}{primepi}{GEN x}.

\subsec{primes$(n)$}\kbdsidx{primes}\label{se:primes}
Creates a row vector whose components are the first $n$ prime numbers.
(Returns the empty vector for $n \leq 0$.) A \typ{VEC} $n = [a,b]$ is also
allowed, in which case the primes in $[a,b]$ are returned
\bprog
? primes(10)     \\ the first 10 primes
%1 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([0,29])  \\ the primes up to 29
%2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([15,30])
%3 = [17, 19, 23, 29]
@eprog

The library syntax is \fun{GEN}{primes0}{GEN n}.

\subsec{qfbclassno$(D,\{\fl=0\})$}\kbdsidx{qfbclassno}\label{se:qfbclassno}
Ordinary class number of the quadratic
order of discriminant $D$. In the present version \vers, a $O(D^{1/2})$
algorithm is used for $D > 0$ (using Euler product and the functional
equation) so $D$ should not be too large, say $D < 10^8$, for the time to be
reasonable. On the other hand, for $D < 0$ one can reasonably compute
\kbd{qfbclassno($D$)} for $|D|<10^{25}$, since the routine uses
\idx{Shanks}'s method which is in $O(|D|^{1/4})$. For larger values of $|D|$,
see \kbd{quadclassunit}.

If $\fl=1$, compute the class number using \idx{Euler product}s and the
functional equation. However, it is in $O(|D|^{1/2})$.

\misctitle{Important warning} For $D < 0$, this function may give incorrect
results when the class group has many cyclic factors,
because implementing \idx{Shanks}'s method in full generality slows it down
immensely. It is therefore strongly recommended to double-check results using
either the version with $\fl = 1$ or the function \kbd{quadclassunit}.

\misctitle{Warning} Contrary to what its name implies, this routine does not
compute the number of classes of binary primitive forms of discriminant $D$,
which is equal to the \emph{narrow} class number. The two notions are the same
when $D < 0$ or the fundamental unit $\varepsilon$ has negative norm; when $D
> 0$ and $N\varepsilon > 0$, the number of classes of forms is twice the
ordinary class number. This is a problem which we cannot fix for backward
compatibility reasons. Use the following routine if you are only interested
in the number of classes of forms:
\bprog
QFBclassno(D) =
qfbclassno(D) * if (D < 0 || norm(quadunit(D)) < 0, 1, 2)
@eprog\noindent
Here are a few examples:
\bprog
? qfbclassno(400000028)
time = 3,140 ms.
%1 = 1
? quadclassunit(400000028).no
time = 20 ms. \\@com{ much faster}
%2 = 1
? qfbclassno(-400000028)
time = 0 ms.
%3 = 7253 \\@com{ correct, and fast enough}
? quadclassunit(-400000028).no
time = 0 ms.
%4 = 7253
@eprog\noindent
See also \kbd{qfbhclassno}.

The library syntax is \fun{GEN}{qfbclassno0}{GEN D, long flag}.
The following functions are also available:

\fun{GEN}{classno}{GEN D} ($\fl = 0$)

\fun{GEN}{classno2}{GEN D} ($\fl = 1$).

\noindent Finally

\fun{GEN}{hclassno}{GEN D} computes the class number of an imaginary
quadratic field by counting reduced forms, an $O(|D|)$ algorithm.

\subsec{qfbcompraw$(x,y)$}\kbdsidx{qfbcompraw}\label{se:qfbcompraw}
\idx{composition} of the binary quadratic forms $x$ and $y$, without
\idx{reduction} of the result. This is useful e.g.~to compute a generating
element of an ideal. The result is undefined if $x$ and $y$ do not have the
same discriminant.

The library syntax is \fun{GEN}{qfbcompraw}{GEN x, GEN y}.

\subsec{qfbhclassno$(x)$}\kbdsidx{qfbhclassno}\label{se:qfbhclassno}
\idx{Hurwitz class number} of $x$, where
$x$ is non-negative and congruent to 0 or 3 modulo 4. For $x > 5\cdot
10^5$, we assume the GRH, and use \kbd{quadclassunit} with default
parameters.

The library syntax is \fun{GEN}{hclassno}{GEN x}.

\subsec{qfbnucomp$(x,y,L)$}\kbdsidx{qfbnucomp}\label{se:qfbnucomp}
\idx{composition} of the primitive positive
definite binary quadratic forms $x$ and $y$ (type \typ{QFI}) using the NUCOMP
and NUDUPL algorithms of \idx{Shanks}, \`a la Atkin. $L$ is any positive
constant, but for optimal speed, one should take $L=|D|^{1/4}$, where $D$ is
the common discriminant of $x$ and $y$. When $x$ and $y$ do not have the same
discriminant, the result is undefined.

The current implementation is straightforward and in general \emph{slower}
than the generic routine (since the latter takes advantage of asymptotically
fast operations and careful optimizations).

The library syntax is \fun{GEN}{nucomp}{GEN x, GEN y, GEN L}.
Also available is \fun{GEN}{nudupl}{GEN x, GEN L} when $x=y$.

\subsec{qfbnupow$(x,n)$}\kbdsidx{qfbnupow}\label{se:qfbnupow}
$n$-th power of the primitive positive definite
binary quadratic form $x$ using \idx{Shanks}'s NUCOMP and NUDUPL algorithms
(see \kbd{qfbnucomp}, in particular the final warning).

The library syntax is \fun{GEN}{nupow}{GEN x, GEN n}.

\subsec{qfbpowraw$(x,n)$}\kbdsidx{qfbpowraw}\label{se:qfbpowraw}
$n$-th power of the binary quadratic form
$x$, computed without doing any \idx{reduction} (i.e.~using \kbd{qfbcompraw}).
Here $n$ must be non-negative and $n<2^{31}$.

The library syntax is \fun{GEN}{qfbpowraw}{GEN x, long n}.

\subsec{qfbprimeform$(x,p)$}\kbdsidx{qfbprimeform}\label{se:qfbprimeform}
Prime binary quadratic form of discriminant
$x$ whose first coefficient is $p$, where $|p|$ is a prime number.
By abuse of notation,
$p = \pm 1$ is also valid and returns the unit form. Returns an
error if $x$ is not a quadratic residue mod $p$, or if $x < 0$ and $p < 0$.
(Negative definite \typ{QFI} are not implemented.) In the case where $x>0$,
the ``distance'' component of the form is set equal to zero according to the
current precision.

The library syntax is \fun{GEN}{primeform}{GEN x, GEN p, long prec}.

\subsec{qfbred$(x,\{\fl=0\},\{d\},\{\var{isd}\},\{\var{sd}\})$}\kbdsidx{qfbred}\label{se:qfbred}
Reduces the binary quadratic form $x$ (updating Shanks's distance function
if $x$ is indefinite). The binary digits of $\fl$ are toggles meaning

\quad 1: perform a single \idx{reduction} step

\quad 2: don't update \idx{Shanks}'s distance

The arguments $d$, \var{isd}, \var{sd}, if present, supply the values of the
discriminant, $\floor{\sqrt{d}}$, and $\sqrt{d}$ respectively
(no checking is done of these facts). If $d<0$ these values are useless,
and all references to Shanks's distance are irrelevant.

The library syntax is \fun{GEN}{qfbred0}{GEN x, long flag, GEN d = NULL, GEN isd = NULL, GEN sd = NULL}.
Also available are

\fun{GEN}{redimag}{GEN x} (for definite $x$),

\noindent and for indefinite forms:

\fun{GEN}{redreal}{GEN x}

\fun{GEN}{rhoreal}{GEN x} (= \kbd{qfbred(x,1)}),

\fun{GEN}{redrealnod}{GEN x, GEN isd} (= \kbd{qfbred(x,2,,isd)}),

\fun{GEN}{rhorealnod}{GEN x, GEN isd} (= \kbd{qfbred(x,3,,isd)}).

\subsec{qfbsolve$(Q,p)$}\kbdsidx{qfbsolve}\label{se:qfbsolve}
Solve the equation $Q(x,y)=p$ over the integers,
where $Q$ is a binary quadratic form and $p$ a prime number.

Return $[x,y]$ as a two-components vector, or zero if there is no solution.
Note that this function returns only one solution and not all the solutions.

Let $D = \disc Q$. The algorithm used runs in probabilistic polynomial time
in $p$ (through the computation of a square root of $D$ modulo $p$); it is
polynomial time in $D$ if $Q$ is imaginary, but exponential time if $Q$ is
real (through the computation of a full cycle of reduced forms). In the
latter case, note that \tet{bnfisprincipal} provides a solution in heuristic
subexponential time in $D$ assuming the GRH.

The library syntax is \fun{GEN}{qfbsolve}{GEN Q, GEN p}.

\subsec{quadclassunit$(D,\{\fl=0\},\{\var{tech}=[\,]\})$}\kbdsidx{quadclassunit}\label{se:quadclassunit}
\idx{Buchmann-McCurley}'s sub-exponential algorithm for computing the
class group of a quadratic order of discriminant $D$.

This function should be used instead of \tet{qfbclassno} or \tet{quadregula}
when $D<-10^{25}$, $D>10^{10}$, or when the \emph{structure} is wanted. It
is a special case of \tet{bnfinit}, which is slower, but more robust.

The result is a vector $v$ whose components should be accessed using member
functions:

\item \kbd{$v$.no}: the class number

\item \kbd{$v$.cyc}: a vector giving the structure of the class group as a
product of cyclic groups;

\item \kbd{$v$.gen}: a vector giving generators of those cyclic groups (as
binary quadratic forms).

\item \kbd{$v$.reg}: the regulator, computed to an accuracy which is the
maximum of an internal accuracy determined by the program and the current
default (note that once the regulator is known to a small accuracy it is
trivial to compute it to very high accuracy, see the tutorial).

The $\fl$ is obsolete and should be left alone. In older versions,
it supposedly computed the narrow class group when $D>0$, but this did not
work at all; use the general function \tet{bnfnarrow}.

Optional parameter \var{tech} is a row vector of the form $[c_1, c_2]$,
where $c_1 \leq c_2$ are non-negative real numbers which control the execution
time and the stack size, see \ref{se:GRHbnf}. The parameter is used as a
threshold to balance the relation finding phase against the final linear
algebra. Increasing the default $c_1$ means that relations are easier
to find, but more relations are needed and the linear algebra will be
harder. The default value for $c_1$ is $0$ and means that it is taken equal
to $c_2$. The parameter $c_2$ is mostly obsolete and should not be changed,
but we still document it for completeness: we compute a tentative class
group by generators and relations using a factorbase of prime ideals
$\leq c_1 (\log |D|)^2$, then prove that ideals of norm
$\leq c_2 (\log |D|)^2$ do
not generate a larger group. By default an optimal $c_2$ is chosen, so that
the result is provably correct under the GRH --- a famous result of Bach
states that $c_2 = 6$ is fine, but it is possible to improve on this
algorithmically. You may provide a smaller $c_2$, it will be ignored
(we use the provably correct
one); you may provide a larger $c_2$ than the default value, which results
in longer computing times for equally correct outputs (under GRH).

The library syntax is \fun{GEN}{quadclassunit0}{GEN D, long flag, GEN tech = NULL, long prec}.
If you really need to experiment with the \var{tech} parameter, it is
usually more convenient to use
\fun{GEN}{Buchquad}{GEN D, double c1, double c2, long prec}

\subsec{quaddisc$(x)$}\kbdsidx{quaddisc}\label{se:quaddisc}
Discriminant of the quadratic field $\Q(\sqrt{x})$, where $x\in\Q$.

The library syntax is \fun{GEN}{quaddisc}{GEN x}.

\subsec{quadgen$(D)$}\kbdsidx{quadgen}\label{se:quadgen}
Creates the quadratic
number\sidx{omega} $\omega=(a+\sqrt{D})/2$ where $a=0$ if $D\equiv0\mod4$,
$a=1$ if $D\equiv1\mod4$, so that $(1,\omega)$ is an integral basis for the
quadratic order of discriminant $D$. $D$ must be an integer congruent to 0 or
1 modulo 4, which is not a square.

The library syntax is \fun{GEN}{quadgen}{GEN D}.

\subsec{quadhilbert$(D)$}\kbdsidx{quadhilbert}\label{se:quadhilbert}
Relative equation defining the
\idx{Hilbert class field} of the quadratic field of discriminant $D$.

If $D < 0$, uses complex multiplication (\idx{Schertz}'s variant).

If $D > 0$ \idx{Stark units} are used and (in rare cases) a
vector of extensions may be returned whose compositum is the requested class
field. See \kbd{bnrstark} for details.

The library syntax is \fun{GEN}{quadhilbert}{GEN D, long prec}.

\subsec{quadpoly$(D,\{v='x\})$}\kbdsidx{quadpoly}\label{se:quadpoly}
Creates the ``canonical'' quadratic
polynomial (in the variable $v$) corresponding to the discriminant $D$,
i.e.~the minimal polynomial of $\kbd{quadgen}(D)$. $D$ must be an integer
congruent to 0 or 1 modulo 4, which is not a square.

The library syntax is \fun{GEN}{quadpoly0}{GEN D, long v = -1}, where \kbd{v} is a variable number.

\subsec{quadray$(D,f)$}\kbdsidx{quadray}\label{se:quadray}
Relative equation for the ray
class field of conductor $f$ for the quadratic field of discriminant $D$
using analytic methods. A \kbd{bnf} for $x^2 - D$ is also accepted in place
of $D$.

For $D < 0$, uses the $\sigma$ function and Schertz's method.

For $D>0$, uses Stark's conjecture, and a vector of relative equations may be
returned. See \tet{bnrstark} for more details.

The library syntax is \fun{GEN}{quadray}{GEN D, GEN f, long prec}.

\subsec{quadregulator$(x)$}\kbdsidx{quadregulator}\label{se:quadregulator}
Regulator of the quadratic field of positive discriminant $x$. Returns
an error if $x$ is not a discriminant (fundamental or not) or if $x$ is a
square. See also \kbd{quadclassunit} if $x$ is large.

The library syntax is \fun{GEN}{quadregulator}{GEN x, long prec}.

\subsec{quadunit$(D)$}\kbdsidx{quadunit}\label{se:quadunit}
Fundamental unit\sidx{fundamental units} of the
real quadratic field $\Q(\sqrt D)$ where  $D$ is the positive discriminant
of the field. If $D$ is not a fundamental discriminant, this probably gives
the fundamental unit of the corresponding order. $D$ must be an integer
congruent to 0 or 1 modulo 4, which is not a square; the result is a
quadratic number (see \secref{se:quadgen}).

The library syntax is \fun{GEN}{quadunit}{GEN D}.

\subsec{randomprime$(\{N = 2^{{31}}\})$}\kbdsidx{randomprime}\label{se:randomprime}
Returns a strong pseudo prime (see \tet{ispseudoprime}) in $[2,N-1]$.
A \typ{VEC} $N = [a,b]$ is also allowed, with $a \leq b$ in which case a
pseudo prime $a \leq p \leq b$ is returned; if no prime exists in the
interval, the function will run into an infinite loop. If the upper bound
is less than $2^{64}$ the pseudo prime returned is a proven prime.

The library syntax is \fun{GEN}{randomprime}{GEN N  = NULL}.

\subsec{removeprimes$(\{x=[\,]\})$}\kbdsidx{removeprimes}\label{se:removeprimes}
Removes the primes listed in $x$ from
the prime number table. In particular \kbd{removeprimes(addprimes())} empties
the extra prime table. $x$ can also be a single integer. List the current
extra primes if $x$ is omitted.

The library syntax is \fun{GEN}{removeprimes}{GEN x = NULL}.

\subsec{sigma$(x,\{k=1\})$}\kbdsidx{sigma}\label{se:sigma}
Sum of the $k^{\text{th}}$ powers of the positive divisors of $|x|$. $x$
and $k$ must be of type integer.

The library syntax is \fun{GEN}{sumdivk}{GEN x, long k}.
Also available is \fun{GEN}{sumdiv}{GEN n}, for $k = 1$.

\subsec{sqrtint$(x)$}\kbdsidx{sqrtint}\label{se:sqrtint}
Returns the integer square root of $x$, i.e. the largest integer $y$
such that $y^2 \leq x$, where $x$ a non-negative integer.
\bprog
? N = 120938191237; sqrtint(N)
%1 = 347761
? sqrt(N)
%2 = 347761.68741970412747602130964414095216
@eprog

The library syntax is \fun{GEN}{sqrtint}{GEN x}.

\subsec{sqrtnint$(x,n)$}\kbdsidx{sqrtnint}\label{se:sqrtnint}
Returns the integer $n$-th root of $x$, i.e. the largest integer $y$ such
that $y^n \leq x$, where $x$ is a non-negative integer.
\bprog
? N = 120938191237; sqrtnint(N, 5)
%1 = 164
? N^(1/5)
%2 = 164.63140849829660842958614676939677391
@eprog\noindent The special case $n = 2$ is \tet{sqrtint}

The library syntax is \fun{GEN}{sqrtnint}{GEN x, long n}.

\subsec{stirling$(n,k,\{\fl=1\})$}\kbdsidx{stirling}\label{se:stirling}
\idx{Stirling number} of the first kind $s(n,k)$ ($\fl=1$, default) or
of the second kind $S(n,k)$ (\fl=2), where $n$, $k$ are non-negative
integers. The former is $(-1)^{n-k}$ times the
number of permutations of $n$ symbols with exactly $k$ cycles; the latter is
the number of ways of partitioning a set of $n$ elements into $k$ non-empty
subsets. Note that if all $s(n,k)$ are needed, it is much faster to compute
$$\sum_k s(n,k) x^k = x(x-1)\dots(x-n+1).$$
Similarly, if a large number of $S(n,k)$ are needed for the same $k$,
one should use
$$\sum_n S(n,k) x^n = \dfrac{x^k}{(1-x)\dots(1-kx)}.$$
(Should be implemented using a divide and conquer product.) Here are
simple variants for $n$ fixed:
\bprog
/* list of s(n,k), k = 1..n */
vecstirling(n) = Vec( factorback(vector(n-1,i,1-i*'x)) )

/* list of S(n,k), k = 1..n */
vecstirling2(n) =
{ my(Q = x^(n-1), t);
  vector(n, i, t = divrem(Q, x-i); Q=t[1]; t[2]);
}
@eprog

The library syntax is \fun{GEN}{stirling}{long n, long k, long flag}.
Also available are \fun{GEN}{stirling1}{ulong n, ulong k}
($\fl=1$) and \fun{GEN}{stirling2}{ulong n, ulong k} ($\fl=2$).

\subsec{sumdedekind$(h,k)$}\kbdsidx{sumdedekind}\label{se:sumdedekind}
Returns the \idx{Dedekind sum} associated to the integers $h$ and $k$,
 corresponding to a fast implementation of
 \bprog
  s(h,k) = sum(n = 1, k-1, (n/k)*(frac(h*n/k) - 1/2))
 @eprog

The library syntax is \fun{GEN}{sumdedekind}{GEN h, GEN k}.

\subsec{sumdigits$(n)$}\kbdsidx{sumdigits}\label{se:sumdigits}
Sum of (decimal) digits in the integer $n$.
\bprog
? sumdigits(123456789)
%1 = 45
@eprog\noindent Other bases that 10 are not supported. Note that the sum of
bits in $n$ is returned by \tet{hammingweight}.

The library syntax is \fun{GEN}{sumdigits}{GEN n}.

\subsec{zncoppersmith$(P, N, X, \{B=N\})$}\kbdsidx{zncoppersmith}\label{se:zncoppersmith}
$N$ being an integer and $P\in \Z[X]$, finds all integers $x$ with
$|x| \leq X$ such that
$$\gcd(N, P(x)) \geq B,$$
using \idx{Coppersmith}'s algorithm (a famous application of the \idx{LLL}
algorithm). $X$ must be smaller than $\exp(\log^2 B / (\deg(P) \log N))$:
for $B = N$, this means $X < N^{1/\deg(P)}$. Some $x$ larger than $X$ may
be returned if you are very lucky. The smaller $B$ (or the larger $X$), the
slower the routine will be. The strength of Coppersmith method is the
ability to find roots modulo a general \emph{composite} $N$: if $N$ is a prime
or a prime power, \tet{polrootsmod} or \tet{polrootspadic} will be much
faster.

We shall now present two simple applications. The first one is
finding non-trivial factors of $N$, given some partial information on the
factors; in that case $B$ must obviously be smaller than the largest
non-trivial divisor of $N$.
\bprog
setrand(1); \\ to make the example reproducible
p = nextprime(random(10^30));
q = nextprime(random(10^30)); N = p*q;
p0 = p % 10^20; \\ assume we know 1) p > 10^29, 2) the last 19 digits of p
p1 = zncoppersmith(10^19*x + p0, N, 10^12, 10^29)

\\ result in 10ms.
%1 = [35023733690]
? gcd(p1[1] * 10^19 + p0, N) == p
%2 = 1
@eprog\noindent and we recovered $p$, faster than by trying all
possibilities $ < 10^{12}$.

The second application is an attack on RSA with low exponent, when the
message $x$ is short and the padding $P$ is known to the attacker. We use
the same RSA modulus $N$ as in the first example:
\bprog
setrand(1);
P = random(N);    \\ known padding
e = 3;            \\ small public encryption exponent
X = floor(N^0.3); \\ N^(1/e - epsilon)
x0 = random(X);   \\ unknown short message
C = lift( (Mod(x0,N) + P)^e ); \\ known ciphertext, with padding P
zncoppersmith((P + x)^3 - C, N, X)

\\ result in 244ms.
%3 = [265174753892462432]
? %[1] == x0
%4 = 1
@eprog\noindent
We guessed an integer of the order of $10^{18}$, almost instantly.

The library syntax is \fun{GEN}{zncoppersmith}{GEN P, GEN N, GEN X, GEN B = NULL}.

\subsec{znlog$(x,g,\{o\})$}\kbdsidx{znlog}\label{se:znlog}
Discrete logarithm of $x$ in $(\Z/N\Z)^*$ in base $g$.
The result is $[]$ when $x$ is not a power of $g$.
If present, $o$ represents the multiplicative order of $g$, see
\secref{se:DLfun}; the preferred format for this parameter is
\kbd{[ord, factor(ord)]}, where \kbd{ord} is the order of $g$.
This provides a definite speedup when the discrete log problem is simple:
\bprog
? p = nextprime(10^4); g = znprimroot(p); o = [p-1, factor(p-1)];
? for(i=1,10^4, znlog(i, g, o))
time = 205 ms.
? for(i=1,10^4, znlog(i, g))
time = 244 ms. \\ a little slower
@eprog

The result is undefined if $g$ is not invertible mod $N$ or if the supplied
order is incorrect.

This function uses

\item a combination of generic discrete log algorithms (see below).

\item in $(\Z/N\Z)^*$ when $N$ is prime: a linear sieve index calculus
method, suitable for $N < 10^{50}$, say, is used for large prime divisors of
the order.

The generic discrete log algorithms are:

\item Pohlig-Hellman algorithm, to reduce to groups of prime order $q$,
where $q | p-1$ and $p$ is an odd prime divisor of $N$,

\item Shanks baby-step/giant-step ($q < 2^{32}$ is small),

\item Pollard rho method ($q > 2^{32}$).

The latter two algorithms require $O(\sqrt{q})$ operations in the group on
average, hence will not be able to treat cases where $q > 10^{30}$, say.
In addition, Pollard rho is not able to handle the case where there are no
solutions: it will enter an infinite loop.
\bprog
? g = znprimroot(101)
%1 = Mod(2,101)
? znlog(5, g)
%2 = 24
? g^24
%3 = Mod(5, 101)

? G = znprimroot(2 * 101^10)
%4 = Mod(110462212541120451003, 220924425082240902002)
? znlog(5, G)
%5 = 76210072736547066624
? G^% == 5
%6 = 1
? N = 2^4*3^2*5^3*7^4*11; g = Mod(13, N); znlog(g^110, g)
%7 = 110
? znlog(6, Mod(2,3))  \\ no solution
%8 = []
@eprog\noindent For convenience, $g$ is also allowed to be a $p$-adic number:
\bprog
? g = 3+O(5^10); znlog(2, g)
%1 = 1015243
? g^%
%2 = 2 + O(5^10)
@eprog

The library syntax is \fun{GEN}{znlog}{GEN x, GEN g, GEN o = NULL}.

\subsec{znorder$(x,\{o\})$}\kbdsidx{znorder}\label{se:znorder}
$x$ must be an integer mod $n$, and the
result is the order of $x$ in the multiplicative group $(\Z/n\Z)^*$. Returns
an error if $x$ is not invertible.
The parameter o, if present, represents a non-zero
multiple of the order of $x$, see \secref{se:DLfun}; the preferred format for
this parameter is \kbd{[ord, factor(ord)]}, where \kbd{ord = eulerphi(n)}
is the cardinality of the group.

The library syntax is \fun{GEN}{znorder}{GEN x, GEN o = NULL}.
Also available is \fun{GEN}{order}{GEN x}.

\subsec{znprimroot$(n)$}\kbdsidx{znprimroot}\label{se:znprimroot}
Returns a primitive root (generator) of $(\Z/n\Z)^*$, whenever this
latter group is cyclic ($n = 4$ or $n = 2p^k$ or $n = p^k$, where $p$ is an
odd prime and $k \geq 0$). If the group is not cyclic, the result is
undefined. If $n$ is a prime power, then the smallest positive primitive
root is returned. This may not be true for $n = 2p^k$, $p$ odd.

Note that this function requires factoring $p-1$ for $p$ as above,
in order to determine the exact order of elements in
$(\Z/n\Z)^*$: this is likely to be costly if $p$ is large.

The library syntax is \fun{GEN}{znprimroot}{GEN n}.

\subsec{znstar$(n)$}\kbdsidx{znstar}\label{se:znstar}
Gives the structure of the multiplicative group
$(\Z/n\Z)^*$ as a 3-component row vector $v$, where $v[1]=\phi(n)$ is the
order of that group, $v[2]$ is a $k$-component row-vector $d$ of integers
$d[i]$ such that $d[i]>1$ and $d[i]\mid d[i-1]$ for $i \ge 2$ and
$(\Z/n\Z)^* \simeq \prod_{i=1}^k(\Z/d[i]\Z)$, and $v[3]$ is a $k$-component row
vector giving generators of the image of the cyclic groups $\Z/d[i]\Z$.
\bprog
? G = znstar(40)
%1 = [16, [4, 2, 2], [Mod(17, 40), Mod(21, 40), Mod(11, 40)]]
? G.no   \\ eulerphi(40)
%2 = 16
? G.cyc  \\ cycle structure
%3 = [4, 2, 2]
? G.gen  \\ generators for the cyclic components
%4 = [Mod(17, 40), Mod(21, 40), Mod(11, 40)]
? apply(znorder, G.gen)
%5 = [4, 2, 2]
@eprog\noindent According to the above definitions, \kbd{znstar(0)} is
\kbd{[2, [2], [-1]]}, corresponding to $\Z^*$.

The library syntax is \fun{GEN}{znstar}{GEN n}.
%SECTION: number_theoretical

\section{Functions related to elliptic curves}

\subsec{Elliptic curve structures}
An elliptic curve is given by a Weierstrass model\sidx{Weierstrass equation}
$$
  y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6,
$$
whose discriminant is non-zero. Affine points on \kbd{E} are represented as
two-component vectors \kbd{[x,y]}; the point at infinity, i.e.~the identity
element of the group law, is represented by the one-component vector
\kbd{[0]}.

Given a vector of coefficients $[a_1,a_2,a_3,a_4,a_6]$, the function
\tet{ellinit} initializes and returns an \tev{ell} structure. (An additional
optional argument allows to specify the base field in case it cannot be
inferred from the curve coefficients.) This structure contains data needed by
elliptic curve related functions, and is generally passed as a first argument.
Expensive data are skipped on initialization: they will be dynamically
computed when (and if) needed, and then inserted in the structure. The
precise layout of the \tev{ell} structure is left undefined and should never
be used directly. The following \idx{member functions} are available,
depending on the underlying domain.

\subsubsec{All domains}

\item \tet{a1}, \tet{a2}, \tet{a3}, \tet{a4}, \tet{a6}: coefficients of the
elliptic curve.

\item \tet{b2}, \tet{b4}, \tet{b6}, \tet{b8}: $b$-invariants of the curve; in
characteristic $\neq 2$, for $Y = 2y + a_1x+a3$, the curve equation becomes
$$ Y^2 = 4 x^3 + b_2 x^2 + 2b_4 x + b_6 =: g(x). $$

\item \tet{c4}, \tet{c6}: $c$-invariants of the curve; in characteristic $\neq
2,3$, for $X = x + b_2/12$ and $Y = 2y + a_1x+a3$, the curve equation becomes
$$ Y^2 = 4 X^3 - (c_4/12) X - (c_6/216). $$

\item \tet{disc}: discriminant of the curve. This is only required to be
non-zero, not necessarily a unit.

\item \tet{j}: $j$-invariant of the curve.

\noindent These are used as follows:
\bprog
? E = ellinit([0,0,0, a4,a6]);
? E.b4
%2 = 2*a4
? E.disc
%3 = -64*a4^3 - 432*a6^2
@eprog

\subsubsec{Curves over $\R$}

This in particular includes curves defined over $\Q$. All member functions in
this section return data, as it is currently stored in the structure, if
present; and otherwise compute it to the default accuracy, that was fixed
\emph{at the time of ellinit} (via a \typ{REAL} $D$ domain argument, or
\kbd{realprecision} by default). The function \tet{ellperiods} allows to
recompute (and cache) the following data to \emph{current}
\kbd{realprecision}.

\item \tet{area}: volume of the complex lattice defining $E$.

\item \tet{roots} is a vector whose three components contain the complex
roots of the right hand side $g(x)$ of the associated $b$-model $Y^2 = g(x)$.
If the roots are all real, they are ordered by decreasing value. If only one
is real, it is the first component.

\item \tet{omega}: $[\omega_1,\omega_2]$, periods forming a basis of the
complex lattice defining $E$. The first component $\omega_1$ is the
(positive) real period, in other words the integral of $dx/(2y+a_1x+a_3)$
over the connected component of the identity component of $E(\R)$.
The second component $\omega_2$ is a complex period, such that
$\tau=\dfrac{\omega_1}{\omega_2}$ belongs to Poincar\'e's
half-plane (positive imaginary part); not necessarily to the standard
fundamental domain.

\item \tet{eta} is a row vector containing the quasi-periods $\eta_1$ and
$\eta_2$ such that $\eta_i = 2\zeta(\omega_i/2)$, where $\zeta$ is the
Weierstrass zeta function associated to the period lattice; see
\tet{ellzeta}. In particular, the Legendre relation holds: $\eta_2\omega_1 -
\eta_1\omega_2 = 2i\pi$.

\misctitle{Warning} As for the orientation of the basis of the period lattice,
beware that many sources use the inverse convention where $\omega_2/\omega_1$
has positive imaginary part and our $\omega_2$ is the negative of theirs. Our
convention $\tau = \omega_1/\omega_2$  ensures that the action of $\text{PSL}_2$ is the natural
one:
$$[a,b;c,d]\cdot\tau = (a\tau+b)/(c\tau+d)
  = (a \omega_1 + b\omega_2)/(c\omega_1 + d\omega_2),$$
instead of a twisted one. (Our $tau$ is $-1/\tau$ in the above inverse
convention.)

\subsubsec{Curves over $\Q_p$}

We advise to input a model defined over $\Q$ for such curves. In any case,
if you input an approximate model with \typ{PADIC} coefficients, it will be
replaced by a lift to $\Q$ (an exact model ``close'' to the one that was
input) and all quantities will then be computed in terms of this lifted
model.

For the time being only curves with multiplicative reduction (split or
non-split), i.e. $v_p(j) < 0$, are supported by non-trivial functions. In
this case the curve is analytically isomorphic to $\bar{\Q}_p^*/q^\Z :=
E_q(\bar{\Q}_p)$, for some $p$-adic integer $q$ (the Tate period). In
particular, we have $j(q) = j(E)$.

\item \tet{p} is the residual characteristic

\item \tet{roots} is a vector with a single component, equal to the $p$-adic
root $e_1$ of the right hand side $g(x)$ of the associated $b$-model $Y^2
= g(x)$. The point $(e_1,0)$ corresponds to $-1 \in \bar{\Q}_p^*/q^\Z$
under the Tate parametrization.

\item \tet{tate} returns $[u^2,u,q,[a,b]]$ in the notation of Henniart-Mestre
(CRAS t. 308, p.~391--395, 1989): $q$ is as above, $u\in \Q_p(\sqrt{-c_6})$
is such that $\phi^* dx/(2y + a_1x+a3) = u dt/t$, where $\phi: E_q\to E$
is an isomorphism (well defined up to sign) and $dt/t$ is the canonical
invariant differential on the Tate curve; $u^2\in\Q_p$ does not depend on
$\phi$. (Technicality: if $u\not\in\Q_p$, it is stored as a quadratic
\typ{POLMOD}.)
Finally, $[a,b]$ satisfy $4u^2 b \cdot \text{agm}(\sqrt{a/b},1)^2 = 1$
as in Theorem~2 (\emph{loc.~cit.}).

\subsubsec{Curves over $\F_q$}

\item \tet{p} is the characteristic of $\F_q$.

\item \tet{no} is $\#E(\F_q)$.

\item \tet{cyc} gives the cycle structure of $E(\F_q)$.

\item \tet{gen} returns the generators of $E(\F_q)$.

\item \tet{group} returns $[\kbd{no},\kbd{cyc},\kbd{gen}]$, i.e. $E(\F_q)$
as an abelian group structure.

\subsubsec{Curves over $\Q$}

All functions should return a correct result, whether the model is minimal or
not, but it is a good idea to stick to minimal models whenever
$\gcd(c_4,c_6)$ is easy to factor (minor speed-up). The construction
\bprog
  E = ellminimalmodel(E0, &v)
@eprog\noindent replaces the original model $E_0$ by a minimal model $E$,
and the variable change $v$ allows to go between the two models:
\bprog
  ellchangepoint(P0, v)
  ellchangepointinv(P, v)
@eprog\noindent respectively map the point $P_0$ on $E_0$ to its image on
$E$, and the point $P$ on $E$ to its pre-image on $E_0$.

A few routines --- namely \tet{ellgenerators}, \tet{ellidentify},
\tet{ellsearch}, \tet{forell} --- require the optional package \tet{elldata}
(John Cremona's database) to be installed. In that case, the function
\tet{ellinit} will allow alternative inputs, e.g.~\kbd{ellinit("11a1")}.
Functions using this package need to load chunks of a large database in
memory and require at least 2MB stack to avoid stack overflows.

\item \tet{gen} returns the generators of $E(\Q)$, if known (from John
  Cremona's database)


\subsec{ellL1$(e, r)$}\kbdsidx{ellL1}\label{se:ellL1}
Returns the value at $s=1$ of the derivative of order $r$ of the
$L$-function of the elliptic curve $e$ assuming that $r$ is at most the order
of vanishing of the $L$-function at $s=1$. (The result is wrong if $r$ is
strictly larger than the order of vanishing at 1.)
\bprog
? e = ellinit("11a1"); \\ order of vanishing is 0
? ellL1(e, 0)
%2 = 0.2538418608559106843377589233
? e = ellinit("389a1");  \\ order of vanishing is 2
? ellL1(e, 0)
%4 = -5.384067311837218089235032414 E-29
? ellL1(e, 1)
%5 = 0
? ellL1(e, 2)
%6 = 1.518633000576853540460385214
@eprog\noindent
The main use of this function, after computing at \emph{low} accuracy the
order of vanishing using \tet{ellanalyticrank}, is to compute the
leading term at \emph{high} accuracy to check (or use) the Birch and
Swinnerton-Dyer conjecture:
\bprog
? \p18
  realprecision = 18 significant digits
? ellanalyticrank(ellinit([0, 0, 1, -7, 6]))
time = 32 ms.
%1 = [3, 10.3910994007158041]
? \p200
  realprecision = 202 significant digits (200 digits displayed)
? ellL1(e, 3)
time = 23,113 ms.
%3 = 10.3910994007158041387518505103609170697263563756570092797@com$[\dots]$
@eprog

The library syntax is \fun{GEN}{ellL1}{GEN e, long r, long prec}.

\subsec{elladd$(E,\var{z1},\var{z2})$}\kbdsidx{elladd}\label{se:elladd}
Sum of the points $z1$ and $z2$ on the
elliptic curve corresponding to $E$.

The library syntax is \fun{GEN}{elladd}{GEN E, GEN z1, GEN z2}.

\subsec{ellak$(E,n)$}\kbdsidx{ellak}\label{se:ellak}
Computes the coefficient $a_n$ of the $L$-function of the elliptic curve
$E/\Q$, i.e.~coefficients of a newform of weight 2 by the modularity theorem
(\idx{Taniyama-Shimura-Weil conjecture}). $E$ must be an \var{ell} structure
over $\Q$ as output by \kbd{ellinit}. $E$ must be given by an integral model,
not necessarily minimal, although a minimal model will make the function
faster.
\bprog
? E = ellinit([0,1]);
? ellak(E, 10)
%2 = 0
? e = ellinit([5^4,5^6]); \\ not minimal at 5
? ellak(e, 5) \\ wasteful but works
%3 = -3
? E = ellminimalmodel(e); \\ now minimal
? ellak(E, 5)
%5 = -3
@eprog\noindent If the model is not minimal at a number of bad primes, then
the function will be slower on those $n$ divisible by the bad primes.
The speed should be comparable for other $n$:
\bprog
? for(i=1,10^6, ellak(E,5))
time = 820 ms.
? for(i=1,10^6, ellak(e,5)) \\ 5 is bad, markedly slower
time = 1,249 ms.

? for(i=1,10^5,ellak(E,5*i))
time = 977 ms.
? for(i=1,10^5,ellak(e,5*i)) \\ still slower but not so much on average
time = 1,008 ms.
@eprog

The library syntax is \fun{GEN}{akell}{GEN E, GEN n}.

\subsec{ellan$(E,n)$}\kbdsidx{ellan}\label{se:ellan}
Computes the vector of the first $n$ Fourier coefficients $a_k$
corresponding to the elliptic curve $E$. The curve must be given by an
integral model, not necessarily minimal, although a minimal model will make
the function faster.

The library syntax is \fun{GEN}{anell}{GEN E, long n}.
Also available is \fun{GEN}{anellsmall}{GEN e, long n}, which
returns a \typ{VECSMALL} instead of a \typ{VEC}, saving on memory.

\subsec{ellanalyticrank$(e, \{\var{eps}\})$}\kbdsidx{ellanalyticrank}\label{se:ellanalyticrank}
Returns the order of vanishing at $s=1$ of the $L$-function of the
elliptic curve $e$ and the value of the first non-zero derivative. To
determine this order, it is assumed that any value less than \kbd{eps} is
zero. If no value of \kbd{eps} is given, a value of half the current
precision is used.
\bprog
? e = ellinit("11a1"); \\ rank 0
? ellanalyticrank(e)
%2 = [0, 0.2538418608559106843377589233]
? e = ellinit("37a1"); \\ rank 1
? ellanalyticrank(e)
%4 = [1, 0.3059997738340523018204836835]
? e = ellinit("389a1"); \\ rank 2
? ellanalyticrank(e)
%6 = [2, 1.518633000576853540460385214]
? e = ellinit("5077a1"); \\ rank 3
? ellanalyticrank(e)
%8 = [3, 10.39109940071580413875185035]
@eprog

The library syntax is \fun{GEN}{ellanalyticrank}{GEN e, GEN eps = NULL, long prec}.

\subsec{ellap$(E,\{p\})$}\kbdsidx{ellap}\label{se:ellap}
Let $E$ be an \var{ell} structure as output by \kbd{ellinit}, defined over
$\Q$ or a finite field $\F_q$. The argument $p$ is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the trace of Frobenius $t$ for the elliptic curve $E$,
defined by the equation $\#E(\F_q) = q+1 - t$.

If the curve is defined over $\Q$, $p$ must be explicitly given and the
function computes the trace of the reduction over $\F_p$.
The trace of Frobenius is also the $a_p$ coefficient in the curve $L$-series
$L(E,s) = \sum_n a_n n^{-s}$, whence the function name. The equation must be
integral at $p$ but need not be minimal at $p$; of course, a minimal model
will be more efficient.
\bprog
? E = ellinit([0,1]);  \\ y^2 = x^3 + 0.x + 1, defined over Q
? ellap(E, 7) \\ 7 necessary here
%2 = -4       \\ #E(F_7) = 7+1-(-4) = 12
? ellcard(E, 7)
%3 = 12       \\ OK

? E = ellinit([0,1], 11);  \\ defined over F_11
? ellap(E)       \\ no need to repeat 11
%4 = 0
? ellap(E, 11)   \\ ... but it also works
%5 = 0
? ellgroup(E, 13) \\ ouch, inconsistent input!
   ***   at top-level: ellap(E,13)
   ***                 ^-----------
   *** ellap: inconsistent moduli in Rg_to_Fp:
     11
     13

? Fq = ffgen(ffinit(11,3), 'a); \\ defines F_q := F_{11^3}
? E = ellinit([a+1,a], Fq);  \\ y^2 = x^3 + (a+1)x + a, defined over F_q
? ellap(E)
%8 = -3
@eprog

\misctitle{Algorithms used} If $E/\F_q$ has CM by a principal imaginary
quadratic order we use a fast explicit formula (involving essentially Kronecker
symbols and Cornacchia's algorithm), in $O(\log q)^2$.
Otherwise, we use Shanks-Mestre's baby-step/giant-step method, which runs in
time $q(p^{1/4})$ using $O(q^{1/4})$ storage, hence becomes unreasonable when
$q$ has about 30~digits. If the \tet{seadata} package is installed, the
\tet{SEA} algorithm becomes available, heuristically in $\tilde{O}(\log
q)^4$, and primes of the order of 200~digits become feasible. In very small
characteristic (2,3,5,7 or $13$), we use Harley's algorithm.

The library syntax is \fun{GEN}{ellap}{GEN E, GEN p = NULL}.

\subsec{ellbil$(E,\var{z1},\var{z2})$}\kbdsidx{ellbil}\label{se:ellbil}
If $z1$ and $z2$ are points on the elliptic
curve $E$ this function
computes the value of the canonical bilinear form on $z1$, $z2$:
$$ ( h(E,z1\kbd{+}z2) - h(E,z1) - h(E,z2) ) / 2 $$
where \kbd{+} denotes of course addition on $E$. In addition, $z1$ or $z2$
(but not both) can be vectors or matrices.

The library syntax is \fun{GEN}{bilhell}{GEN E, GEN z1, GEN z2, long prec}.

\subsec{ellcard$(E,\{p\})$}\kbdsidx{ellcard}\label{se:ellcard}
Let $E$ be an \var{ell} structure as output by \kbd{ellinit}, defined over
$\Q$ or a finite field $\F_q$. The argument $p$ is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the order of the group $E(\F_q)$ (as would be
computed by \tet{ellgroup}).

If the curve is defined over $\Q$, $p$ must be explicitly given and the
function computes the cardinal of the reduction over $\F_p$; the
equation need not be minimal at $p$, but a minimal model will be more
efficient. The reduction is allowed to be singular, and we return the order
of the group of non-singular points in this case.

The library syntax is \fun{GEN}{ellcard}{GEN E, GEN p = NULL}.
Also available is \fun{GEN}{ellcard}{GEN E, GEN p} where $p$ is not
\kbd{NULL}.

\subsec{ellchangecurve$(E,v)$}\kbdsidx{ellchangecurve}\label{se:ellchangecurve}
Changes the data for the elliptic curve $E$
by changing the coordinates using the vector \kbd{v=[u,r,s,t]}, i.e.~if $x'$
and $y'$ are the new coordinates, then $x=u^2x'+r$, $y=u^3y'+su^2x'+t$.
$E$ must be an \var{ell} structure as output by \kbd{ellinit}. The special
case $v = 1$ is also used instead of $[1,0,0,0]$ to denote the
trivial coordinate change.

The library syntax is \fun{GEN}{ellchangecurve}{GEN E, GEN v}.

\subsec{ellchangepoint$(x,v)$}\kbdsidx{ellchangepoint}\label{se:ellchangepoint}
Changes the coordinates of the point or
vector of points $x$ using the vector \kbd{v=[u,r,s,t]}, i.e.~if $x'$ and
$y'$ are the new coordinates, then $x=u^2x'+r$, $y=u^3y'+su^2x'+t$ (see also
\kbd{ellchangecurve}).
\bprog
? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
? E = ellchangecurve(E0, v);
? P = ellchangepoint(P0,v)
%3 = [-2, 3]
? ellisoncurve(E, P)
%4 = 1
? ellchangepointinv(P,v)
%5 = [0, 1]
@eprog

The library syntax is \fun{GEN}{ellchangepoint}{GEN x, GEN v}.
The reciprocal function \fun{GEN}{ellchangepointinv}{GEN x, GEN ch}
inverts the coordinate change.

\subsec{ellchangepointinv$(x,v)$}\kbdsidx{ellchangepointinv}\label{se:ellchangepointinv}
Changes the coordinates of the point or vector of points $x$ using
the inverse of the isomorphism associated to \kbd{v=[u,r,s,t]},
i.e.~if $x'$ and $y'$ are the old coordinates, then $x=u^2x'+r$,
$y=u^3y'+su^2x'+t$ (inverse of \kbd{ellchangepoint}).
\bprog
? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
? E = ellchangecurve(E0, v);
? P = ellchangepoint(P0,v)
%3 = [-2, 3]
? ellisoncurve(E, P)
%4 = 1
? ellchangepointinv(P,v)
%5 = [0, 1]  \\ we get back P0
@eprog

The library syntax is \fun{GEN}{ellchangepointinv}{GEN x, GEN v}.

\subsec{ellconvertname$(\var{name})$}\kbdsidx{ellconvertname}\label{se:ellconvertname}
Converts an elliptic curve name, as found in the \tet{elldata} database,
from a string to a triplet $[\var{conductor}, \var{isogeny class},
\var{index}]$. It will also convert a triplet back to a curve name.
Examples:
\bprog
? ellconvertname("123b1")
%1 = [123, 1, 1]
? ellconvertname(%)
%2 = "123b1"
@eprog

The library syntax is \fun{GEN}{ellconvertname}{GEN name}.

\subsec{elldivpol$(E,n,\{v='x\})$}\kbdsidx{elldivpol}\label{se:elldivpol}
$n$-division polynomial $f_n$ for the curve $E$ in the
variable $v$. In standard notation, for any affine point $P = (X,Y)$ on the
curve, we have
$$[n]P = (\phi_n(P)\psi_n(P) : \omega_n(P) : \psi_n(P)^3)$$
for some polynomials $\phi_n,\omega_n,\psi_n$ in
$\Z[a_1,a_2,a_3,a_4,a_6][X,Y]$. We have $f_n(X) = \psi_n(X)$ for $n$ odd, and
$f_n(X) = \psi_n(X,Y) (2Y + a_1X+a_3)$ for $n$ even. We have
$$ f_1  = 1,\quad f_2 = 4X^3 + b_2X^2 + 2b_4 X + b_6, \quad f_3 = 3 X^4 + b_2 X^3 + 3b_4 X^2 + 3 b_6 X + b8, $$
$$ f_4 = f_2(2X^6 + b_2 X^5 + 5b_4 X^4 + 10 b_6 X^3 + 10 b_8 X^2 +
(b_2b_8-b_4b_6)X + (b_8b_4 - b_6^2)), \dots $$
For $n \geq 2$, the roots of $f_n$ are the $X$-coordinates of points in $E[n]$.

The library syntax is \fun{GEN}{elldivpol}{GEN E, long n, long v = -1}, where \kbd{v} is a variable number.

\subsec{elleisnum$(w,k,\{\fl=0\})$}\kbdsidx{elleisnum}\label{se:elleisnum}
$k$ being an even positive integer, computes the numerical value of the
Eisenstein series of weight $k$ at the lattice $w$, as given by
\tet{ellperiods}, namely
$$
(2i \pi/\omega_2)^k
\Big(1 + 2/\zeta(1-k) \sum_{n\geq 0} n^{k-1}q^n / (1-q^n)\Big),
$$
where $q = \exp(2i\pi \tau)$ and $\tau:=\omega_1/\omega_2$ belongs to the
complex upper half-plane. It is also possible to directly input $w =
[\omega_1,\omega_2]$, or an elliptic curve $E$ as given by \kbd{ellinit}.
\bprog
? w = ellperiods([1,I]);
? elleisnum(w, 4)
%2 = 2268.8726415508062275167367584190557607
? elleisnum(w, 6)
%3 = -3.977978632282564763 E-33
? E = ellinit([1, 0]);
? elleisnum(E, 4, 1)
%5 = -47.999999999999999999999999999999999998
@eprog

When \fl\ is non-zero and $k=4$ or 6, returns the elliptic invariants $g_2$
or $g_3$, such that
$$y^2 = 4x^3 - g_2 x - g_3$$
is a Weierstrass equation for $E$.

The library syntax is \fun{GEN}{elleisnum}{GEN w, long k, long flag, long prec}.

\subsec{elleta$(w)$}\kbdsidx{elleta}\label{se:elleta}
Returns the quasi-periods $[\eta_1,\eta_2]$
associated to the lattice basis $\var{w} = [\omega_1, \omega_2]$.
Alternatively, \var{w} can be an elliptic curve $E$ as output by
\kbd{ellinit}, in which case, the quasi periods associated to the period
lattice basis \kbd{$E$.omega} (namely, \kbd{$E$.eta}) are returned.
\bprog
? elleta([1, I])
%1 = [3.141592653589793238462643383, 9.424777960769379715387930149*I]
@eprog

The library syntax is \fun{GEN}{elleta}{GEN w, long prec}.

\subsec{ellfromj$(j)$}\kbdsidx{ellfromj}\label{se:ellfromj}
Returns the coefficients $[a_1,a_2,a_3,a_4,a_6]$ of a fixed elliptic curve
with $j$-invariant $j$.

The library syntax is \fun{GEN}{ellfromj}{GEN j}.

\subsec{ellgenerators$(E)$}\kbdsidx{ellgenerators}\label{se:ellgenerators}
If $E$ is an elliptic curve over the rationals, return a $\Z$-basis of the
free part of the \idx{Mordell-Weil group} associated to $E$.  This relies on
the \tet{elldata} database being installed and referencing the curve, and so
is only available for curves over $\Z$ of small conductors.
If $E$ is an elliptic curve over a finite field $\F_q$ as output by
\tet{ellinit}, return a minimal set of generators for the group $E(\F_q)$.

The library syntax is \fun{GEN}{ellgenerators}{GEN E}.

\subsec{ellglobalred$(E)$}\kbdsidx{ellglobalred}\label{se:ellglobalred}
Calculates the arithmetic conductor, the global
minimal model of $E$ and the global \idx{Tamagawa number} $c$.
$E$ must be an \var{ell} structure as output by \kbd{ellinit}, defined over
$\Q$. The result is a vector $[N,v,c,F,L]$, where

\item $N$ is the arithmetic conductor of the curve,

\item $v$ gives the coordinate change for $E$ over $\Q$ to the minimal
integral model (see \tet{ellminimalmodel}),

\item $c$ is the product of the local Tamagawa numbers $c_p$, a quantity
which enters in the \idx{Birch and Swinnerton-Dyer conjecture},\sidx{minimal model}

\item $F$ is the factorization of $N$ over $\Z$.

\item $L$ is a vector, whose $i$-th entry contains the local data
at the $i$-th prime divisor of $N$, i.e. \kbd{L[i] = elllocalred(E,F[i,1])},
where the local coordinate change has been deleted, and replaced by a $0$.

The library syntax is \fun{GEN}{ellglobalred}{GEN E}.

\subsec{ellgroup$(E,\{p\},\{\fl\})$}\kbdsidx{ellgroup}\label{se:ellgroup}
Let $E$ be an \var{ell} structure as output by \kbd{ellinit}, defined over
$\Q$ or a finite field $\F_q$. The argument $p$ is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the structure of the group $E(\F_q) \sim \Z/d_1\Z
\times \Z/d_2\Z$, with $d_2\mid d_1$.

If the curve is defined over $\Q$, $p$ must be explicitly given and the
function computes the structure of the reduction over $\F_p$; the
equation need not be minimal at $p$, but a minimal model will be more
efficient. The reduction is allowed to be singular, and we return the
structure of the (cyclic) group of non-singular points in this case.

If the flag is $0$ (default), return $[d_1]$ or $[d_1, d_2]$, if $d_2>1$.
If the flag is $1$, return a triple $[h,\var{cyc},\var{gen}]$, where
$h$ is the curve cardinality, \var{cyc} gives the group structure as a
product of cyclic groups (as per $\fl = 0$). More precisely, if $d_2 > 1$,
the output is $[d_1d_2, [d_1,d_2],[P,Q]]$ where $P$ is
of order $d_1$ and $[P,Q]$ generates the curve.
\misctitle{Caution} It is not guaranteed that $Q$ has order $d_2$, which in
the worst case requires an expensive discrete log computation. Only that
\kbd{ellweilpairing(E, P, Q, d1)} has order $d_2$.
\bprog
? E = ellinit([0,1]);  \\ y^2 = x^3 + 0.x + 1, defined over Q
? ellgroup(E, 7)
%2 = [6, 2] \\ Z/6 x Z/2, non-cyclic
? E = ellinit([0,1] * Mod(1,11));  \\ defined over F_11
? ellgroup(E)   \\ no need to repeat 11
%4 = [12]
? ellgroup(E, 11)   \\ ... but it also works
%5 = [12]
? ellgroup(E, 13) \\ ouch, inconsistent input!
   ***   at top-level: ellgroup(E,13)
   ***                 ^--------------
   *** ellgroup: inconsistent moduli in Rg_to_Fp:
     11
     13
? ellgroup(E, 7, 1)
%6 = [12, [6, 2], [[Mod(2, 7), Mod(4, 7)], [Mod(4, 7), Mod(4, 7)]]]
@eprog\noindent
If $E$ is defined over $\Q$, we allow singular reduction and in this case we
return the structure of the group of non-singular points, satisfying
$\#E_{ns}(\F_p) = p - a_p$.
\bprog
? E = ellinit([0,5]);
? ellgroup(E, 5, 1)
%2 = [5, [5], [[Mod(4, 5), Mod(2, 5)]]]
? ellap(E, 5)
%3 = 0 \\ additive reduction at 5
? E = ellinit([0,-1,0,35,0]);
? ellgroup(E, 5, 1)
%5 = [4, [4], [[Mod(2, 5), Mod(2, 5)]]]
? ellap(E, 5)
%6 = 1 \\ split multiplicative reduction at 5
? ellgroup(E, 7, 1)
%7 = [8, [8], [[Mod(3, 7), Mod(5, 7)]]]
? ellap(E, 7)
%8 = -1 \\ non-split multiplicative reduction at 7
@eprog

The library syntax is \fun{GEN}{ellgroup0}{GEN E, GEN p = NULL, long flag}.
Also available is \fun{GEN}{ellgroup}{GEN E, GEN p}, corresponding
to \fl = 0.

\subsec{ellheegner$(E)$}\kbdsidx{ellheegner}\label{se:ellheegner}
Let $E$ be an elliptic curve over the rationals, assumed to be of
(analytic) rank $1$. This returns a non-torsion rational point on the curve,
whose canonical height is equal to the product of the elliptic regulator by the
analytic Sha.

This uses the Heegner point method, described in Cohen GTM 239; the complexity
is proportional to the product of the square root of the conductor and the
height of the point (thus, it is preferable to apply it to strong Weil curves).
\bprog
? E = ellinit([-157^2,0]);
? u = ellheegner(E); print(u[1], "\n", u[2])
69648970982596494254458225/166136231668185267540804
538962435089604615078004307258785218335/67716816556077455999228495435742408
? ellheegner(ellinit([0,1]))         \\ E has rank 0 !
 ***   at top-level: ellheegner(E=ellinit
 ***                 ^--------------------
 *** ellheegner: The curve has even analytic rank.
@eprog

The library syntax is \fun{GEN}{ellheegner}{GEN E}.

\subsec{ellheight$(E,x,\{\fl=2\})$}\kbdsidx{ellheight}\label{se:ellheight}
Global N\'eron-Tate height of the point $z$ on the elliptic curve
$E$ (defined over $\Q$), using the normalization in Cremona's
\emph{Algorithms for modular elliptic curves}. $E$
must be an \kbd{ell} as output by \kbd{ellinit}; it needs not be given by a
minimal model although the computation will be faster if it is. \fl\ selects
the algorithm used to compute the Archimedean local height. If $\fl=0$,
we use sigma and theta-functions and Silverman's trick (Computing
heights on elliptic curves, \emph{Math.~Comp.} {\bf 51}; note that
our height is twice Silverman's height). If
$\fl=1$, use Tate's $4^n$ algorithm. If $\fl=2$, use Mestre's AGM algorithm.
The latter converges quadratically and is much faster than the other two.

The library syntax is \fun{GEN}{ellheight0}{GEN E, GEN x, long flag, long prec}.
Also available is \fun{GEN}{ghell}{GEN E, GEN x, long prec}
($\fl=2$).

\subsec{ellheightmatrix$(E,x)$}\kbdsidx{ellheightmatrix}\label{se:ellheightmatrix}
$x$ being a vector of points, this
function outputs the Gram matrix of $x$ with respect to the N\'eron-Tate
height, in other words, the $(i,j)$ component of the matrix is equal to
\kbd{ellbil($E$,x[$i$],x[$j$])}. The rank of this matrix, at least in some
approximate sense, gives the rank of the set of points, and if $x$ is a
basis of the \idx{Mordell-Weil group} of $E$, its determinant is equal to
the regulator of $E$. Note our height normalization follows Cremona's
\emph{Algorithms for modular elliptic curves}: this matrix should be divided
by 2 to be in accordance with, e.g., Silverman's normalizations.

The library syntax is \fun{GEN}{mathell}{GEN E, GEN x, long prec}.

\subsec{ellidentify$(E)$}\kbdsidx{ellidentify}\label{se:ellidentify}
Look up the elliptic curve $E$, defined by an arbitrary model over $\Q$,
in the \tet{elldata} database.
Return \kbd{[[N, M, G], C]}  where $N$ is the curve name in Cremona's
elliptic curve database, $M$ is the minimal model, $G$ is a $\Z$-basis of
the free part of the \idx{Mordell-Weil group} $E(\Q)$ and $C$ is the
change of coordinates change, suitable for \kbd{ellchangecurve}.

The library syntax is \fun{GEN}{ellidentify}{GEN E}.

\subsec{ellinit$(x,\{D=1\})$}\kbdsidx{ellinit}\label{se:ellinit}
Initialize an \tet{ell} structure, associated to the elliptic curve $E$.
$E$ is either

\item a $5$-component vector $[a_1,a_2,a_3,a_4,a_6]$ defining the elliptic
curve with Weierstrass equation
$$ Y^2 + a_1 XY + a_3 Y = X^3 + a_2 X^2 + a_4 X + a_6, $$

\item a $2$-component vector $[a_4,a_6]$ defining the elliptic
curve with short Weierstrass equation
$$ Y^2 = X^3 + a_4 X + a_6, $$

\item a character string in Cremona's notation, e.g. \kbd{"11a1"}, in which
case the curve is retrieved from the \tet{elldata} database if available.

The optional argument $D$ describes the domain over which the curve is
defined:

\item the \typ{INT} $1$ (default): the field of rational numbers $\Q$.

\item a \typ{INT} $p$, where $p$ is a prime number: the prime finite field
$\F_p$.

\item an \typ{INTMOD} \kbd{Mod(a, p)}, where $p$ is a prime number: the
prime finite field $\F_p$.

\item a \typ{FFELT}, as returned by \tet{ffgen}: the corresponding finite
field $\F_q$.

\item a \typ{PADIC}, $O(p^n)$: the field $\Q_p$, where $p$-adic quantities
will be computed to a relative accuracy of $n$ digits. We advise to input a
model defined over $\Q$ for such curves. In any case, if you input an
approximate model with \typ{PADIC} coefficients, it will be replaced by a lift
to $\Q$ (an exact model ``close'' to the one that was input) and all quantities
will then be computed in terms of this lifted model, at the given accuracy.

\item a \typ{REAL} $x$: the field $\C$ of complex numbers, where floating
point quantities are by default computed to a relative accuracy of
\kbd{precision}$(x)$. If no such argument is given, the value of
\kbd{realprecision} at the time \kbd{ellinit} is called will be used.

This argument $D$ is indicative: the curve coefficients are checked for
compatibility, possibly changing $D$; for instance if $D = 1$ and
an \typ{INTMOD} is found. If inconsistencies are detected, an error is
raised:
\bprog
? ellinit([1 + O(5), 1], O(7));
 ***   at top-level: ellinit([1+O(5),1],O
 ***                 ^--------------------
 *** ellinit: inconsistent moduli in ellinit: 7 != 5
@eprog\noindent If the curve coefficients are too general to fit any of the
above domain categories, only basic operations, such as point addition, will
be supported later.

If the curve (seen over the domain $D$) is singular, fail and return an
empty vector $[]$.
\bprog
? E = ellinit([0,0,0,0,1]); \\ y^2 = x^3 + 1, over Q
? E = ellinit([0,1]);       \\ the same curve, short form
? E = ellinit("36a1");      \\ sill the same curve, Cremona's notations
? E = ellinit([0,1], 2)     \\ over F2: singular curve
%4 = []
? E = ellinit(['a4,'a6] * Mod(1,5));  \\ over F_5[a4,a6], basic support !
@eprog\noindent

The result of \tet{ellinit} is an \tev{ell} structure. It contains at least
the following information in its components:
%
$$ a_1,a_2,a_3,a_4,a_6,b_2,b_4,b_6,b_8,c_4,c_6,\Delta,j.$$
%
All are accessible via member functions. In particular, the discriminant is
\kbd{$E$.disc}, and the $j$-invariant is \kbd{$E$.j}.
\bprog
? E = ellinit([a4, a6]);
? E.disc
%2 = -64*a4^3 - 432*a6^2
? E.j
%3 = -6912*a4^3/(-4*a4^3 - 27*a6^2)
@eprog
Further components contain domain-specific data, which are in general dynamic:
only computed when needed, and then cached in the structure.
\bprog
? E = ellinit([2,3], 10^60+7);  \\ E over F_p, p large
? ellap(E)
time = 4,440 ms.
%2 = -1376268269510579884904540406082
? ellcard(E);  \\ now instantaneous !
time = 0 ms.
? ellgenerators(E);
time = 5,965 ms.
? ellgenerators(E); \\ second time instantaneous
time = 0 ms.
@eprog
See the description of member functions related to elliptic curves at the
beginning of this section.

The library syntax is \fun{GEN}{ellinit}{GEN x, GEN D = NULL, long prec}.

\subsec{ellisoncurve$(E,z)$}\kbdsidx{ellisoncurve}\label{se:ellisoncurve}
Gives 1 (i.e.~true) if the point $z$ is on the elliptic curve $E$, 0
otherwise. If $E$ or $z$ have imprecise coefficients, an attempt is made to
take this into account, i.e.~an imprecise equality is checked, not a precise
one. It is allowed for $z$ to be a vector of points in which case a vector
(of the same type) is returned.

The library syntax is \fun{GEN}{ellisoncurve}{GEN E, GEN z}.
Also available is \fun{int}{oncurve}{GEN E, GEN z} which does not
accept vectors of points.

\subsec{ellj$(x)$}\kbdsidx{ellj}\label{se:ellj}
Elliptic $j$-invariant. $x$ must be a complex number
with positive imaginary part, or convertible into a power series or a
$p$-adic number with positive valuation.

The library syntax is \fun{GEN}{jell}{GEN x, long prec}.

\subsec{elllocalred$(E,p)$}\kbdsidx{elllocalred}\label{se:elllocalred}
Calculates the \idx{Kodaira} type of the local fiber of the elliptic curve
$E$ at the prime $p$. $E$ must be an \var{ell} structure as output by
\kbd{ellinit}, and is assumed to have all its coefficients $a_i$ in $\Z$.
The result is a 4-component vector $[f,kod,v,c]$. Here $f$ is the exponent of
$p$ in the arithmetic conductor of $E$, and $kod$ is the Kodaira type which
is coded as follows:

1 means good reduction (type I$_0$), 2, 3 and 4 mean types II, III and IV
respectively, $4+\nu$ with $\nu>0$ means type I$_\nu$;
finally the opposite values $-1$, $-2$, etc.~refer to the starred types
I$_0^*$, II$^*$, etc. The third component $v$ is itself a vector $[u,r,s,t]$
giving the coordinate changes done during the local reduction;
$u = 1$ if and only if the given equation was already minimal at $p$.
Finally, the last component $c$ is the local \idx{Tamagawa number} $c_p$.

The library syntax is \fun{GEN}{elllocalred}{GEN E, GEN p}.

\subsec{elllog$(E,P,G,\{o\})$}\kbdsidx{elllog}\label{se:elllog}
Given two points $P$ and $G$ on the elliptic curve $E/\F_q$, returns the
discrete logarithm of $P$ in base $G$, i.e. the smallest non-negative
integer $n$ such that $P = [n]G$.
See \tet{znlog} for the limitations of the underlying discrete log algorithms.
If present, $o$ represents the order of $G$, see \secref{se:DLfun};
the preferred format for this parameter is \kbd{[N, factor(N)]}, where $N$
is  the order of $G$.

If no $o$ is given, assume that $G$ generates the curve.
The function also assumes that $P$ is a multiple of $G$.
\bprog
? a = ffgen(ffinit(2,8),'a);
? E = ellinit([a,1,0,0,1]);  \\ over F_{2^8}
? x = a^3; y = ellordinate(E,x)[1];
? P = [x,y]; G = ellmul(E, P, 113);
? ord = [242, factor(242)]; \\ P generates a group of order 242. Initialize.
? ellorder(E, G, ord)
%4 = 242
? e = elllog(E, P, G, ord)
%5 = 15
? ellmul(E,G,e) == P
%6 = 1
@eprog

The library syntax is \fun{GEN}{elllog}{GEN E, GEN P, GEN G, GEN o = NULL}.

\subsec{elllseries$(E,s,\{A=1\})$}\kbdsidx{elllseries}\label{se:elllseries}
$E$ being an elliptic curve, given by an arbitrary model over $\Q$ as output
by \kbd{ellinit}, this function computes the value of the $L$-series of $E$ at
the (complex) point $s$. This function uses an $O(N^{1/2})$ algorithm, where
$N$ is the conductor.

The optional parameter $A$ fixes a cutoff point for the integral and is best
left omitted; the result must be independent of $A$, up to
\kbd{realprecision}, so this allows to check the function's accuracy.

The library syntax is \fun{GEN}{elllseries}{GEN E, GEN s, GEN A = NULL, long prec}.

\subsec{ellminimalmodel$(E,\{\&v\})$}\kbdsidx{ellminimalmodel}\label{se:ellminimalmodel}
Return the standard minimal integral model of the rational elliptic
curve $E$. If present, sets $v$ to the corresponding change of variables,
which is a vector $[u,r,s,t]$ with rational components. The return value is
identical to that of \kbd{ellchangecurve(E, v)}.

The resulting model has integral coefficients, is everywhere minimal, $a_1$
is 0 or 1, $a_2$ is 0, 1 or $-1$ and $a_3$ is 0 or 1. Such a model is
unique, and the vector $v$ is unique if we specify that $u$ is positive,
which we do. \sidx{minimal model}

The library syntax is \fun{GEN}{ellminimalmodel}{GEN E, GEN *v = NULL}.

\subsec{ellmodulareqn$(N,\{x\},\{y\})$}\kbdsidx{ellmodulareqn}\label{se:ellmodulareqn}
Return a vector [\kbd{eqn},$t$] where \kbd{eqn} is a modular equation of
level $N$, i.e.~a bivariate polynomial with integer coefficients; $t$
indicates the type of this equation: either \emph{canonical} ($t = 0$) or
\emph{Atkin} ($t = 1$). This function currently requires the package
\kbd{seadata} to be installed and is limited to $N<500$, $N$ prime.

Let $j$ be the $j$-invariant function. The polynomial \kbd{eqn} satisfies
the following functional equation, which allows to compute the values of the
classical modular polynomial $\Phi_N$ of prime level $N$, such that
$\Phi_N(j(\tau), j(N\tau)) = 0$, while being much smaller than the latter:

\item for canonical type:
 $P(f(\tau),j(\tau)) = P(N^s/f(\tau),j(N\*\tau)) = 0$,
 where $s = 12/\gcd(12,N-1)$;

\item for Atkin type:
 $P(f(\tau),j(\tau)) = P(f(\tau),j(N\*\tau)) = 0$.

\noindent In both cases, $f$ is a suitable modular function (see below).

The following GP function returns values of the classical modular polynomial
by eliminating $f(\tau)$ in the above two equations, for $N\leq 31$ or
$N\in\{41,47,59,71\}$.

\bprog
classicaleqn(N, X='X, Y='Y)=
{
  my(E=ellmodulareqn(N), P=E[1], t=E[2], Q, d);
  if(poldegree(P,'y)>2,error("level unavailable in classicaleqn"));
  if (t == 0,
    my(s = 12/gcd(12,N-1));
    Q = 'x^(N+1) * substvec(P,['x,'y],[N^s/'x,Y]);
    d = N^(s*(2*N+1)) * (-1)^(N+1);
  ,
    Q = subst(P,'y,Y);
    d = (X-Y)^(N+1));
  polresultant(subst(P,'y,X), Q) / d;
}
@eprog

More precisely, let $W_N(\tau)={{-1}\over{N\*\tau}}$ be the Atkin-Lehner
involution; we have $j(W_N(\tau)) = j(N\*\tau)$ and the function $f$ also
satisfies:

\item for canonical type:
   $f(W_N(\tau)) = N^s/f(\tau)$;

\item for Atkin type:
   $f(W_N(\tau)) = f(\tau)$.

\noindent Furthermore, for an equation of canonical type, $f$ is the standard
$\eta$-quotient
$$f(\tau) = N^s \* \big(\eta(N\*\tau) / \eta(\tau) \big)^{2\*s},$$
where $\eta$ is Dedekind's eta function, which is invariant under
$\Gamma_0(N)$.

The library syntax is \fun{GEN}{ellmodulareqn}{long N, long x = -1, long y = -1}, where \kbd{x}, \kbd{y} are variable numbers.

\subsec{ellmul$(E,z,n)$}\kbdsidx{ellmul}\label{se:ellmul}
Computes $[n]z$, where $z$ is a point on the elliptic curve $E$. The
exponent $n$ is in $\Z$, or may be a complex quadratic integer if the curve $E$
has complex multiplication by $n$ (if not, an error message is issued).
\bprog
? Ei = ellinit([1,0]); z = [0,0];
? ellmul(Ei, z, 10)
%2 = [0]     \\ unsurprising: z has order 2
? ellmul(Ei, z, I)
%3 = [0, 0]  \\ Ei has complex multiplication by Z[i]
? ellmul(Ei, z, quadgen(-4))
%4 = [0, 0]  \\ an alternative syntax for the same query
? Ej  = ellinit([0,1]); z = [-1,0];
? ellmul(Ej, z, I)
  ***   at top-level: ellmul(Ej,z,I)
  ***                 ^--------------
  *** ellmul: not a complex multiplication in ellmul.
? ellmul(Ej, z, 1+quadgen(-3))
%6 = [1 - w, 0]
@eprog
The simple-minded algorithm for the CM case assumes that we are in
characteristic $0$, and that the quadratic order to which $n$ belongs has
small discriminant.

The library syntax is \fun{GEN}{ellmul}{GEN E, GEN z, GEN n}.

\subsec{ellneg$(E,z)$}\kbdsidx{ellneg}\label{se:ellneg}
Opposite of the point $z$ on elliptic curve $E$.

The library syntax is \fun{GEN}{ellneg}{GEN E, GEN z}.

\subsec{ellorder$(E,z,\{o\})$}\kbdsidx{ellorder}\label{se:ellorder}
Gives the order of the point $z$ on the elliptic
curve $E$, defined over $\Q$ or a finite field.
If the curve is defined over $\Q$, return (the impossible value) zero if the
point has infinite order.
\bprog
? E = ellinit([-157^2,0]);  \\ the "157-is-congruent" curve
? P = [2,2]; ellorder(E, P)
%2 = 2
? P = ellheegner(E); ellorder(E, P) \\ infinite order
%3 = 0
? E = ellinit(ellfromj(ffgen(5^10)));
? ellcard(E)
%5 = 9762580
? P = random(E); ellorder(E, P)
%6 = 4881290
? p = 2^160+7; E = ellinit([1,2], p);
? N = ellcard(E)
%8 = 1461501637330902918203686560289225285992592471152
? o = [N, factor(N)];
? for(i=1,100, ellorder(E,random(E)))
time = 260 ms.
@eprog
The parameter $o$, is now mostly useless, and kept for backward
compatibility. If present, it represents a non-zero multiple of the order
of $z$, see \secref{se:DLfun}; the preferred format for this parameter is
\kbd{[ord, factor(ord)]}, where \kbd{ord} is the cardinality of the curve.
It is no longer needed since PARI is now able to compute it over large
finite fields (was restricted to small prime fields at the time this feature
was introduced), \emph{and} caches the result in $E$ so that it is computed
and factored only once. Modifying the last example, we see that including
this extra parameter provides no improvement:
\bprog
? o = [N, factor(N)];
? for(i=1,100, ellorder(E,random(E),o))
time = 260 ms.
@eprog

The library syntax is \fun{GEN}{ellorder}{GEN E, GEN z, GEN o = NULL}.
The obsolete form \fun{GEN}{orderell}{GEN e, GEN z} should no longer be
used.

\subsec{ellordinate$(E,x)$}\kbdsidx{ellordinate}\label{se:ellordinate}
Gives a 0, 1 or 2-component vector containing
the $y$-coordinates of the points of the curve $E$ having $x$ as
$x$-coordinate.

The library syntax is \fun{GEN}{ellordinate}{GEN E, GEN x, long prec}.

\subsec{ellperiods$(w, \{\fl = 0\})$}\kbdsidx{ellperiods}\label{se:ellperiods}
Let $w$ describe a complex period lattice ($w = [w_1,w_2]$
or an ellinit structure). Returns normalized periods $[W_1,W_2]$ generating
the same lattice such that $\tau := W_1/W_2$ has positive imaginary part
and lies in the standard fundamental domain for $\text{SL}_2(\Z)$.

If $\fl = 1$, the function returns $[[W_1,W_2], [\eta_1,\eta_2]]$, where
$\eta_1$ and $\eta_2$ are the quasi-periods associated to
$[W_1,W_2]$, satisfying $\eta_1 W_2 - \eta_2 W_1 = 2 i \pi$.

The output of this function is meant to be used as the first argument
given to ellwp, ellzeta, ellsigma or elleisnum. Quasi-periods are
needed by ellzeta and ellsigma only.

The library syntax is \fun{GEN}{ellperiods}{GEN w, long flag , long prec}.

\subsec{ellpointtoz$(E,P)$}\kbdsidx{ellpointtoz}\label{se:ellpointtoz}
If $E/\C \simeq \C/\Lambda$ is a complex elliptic curve ($\Lambda =
\kbd{E.omega}$),
computes a complex number $z$, well-defined modulo the lattice $\Lambda$,
corresponding to the point $P$; i.e.~such that
 $P = [\wp_\Lambda(z),\wp'_\Lambda(z)]$
satisfies the equation
$$y^2 = 4x^3 - g_2 x - g_3,$$
where $g_2$, $g_3$ are the elliptic invariants.

If $E$ is defined over $\R$ and $P\in E(\R)$, we have more precisely, $0 \leq
\Re(t) < w1$ and $0 \leq \Im(t) < \Im(w2)$, where $(w1,w2)$ are the real and
complex periods of $E$.
\bprog
? E = ellinit([0,1]); P = [2,3];
? z = ellpointtoz(E, P)
%2 = 3.5054552633136356529375476976257353387
? ellwp(E, z)
%3 = 2.0000000000000000000000000000000000000
? ellztopoint(E, z) - P
%4 = [6.372367644529809109 E-58, 7.646841173435770930 E-57]
? ellpointtoz(E, [0]) \\ the point at infinity
%5 = 0
@eprog

If $E/\Q_p$ has multiplicative reduction, then $E/\bar{\Q_p}$ is analytically
isomorphic to $\bar{\Q}_p^*/q^\Z$ (Tate curve) for some $p$-adic integer $q$.
The behaviour is then as follows:

\item If the reduction is split ($E.\kbd{tate[2]}$ is a \typ{PADIC}), we have
an isomorphism $\phi: E(\Q_p) \simeq \Q_p^*/q^\Z$ and the function returns
$\phi(P)\in \Q_p$.

\item If the reduction is \emph{not} split ($E.\kbd{tate[2]}$ is a
\typ{POLMOD}), we only have an isomorphism $\phi: E(K) \simeq K^*/q^\Z$ over
the unramified quadratic extension $K/\Q_p$. In this case, the output
$\phi(P)\in K$ is a \typ{POLMOD}.
\bprog
? E = ellinit([0,-1,1,0,0], O(11^5)); P = [0,0];
? [u2,u,q] = E.tate; type(u) \\ split multiplicative reduction
%2 = "t_PADIC"
? ellmul(E, P, 5)  \\ P has order 5
%3 = [0]
? z = ellpointtoz(E, [0,0])
%4 = 3 + 11^2 + 2*11^3 + 3*11^4 + O(11^5)
? z^5
%5 = 1 + O(11^5)
? E = ellinit(ellfromj(1/4), O(2^6)); x=1/2; y=ellordinate(E,x)[1];
? z = ellpointtoz(E,[x,y]); \\ t_POLMOD of t_POL with t_PADIC coeffs
? liftint(z) \\ lift all p-adics
%8 = Mod(8*u + 7, u^2 + 437)
@eprog

The library syntax is \fun{GEN}{zell}{GEN E, GEN P, long prec}.

\subsec{ellpow$(E,z,n)$}\kbdsidx{ellpow}\label{se:ellpow}
Deprecated alias for \kbd{ellmul}.

The library syntax is \fun{GEN}{ellmul}{GEN E, GEN z, GEN n}.

\subsec{ellrootno$(E,\{p\})$}\kbdsidx{ellrootno}\label{se:ellrootno}
$E$ being an \var{ell} structure over $\Q$ as output by \kbd{ellinit},
this function computes the local root number of its $L$-series at the place
$p$ (at the infinite place if $p = 0$). If $p$ is omitted, return the global
root number. Note that the global root number is the sign of the functional
equation and conjecturally is the parity of the rank of the \idx{Mordell-Weil
group}. The equation for $E$ needs not be minimal at $p$, but if the model
is already minimal the function will run faster.

The library syntax is \fun{long}{ellrootno}{GEN E, GEN p = NULL}.

\subsec{ellsearch$(N)$}\kbdsidx{ellsearch}\label{se:ellsearch}
This function finds all curves in the \tet{elldata} database satisfying
the constraint defined by the argument $N$:

\item if $N$ is a character string, it selects a given curve, e.g.
\kbd{"11a1"}, or curves in the given isogeny class, e.g. \kbd{"11a"}, or
curves with given conductor, e.g. \kbd{"11"};

\item if $N$ is a vector of integers, it encodes the same constraints
as the character string above, according to the \tet{ellconvertname}
correspondance, e.g. \kbd{[11,0,1]} for \kbd{"11a1"}, \kbd{[11,0]} for
\kbd{"11a"} and \kbd{[11]} for \kbd{"11"};

\item if $N$ is an integer, curves with conductor $N$ are selected.

If $N$ is a full curve name, e.g. \kbd{"11a1"} or \kbd{[11,0,1]},
the output format is $[N, [a_1,a_2,a_3,a_4,a_6], G]$ where
$[a_1,a_2,a_3,a_4,a_6]$ are the coefficients of the Weierstrass equation of
the curve and $G$ is a $\Z$-basis of the free part of the \idx{Mordell-Weil
group} associated to the curve.
\bprog
? ellsearch("11a3")
%1 = ["11a3", [0, -1, 1, 0, 0], []]
? ellsearch([11,0,3])
%2 = ["11a3", [0, -1, 1, 0, 0], []]
@eprog\noindent

If $N$ is not a full curve name, then the output is a vector of all matching
curves in the above format:
\bprog
? ellsearch("11a")
%1 = [["11a1", [0, -1, 1, -10, -20], []],
      ["11a2", [0, -1, 1, -7820, -263580], []],
      ["11a3", [0, -1, 1, 0, 0], []]]
? ellsearch("11b")
%2 = []
@eprog

The library syntax is \fun{GEN}{ellsearch}{GEN N}.
Also available is \fun{GEN}{ellsearchcurve}{GEN N} that only
accepts complete curve names (as \typ{STR}).

\subsec{ellsigma$(L,\{z='x\},\{\fl=0\})$}\kbdsidx{ellsigma}\label{se:ellsigma}
Computes the value at $z$ of the Weierstrass $\sigma$ function attached to
the lattice $L$ as given by \tet{ellperiods}$(,1)$: including quasi-periods
is useful, otherwise there are recomputed from scratch for each new $z$.
$$ \sigma(z, L) = z \prod_{\omega\in L^*} \left(1 -
\dfrac{z}{\omega}\right)e^{\dfrac{z}{\omega} + \dfrac{z^2}{2\omega^2}}.$$
It is also possible to directly input $L = [\omega_1,\omega_2]$,
or an elliptic curve $E$ as given by \kbd{ellinit} ($L = \kbd{E.omega}$).
\bprog
? w = ellperiods([1,I], 1);
? ellsigma(w, 1/2)
%2 = 0.47494937998792065033250463632798296855
? E = ellinit([1,0]);
? ellsigma(E) \\ at 'x, implicitly at default seriesprecision
%4 = x + 1/60*x^5 - 1/10080*x^9 - 23/259459200*x^13 + O(x^17)
@eprog

If $\fl=1$, computes an arbitrary determination of $\log(\sigma(z))$.

The library syntax is \fun{GEN}{ellsigma}{GEN L, GEN z = NULL, long flag, long prec}.

\subsec{ellsub$(E,\var{z1},\var{z2})$}\kbdsidx{ellsub}\label{se:ellsub}
Difference of the points $z1$ and $z2$ on the
elliptic curve corresponding to $E$.

The library syntax is \fun{GEN}{ellsub}{GEN E, GEN z1, GEN z2}.

\subsec{elltaniyama$(E, \{d = \var{seriesprecision}\})$}\kbdsidx{elltaniyama}\label{se:elltaniyama}
Computes the modular parametrization of the elliptic curve $E/\Q$,
where $E$ is an \var{ell} structure as output by \kbd{ellinit}. This returns
a two-component vector $[u,v]$ of power series, given to $d$ significant
terms (\tet{seriesprecision} by default), characterized by the following two
properties. First the point $(u,v)$ satisfies the equation of the elliptic
curve. Second, let $N$ be the conductor of $E$ and $\Phi: X_0(N)\to E$
be a modular parametrization; the pullback by $\Phi$ of the
N\'eron differential $du/(2v+a_1u+a_3)$ is equal to $2i\pi
f(z)dz$, a holomorphic differential form. The variable used in the power
series for $u$ and $v$ is $x$, which is implicitly understood to be equal to
$\exp(2i\pi z)$.

The algorithm assumes that $E$ is a \emph{strong} \idx{Weil curve}
and that the Manin constant is equal to 1: in fact, $f(x) = \sum_{n > 0}
\kbd{ellan}(E, n) x^n$.

The library syntax is \fun{GEN}{elltaniyama}{GEN E, long precdl}.

\subsec{elltatepairing$(E, P, Q, m)$}\kbdsidx{elltatepairing}\label{se:elltatepairing}
Computes the Tate pairing of the two points $P$ and $Q$ on the elliptic
curve $E$. The point $P$ must be of $m$-torsion.

The library syntax is \fun{GEN}{elltatepairing}{GEN E, GEN P, GEN Q, GEN m}.

\subsec{elltors$(E,\{\fl=0\})$}\kbdsidx{elltors}\label{se:elltors}
If $E$ is an elliptic curve \emph{defined over $\Q$}, outputs the torsion
subgroup of $E$ as a 3-component vector \kbd{[t,v1,v2]}, where \kbd{t} is the
order of the torsion group, \kbd{v1} gives the structure of the torsion group
as a product of cyclic groups (sorted by decreasing order), and \kbd{v2}
gives generators for these cyclic groups. $E$ must be an \var{ell} structure
as output by \kbd{ellinit}, defined over $\Q$.

\bprog
?  E = ellinit([-1,0]);
?  elltors(E)
%1 = [4, [2, 2], [[0, 0], [1, 0]]]
@eprog
Here, the torsion subgroup is isomorphic to $\Z/2\Z \times \Z/2\Z$, with
generators $[0,0]$ and $[1,0]$.

If $\fl = 0$, find rational roots of division polynomials.

If $\fl = 1$, use Lutz-Nagell (\emph{much} slower).

If $\fl = 2$, use Doud's algorithm: bound torsion by computing $\#E(\F_p)$
for small primes of good reduction, then look for torsion points using
Weierstrass $\wp$ function (and Mazur's classification). For this variant,
$E$ must be an \var{ell}.

The library syntax is \fun{GEN}{elltors0}{GEN E, long flag}.
Also available is \fun{GEN}{elltors}{GEN E} for \kbd{elltors(E, 0)}.

\subsec{ellweilpairing$(E, P, Q, m)$}\kbdsidx{ellweilpairing}\label{se:ellweilpairing}
Computes the Weil pairing of the two points of $m$-torsion $P$ and $Q$
on the elliptic curve $E$.

The library syntax is \fun{GEN}{ellweilpairing}{GEN E, GEN P, GEN Q, GEN m}.

\subsec{ellwp$(w,\{z='x\},\{\fl=0\})$}\kbdsidx{ellwp}\label{se:ellwp}
Computes the value at $z$ of the Weierstrass $\wp$ function attached to
the lattice $w$ as given by \tet{ellperiods}. It is also possible to
directly input $w = [\omega_1,\omega_2]$, or an elliptic curve $E$ as given
by \kbd{ellinit} ($w = \kbd{E.omega}$).
\bprog
? w = ellperiods([1,I]);
? ellwp(w, 1/2)
%2 = 6.8751858180203728274900957798105571978
? E = ellinit([1,1]);
? ellwp(E, 1/2)
%4 = 3.9413112427016474646048282462709151389
@eprog\noindent One can also compute the series expansion around $z = 0$:
\bprog
? E = ellinit([1,0]);
? ellwp(E)              \\ 'x implicitly at default seriesprecision
%5 = x^-2 - 1/5*x^2 + 1/75*x^6 - 2/4875*x^10 + O(x^14)
? ellwp(E, x + O(x^12)) \\ explicit precision
%6 = x^-2 - 1/5*x^2 + 1/75*x^6 + O(x^9)
@eprog

Optional \fl\ means 0 (default): compute only $\wp(z)$, 1: compute
$[\wp(z),\wp'(z)]$.

The library syntax is \fun{GEN}{ellwp0}{GEN w, GEN z = NULL, long flag, long prec}.
For $\fl = 0$, we also have
\fun{GEN}{ellwp}{GEN w, GEN z, long prec}, and
\fun{GEN}{ellwpseries}{GEN E, long v, long precdl} for the power series in
variable $v$.

\subsec{ellzeta$(w,\{z='x\})$}\kbdsidx{ellzeta}\label{se:ellzeta}
Computes the value at $z$ of the Weierstrass $\zeta$ function attached to
the lattice $w$ as given by \tet{ellperiods}$(,1)$: including quasi-periods
is useful, otherwise there are recomputed from scratch for each new $z$.
$$ \zeta(z, L) = \dfrac{1}{z} + z^2\sum_{\omega\in L^*}
\dfrac{1}{\omega^2(z-\omega)}.$$
It is also possible to directly input $w = [\omega_1,\omega_2]$,
or an elliptic curve $E$ as given by \kbd{ellinit} ($w = \kbd{E.omega}$).
The quasi-periods of $\zeta$, such that
$$\zeta(z + a\omega_1 + b\omega_2) = \zeta(z) + a\eta_1 + b\eta_2 $$
for integers $a$ and $b$ are obtained as $\eta_i = 2\zeta(\omega_i/2)$.
Or using directly \tet{elleta}.
\bprog
? w = ellperiods([1,I],1);
? ellzeta(w, 1/2)
%2 = 1.5707963267948966192313216916397514421
? E = ellinit([1,0]);
? ellzeta(E, E.omega[1]/2)
%4 = 0.84721308479397908660649912348219163647
@eprog\noindent One can also compute the series expansion around $z = 0$
(the quasi-periods are useless in this case):
\bprog
? E = ellinit([0,1]);
? ellzeta(E) \\ at 'x, implicitly at default seriesprecision
%4 = x^-1 + 1/35*x^5 - 1/7007*x^11 + O(x^15)
? ellzeta(E, x + O(x^20)) \\ explicit precision
%5 = x^-1 + 1/35*x^5 - 1/7007*x^11 + 1/1440257*x^17 + O(x^18)
@eprog\noindent

The library syntax is \fun{GEN}{ellzeta}{GEN w, GEN z = NULL, long prec}.

\subsec{ellztopoint$(E,z)$}\kbdsidx{ellztopoint}\label{se:ellztopoint}
$E$ being an \var{ell} as output by
\kbd{ellinit}, computes the coordinates $[x,y]$ on the curve $E$
corresponding to the complex number $z$. Hence this is the inverse function
of \kbd{ellpointtoz}. In other words, if the curve is put in Weierstrass
form $y^2 = 4x^3 - g_2x - g_3$, $[x,y]$ represents the Weierstrass
$\wp$-function\sidx{Weierstrass $\wp$-function} and its derivative. More
precisely, we have
$$x = \wp(z) - b_2/12,\quad y = \wp'(z) - (a_1 x + a_3)/2.$$
If $z$ is in the lattice defining $E$ over $\C$, the result is the point at
infinity $[0]$.

The library syntax is \fun{GEN}{pointell}{GEN E, GEN z, long prec}.

\subsec{genus2red$(Q,P,\{p\})$}\kbdsidx{genus2red}\label{se:genus2red}
Let $Q,P$ be polynomials with integer coefficients.
Determines the reduction at $p > 2$ of the (proper, smooth) genus~2
curve $C/\Q$, defined by the hyperelliptic equation $y^2+Qy = P$. (The
special fiber $X_p$ of the minimal regular model $X$ of $C$ over $\Z$.)
If $p$ is omitted, determines the reduction type for all (odd) prime
divisors of the discriminant.

\noindent This function rewritten from an implementation of Liu's algorithm by
Cohen and Liu (1994), \kbd{genus2reduction-0.3}, see
\kbd{http://www.math.u-bordeaux1.fr/\til liu/G2R/}.

\misctitle{CAVEAT} The function interface may change: for the
time being, it returns $[N,\var{FaN}, T, V]$
where $N$ is either the local conductor at $p$ or the
global conductor, \var{FaN} is its factorization, $y^2 = T$ defines a
minimal model over $\Z[1/2]$ and $V$ describes the reduction type at the
various considered~$p$. Unfortunately, the program is not complete for
$p = 2$, and we may return the odd part of the conductor only: this is the
case if the factorization includes the (impossible) term $2^{-1}$; if the
factorization contains another power of $2$, then this is the exact local
conductor at $2$ and $N$ is the global conductor.

\bprog
? default(debuglevel, 1);
? genus2red(0,x^6 + 3*x^3 + 63, 3)
(potential) stable reduction: [1, []]
reduction at p: [III{9}] page 184, [3, 3], f = 10
%1 = [59049, Mat([3, 10]), x^6 + 3*x^3 + 63, [3, [1, []],
       ["[III{9}] page 184", [3, 3]]]]
? [N, FaN, T, V] = genus2red(x^3-x^2-1, x^2-x);  \\ X_1(13), global reduction
p = 13
(potential) stable reduction: [5, [Mod(0, 13), Mod(0, 13)]]
reduction at p: [I{0}-II-0] page 159, [], f = 2
? N
%3 = 169
? FaN
%4 = Mat([13, 2])   \\ in particular, good reduction at 2 !
? T
%5 = x^6 + 58*x^5 + 1401*x^4 + 18038*x^3 + 130546*x^2 + 503516*x + 808561
? V
%6 = [[13, [5, [Mod(0, 13), Mod(0, 13)]], ["[I{0}-II-0] page 159", []]]]
@eprog\noindent
We now first describe the format of the vector $V = V_p$ in the case where
$p$ was specified (local reduction at~$p$): it is a triple $[p, \var{stable},
\var{red}]$. The component $\var{stable} = [\var{type}, \var{vecj}]$ contains
information about the stable reduction after a field extension;
depending on \var{type}s, the stable reduction is

\item 1: smooth (i.e. the curve has potentially good reduction). The
      Jacobian $J(C)$ has potentially good reduction.

\item 2: an elliptic curve $E$ with an ordinary double point; \var{vecj}
contains $j$ mod $p$, the modular invariant of $E$. The (potential)
semi-abelian reduction of $J(C)$ is the extension of an elliptic curve (with
modular invariant $j$ mod $p$) by a torus.

\item 3: a projective line with two ordinary double points. The Jacobian
$J(C)$ has potentially multiplicative reduction.

\item 4: the union of two projective lines crossing transversally at three
points. The Jacobian $J(C)$ has potentially multiplicative reduction.

\item 5: the union of two elliptic curves $E_1$ and $E_2$ intersecting
transversally at one point; \var{vecj} contains their modular invariants
$j_1$ and $j_2$, which may live in a quadratic extension of $\F_p$ are need
not be distinct. The Jacobian $J(C)$ has potentially good reduction,
isomorphic to the product of the reductions of $E_1$ and $E_2$.

\item 6: the union of an elliptic curve $E$ and a projective line which has
an ordinary double point, and these two components intersect transversally
at one point; \var{vecj} contains $j$ mod $p$, the modular invariant of $E$.
The (potential) semi-abelian reduction of $J(C)$ is the extension of an
elliptic curve (with modular invariant $j$ mod $p$) by a torus.

\item 7: as in type 6, but the two components are both singular. The
Jacobian $J(C)$ has potentially multiplicative reduction.

The component $\var{red} = [\var{NUtype}, \var{neron}]$ contains two data
concerning the reduction at $p$ without any ramified field extension.

The \var{NUtype} is a \typ{STR} describing the reduction at $p$ of $C$,
following Namikawa-Ueno, \emph{The complete classification of fibers in
pencils of curves of genus two}, Manuscripta Math., vol. 9, (1973), pages
143-186. The reduction symbol is followed by the corresponding page number in
this article.

The second datum \var{neron} is the group of connected components (over an
algebraic closure of $\F_p$) of the N\'eron model of $J(C)$, given as a
finite abelian group (vector of elementary divisors).
\smallskip
If $p = 2$, the \var{red} component may be omitted altogether (and
replaced by \kbd{[]}, in the case where the program could not compute it.
When $p$ was not specified, $V$ is the vector of all $V_p$, for all
considered $p$.

\misctitle{Notes about Namikawa-Ueno types}

\item A lower index is denoted between braces: for instance, \kbd{[I\obr
 2\cbr-II-5]} means \kbd{[I\_2-II-5]}.

\item If $K$ and $K'$ are Kodaira symbols for singular fibers of elliptic
curves, \kbd{[$K$-$K'$-m]} and \kbd{[$K'$-$K$-m]} are the same.

\item \kbd{[$K$-$K'$-$-1$]}  is \kbd{[$K'$-$K$-$\alpha$]} in the notation of
Namikawa-Ueno.

\item The figure \kbd{[2I\_0-m]} in Namikawa-Ueno, page 159, must be denoted
by \kbd{[2I\_0-(m+1)]}.

The library syntax is \fun{GEN}{genus2red}{GEN Q, GEN P, GEN p = NULL}.
%SECTION: elliptic_curves

\section{Functions related to general number fields}

In this section can be found functions which are used almost exclusively for
working in general number fields. Other less specific functions can be found
in the next section on polynomials. Functions related to quadratic number
fields are found in section \secref{se:arithmetic} (Arithmetic functions).

\subsec{Number field structures}

Let $K = \Q[X] / (T)$ a number field, $\Z_K$ its ring of integers, $T\in\Z[X]$
is monic. Three basic number field structures can be associated to $K$ in
GP:

\item $\tev{nf}$ denotes a number field, i.e.~a data structure output by
\tet{nfinit}. This contains the basic arithmetic data associated to the
number field: signature, maximal order (given by a basis \kbd{nf.zk}),
discriminant, defining polynomial $T$, etc.

\item $\tev{bnf}$ denotes a ``Buchmann's number field'', i.e.~a
data structure output by \tet{bnfinit}. This contains
$\var{nf}$ and the deeper invariants of the field: units $U(K)$, class group
$\Cl(K)$, as well as technical data required to solve the two associated
discrete logarithm problems.

\item $\tev{bnr}$ denotes a ``ray number field'', i.e.~a data structure
output by \kbd{bnrinit}, corresponding to the ray class group structure of
the field, for some modulus $f$. It contains a \var{bnf}, the modulus
$f$, the ray class group $\Cl_f(K)$ and data associated to
the discrete logarithm problem therein.

\subsec{Algebraic numbers and ideals}

\noindent An \tev{algebraic number} belonging to $K = \Q[X]/(T)$ is given as

\item a \typ{INT}, \typ{FRAC} or \typ{POL} (implicitly modulo $T$), or

\item a \typ{POLMOD} (modulo $T$), or

\item a \typ{COL}~\kbd{v} of dimension $N = [K:\Q]$, representing
the element in terms of the computed integral basis, as
\kbd{sum(i = 1, N,~v[i] * nf.zk[i])}. Note that a \typ{VEC}
will not be recognized.
\medskip

\noindent An \tev{ideal} is given in any of the following ways:

\item an algebraic number in one of the above forms, defining a principal ideal.

\item a prime ideal, i.e.~a 5-component vector in the format output by
\kbd{idealprimedec} or \kbd{idealfactor}.

\item a \typ{MAT}, square and in Hermite Normal Form (or at least
upper triangular with non-negative coefficients), whose columns represent a
$\Z$-basis of the ideal.

One may use \kbd{idealhnf} to convert any ideal to the last (preferred) format.

\item an \emph{extended ideal} \sidx{ideal (extended)} is a 2-component
vector $[I, t]$, where $I$ is an ideal as above and $t$ is an algebraic
number, representing the ideal $(t)I$. This is useful whenever \tet{idealred}
is involved, implicitly working in the ideal class group, while keeping track
of principal ideals. Ideal operations suitably update the principal part
when it makes sense (in a multiplicative context), e.g.~using \kbd{idealmul}
on $[I,t]$, $[J,u]$, we obtain $[IJ, tu]$. When it does not make sense, the
extended part is silently discarded, e.g.~using \kbd{idealadd} with the above
input produces $I+J$.

The ``principal part'' $t$ in an extended ideal may be
represented in any of the above forms, and \emph{also} as a factorization
matrix (in terms of number field elements, not ideals!), possibly the empty
matrix \kbd{[;]} representing $1$. In the latter case, elements stay in
factored form, or \tev{famat} for \emph{fa}ctorization \emph{mat}rix, which
is a convenient way to avoid coefficient explosion. To recover the
conventional expanded form, try \tet{nffactorback}; but many functions
already accept \var{famat}s as input, for instance \tet{ideallog}, so
expanding huge elements should never be necessary.

\subsec{Finite abelian groups}

A finite abelian group $G$ in user-readable format is given by its Smith
Normal Form as a pair $[h,d]$ or triple $[h,d,g]$.
Here $h$ is the cardinality of $G$, $(d_i)$ is the vector of elementary
divisors, and $(g_i)$ is a vector of generators. In short,
$G = \oplus_{i\leq n} (\Z/d_i\Z) g_i$, with $d_n \mid \dots \mid d_2 \mid d_1$
and $\prod d_i = h$. This information can also be retrieved as
$G.\kbd{no}$, $G.\kbd{cyc}$ and $G.\kbd{gen}$.

\item a \tev{character} on the abelian group
$\oplus (\Z/d_i\Z) g_i$
is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_i^{n_i}) = \exp(2i\pi\sum a_i n_i / d_i)$.

\item given such a structure, a \tev{subgroup} $H$ is input as a square
matrix in HNF, whose columns express generators of $H$ on the given generators
$g_i$. Note that the determinant of that matrix is equal to the index $(G:H)$.

\subsec{Relative extensions}

We now have a look at data structures associated to relative extensions
of number fields $L/K$, and to projective $\Z_K$-modules. When defining a
relative extension $L/K$, the $\var{nf}$ associated to the base field $K$
must be defined by a variable having a lower priority (see
\secref{se:priority}) than the variable defining the extension. For example,
you may use the variable name $y$ to define the base field $K$, and $x$ to
define the relative extension $L/K$.

\subsubsec{Basic definitions}\label{se:ZKmodules}

\item $\tev{rnf}$ denotes a relative number field, i.e.~a data structure
output by \kbd{rnfinit}, associated to the extension $L/K$. The \var{nf}
associated to be base field $K$ is \kbd{rnf.nf}.

\item A \emph{relative matrix} is an $m\times n$ matrix whose entries are
elements of $K$, in any form. Its $m$ columns $A_j$ represent elements
in $K^n$.

\item An \tev{ideal list} is a row vector of fractional ideals of the number
field $\var{nf}$.

\item A \tev{pseudo-matrix} is a 2-component row vector $(A,I)$ where $A$
is a relative $m\times n$ matrix and $I$ an ideal list of length $n$. If $I =
\{{\Bbb a}_1,\dots, {\Bbb a}_n\}$ and the columns of $A$ are $(A_1,\dots,
A_n)$, this data defines the torsion-free (projective) $\Z_K$-module ${\Bbb
a}_1 A_1\oplus {\Bbb a}_n A_n$.

\item An \tev{integral pseudo-matrix} is a 3-component row vector w$(A,I,J)$
where $A = (a_{i,j})$ is an $m\times n$ relative matrix and $I = ({\Bbb
b}_1,\dots, {\Bbb b}_m)$, $J = ({\Bbb a}_1,\dots, {\Bbb a}_n)$ are ideal
lists, such that $a_{i,j} \in {\Bbb b}_i {\Bbb a}_j^{-1}$ for all $i,j$. This
data defines two abstract projective $\Z_K$-modules $N = {\Bbb
a_1}\omega_1\oplus \cdots\oplus {\Bbb a_n}\omega_n $ in $K^n$, $P = {\Bbb
b_1}\eta_1\oplus \cdots\oplus {\Bbb b_m}\eta_m$ in $K^m$, and a $\Z_K$-linear
map $f:N\to P$ given by
$$ f(\sum \alpha_j\omega_j) = \sum_i \Big(a_{i,j}\alpha_j\Big) \eta_i.$$
This data defines the $\Z_K$-module $M = P/f(N)$.

\item Any \emph{projective} $\Z_K$-module\varsidx{projective module} $M$
of finite type in $K^m$ can be given by a pseudo matrix $(A,I)$.

\item An arbitrary $\Z_K$ modules of finite type in $K^m$, with non-trivial
torsion, is given by an integral pseudo-matrix $(A,I,J)$

\subsubsec{Pseudo-bases, determinant}

\item The pair $(A,I)$ is a \tev{pseudo-basis} of the module it
generates if the ${\Bbb a_j}$ are non-zero, and the $A_j$ are $K$-linearly
independent. We call $n$ the \emph{size} of the pseudo-basis. If $A$ is a
relative matrix, the latter condition means it is square with non-zero
determinant; we say that it is in Hermite Normal Form\sidx{Hermite normal
form} (HNF) if it is upper triangular and all the elements of the diagonal
are equal to 1.

\item For instance, the relative integer basis \kbd{rnf.zk} is a pseudo-basis
$(A,I)$ of $\Z_L$, where $A = \kbd{rnf.zk[1]}$ is a vector of elements of $L$,
which are $K$-linearly independent. Most \var{rnf} routines return and handle
$\Z_K$-modules contained in $L$ (e.g.~$\Z_L$-ideals) via a pseudo-basis
$(A',I')$, where $A'$ is a relative matrix representing a vector of elements of
$L$ in terms of the fixed basis \kbd{rnf.zk[1]}

\item The \emph{determinant} of a pseudo-basis $(A,I)$ is the ideal
equal to the product of the determinant of $A$ by all the ideals of $I$. The
determinant of a pseudo-matrix is the determinant of any pseudo-basis of the
module it generates.

\subsec{Class field theory}\label{se:CFT}

A $\tev{modulus}$, in the sense of class field theory, is a divisor supported
on the non-complex places of $K$. In PARI terms, this means either an
ordinary ideal $I$ as above (no Archimedean component), or a pair $[I,a]$,
where $a$ is a vector with $r_1$ $\{0,1\}$-components, corresponding to the
infinite part of the divisor. More precisely, the $i$-th component of $a$
corresponds to the real embedding associated to the $i$-th real root of
\kbd{K.roots}. (That ordering is not canonical, but well defined once a
defining polynomial for $K$ is chosen.) For instance, \kbd{[1, [1,1]]} is a
modulus for a real quadratic field, allowing ramification at any of the two
places at infinity, and nowhere else.

A \tev{bid} or ``big ideal'' is a structure output by \kbd{idealstar}
needed to compute in $(\Z_K/I)^*$, where $I$ is a modulus in the above sense.
It is a finite abelian group as described above, supplemented by
technical data needed to solve discrete log problems.

Finally we explain how to input ray number fields (or \var{bnr}), using class
field theory. These are defined by a triple $A$, $B$, $C$, where the
defining set $[A,B,C]$ can have any of the following forms: $[\var{bnr}]$,
$[\var{bnr},\var{subgroup}]$, $[\var{bnf},\var{mod}]$,
$[\var{bnf},\var{mod},\var{subgroup}]$. The last two forms are kept for
backward compatibility, but no longer serve any real purpose (see example
below); no newly written function will accept them.

\item $\var{bnf}$ is as output by \kbd{bnfinit}, where units are mandatory
unless the modulus is trivial; \var{bnr} is as output by \kbd{bnrinit}. This
is the ground field $K$.

\item \emph{mod} is a modulus $\goth{f}$, as described above.

\item \emph{subgroup} a subgroup of the ray class group modulo $\goth{f}$ of
$K$. As described above, this is input as a square matrix expressing
generators of a subgroup of the ray class group \kbd{\var{bnr}.clgp} on the
given generators.

The corresponding \var{bnr} is the subfield of the ray class field of $K$
modulo $\goth{f}$, fixed by the given subgroup.

\bprog
  ? K = bnfinit(y^2+1);
  ? bnr = bnrinit(K, 13)
  ? %.clgp
  %3 = [36, [12, 3]]
  ? bnrdisc(bnr); \\ discriminant of the full ray class field
  ? bnrdisc(bnr, [3,1;0,1]); \\ discriminant of cyclic cubic extension of K
@eprog\noindent
We could have written directly
\bprog
  ? bnrdisc(K, 13);
  ? bnrdisc(K, 13, [3,1;0,1]);
@eprog\noindent
avoiding one \tet{bnrinit}, but this would actually be slower since the
\kbd{bnrinit} is called internally anyway. And now twice!

\subsec{General use}

All the functions which are specific to relative extensions, number fields,
Buchmann's number fields, Buchmann's number rays, share the prefix \kbd{rnf},
\kbd{nf}, \kbd{bnf}, \kbd{bnr} respectively. They take as first argument a
number field of that precise type, respectively output by \kbd{rnfinit},
\kbd{nfinit}, \kbd{bnfinit}, and \kbd{bnrinit}.

However, and even though it may not be specified in the descriptions of the
functions below, it is permissible, if the function expects a $\var{nf}$, to
use a $\var{bnf}$ instead, which contains much more information. On the other
hand, if the function requires a \kbd{bnf}, it will \emph{not} launch
\kbd{bnfinit} for you, which is a costly operation. Instead, it will give you
a specific error message. In short, the types
$$ \kbd{nf} \leq \kbd{bnf} \leq \kbd{bnr}$$
are ordered, each function requires a minimal type to work properly, but you
may always substitute a larger type.

The data types corresponding to the structures described above are rather
complicated. Thus, as we already have seen it with elliptic curves, GP
provides ``member functions'' to retrieve data from these structures (once
they have been initialized of course). The relevant types of number fields
are indicated between parentheses: \smallskip

\sidx{member functions}
\settabs\+xxxxxxx&(\var{bnr},x&\var{bnf},x&nf\hskip2pt&)x&: &\cr
\+\tet{bid}    &(\var{bnr}&&&)&: & bid ideal structure.\cr

\+\tet{bnf}    &(\var{bnr},& \var{bnf}&&)&: & Buchmann's number field.\cr

\+\tet{clgp}  &(\var{bnr},& \var{bnf}&&)&: & classgroup. This one admits the
following three subclasses:\cr

\+      \quad \tet{cyc} &&&&&: & \quad cyclic decomposition
 (SNF)\sidx{Smith normal form}.\cr

\+      \quad \kbd{gen}\sidx{gen (member function)} &&&&&: &
 \quad generators.\cr

\+      \quad \tet{no}  &&&&&: & \quad number of elements.\cr

\+\tet{diff}  &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the different ideal.\cr

\+\tet{codiff}&(\var{bnr},& \var{bnf},& \var{nf}&)&: & the codifferent
(inverse of the different in the ideal group).\cr

\+\tet{disc} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & discriminant.\cr

\+\tet{fu}   &(\var{bnr},& \var{bnf}&&)&: & \idx{fundamental units}.\cr

\+\tet{index}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: &
 \idx{index} of the power order in the ring of integers.\cr

\+\tet{mod}   &(\var{bnr}&&&)&: & modulus.\cr

\+\tet{nf}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & number field.\cr

\+\tet{pol}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & defining polynomial.\cr

\+\tet{r1} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the number
of real embeddings.\cr

\+\tet{r2} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the number
of pairs of complex embeddings.\cr

\+\tet{reg}  &(\var{bnr},& \var{bnf}&&)&: & regulator.\cr

\+\tet{roots}&(\var{bnr},& \var{bnf},& \var{nf}&)&: & roots of the
polynomial generating the field.\cr

\+\tet{sign} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & signature $[r1,r2]$.\cr

\+\tet{t2}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the $T_2$ matrix (see
\kbd{nfinit}).\cr

\+\tet{tu}   &(\var{bnr},& \var{bnf}&&)&: & a generator for the torsion
units.\cr

\+\tet{zk}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & integral basis, i.e.~a
$\Z$-basis of the maximal order.\cr

\+\tet{zkst}   &(\var{bnr}&&&)&: & structure of $(\Z_K/m)^*$.\cr

\misctitle{Deprecated} The following member functions are still available, but deprecated and should not be used in new scripts :
\+\tet{futu} &(\var{bnr},& \var{bnf},&&)&: &
 $[u_1,...,u_r,w]$, $(u_i)$ is a vector of fundamental units,\cr
\+&&&&&& $w$ generates the torsion units.\cr

\+\tet{tufu} &(\var{bnr},& \var{bnf},&&)&: &
 $[w,u_1,...,u_r]$, $(u_i)$ is a vector of fundamental units,\cr
\+&&&&&& $w$ generates the torsion units.\cr


  For instance, assume that $\var{bnf} = \kbd{bnfinit}(\var{pol})$, for some
polynomial. Then \kbd{\var{bnf}.clgp} retrieves the class group, and
\kbd{\var{bnf}.clgp.no} the class number. If we had set $\var{bnf} =
\kbd{nfinit}(\var{pol})$, both would have output an error message. All these
functions are completely recursive, thus for instance
\kbd{\var{bnr}.bnf.nf.zk} will yield the maximal order of \var{bnr}, which
you could get directly with a simple \kbd{\var{bnr}.zk}.

\subsec{Class group, units, and the GRH}\label{se:GRHbnf}

Some of the functions starting with \kbd{bnf} are implementations of the
sub-exponential algorithms for finding class and unit groups under \idx{GRH},
due to Hafner-McCurley, \idx{Buchmann} and Cohen-Diaz-Olivier. The general
call to the functions concerning class groups of general number fields
(i.e.~excluding \kbd{quadclassunit}) involves a polynomial $P$ and a
technical vector
$$\var{tech} = [c_1, c_2, \var{nrpid} ],$$
where the parameters are to be understood as follows:

$P$ is the defining polynomial for the number field, which must be in
$\Z[X]$, irreducible and monic. In fact, if you supply a non-monic polynomial
at this point, \kbd{gp} issues a warning, then \emph{transforms your
polynomial} so that it becomes monic. The \kbd{nfinit} routine
will return a different result in this case: instead of \kbd{res}, you get a
vector \kbd{[res,Mod(a,Q)]}, where \kbd{Mod(a,Q) = Mod(X,P)} gives the change
of variables. In all other routines, the variable change is simply lost.

The \var{tech} interface is obsolete and you should not tamper with
these parameters. Indeed, from version 2.4.0 on,

\item the results are always rigorous under \idx{GRH} (before that version,
they relied on a heuristic strengthening, hence the need for overrides).

\item the influence of these parameters on execution time and stack size is
marginal. They \emph{can} be useful to fine-tune and experiment with the
\kbd{bnfinit} code, but you will be better off modifying all tuning
parameters in the C code (there are many more than just those three).
We nevertheless describe it for completeness.

The numbers $c_1 \leq c_2$ are non-negative real numbers. By default they are
chosen so that the result is correct under GRH. For $i = 1,2$, let
$B_i = c_i(\log |d_K|)^2$, and denote by $S(B)$ the set of maximal ideals of
$K$ whose norm is less than $B$. We want $S(B_1)$ to generate $\Cl(K)$ and hope
that $S(B_2)$ can be \emph{proven} to generate $\Cl(K)$.

More precisely, $S(B_1)$ is a factorbase used to compute a tentative
$\Cl(K)$ by generators and relations. We then check explicitly, using
essentially \kbd{bnfisprincipal}, that the elements of $S(B_2)$ belong to the
span of $S(B_1)$. Under the assumption that $S(B_2)$ generates $\Cl(K)$, we
are done. User-supplied $c_i$ are only used to compute initial guesses for
the bounds $B_i$, and the algorithm increases them until one can \emph{prove}
under GRH that $S(B_2)$ generates $\Cl(K)$. A uniform result of Bach says
that $c_2 = 12$ is always suitable, but this bound is very pessimistic and a
direct algorithm due to Belabas-Diaz-Friedman is used to check the condition,
assuming GRH. The default values are $c_1 = c_2 = 0$. When $c_1$ is equal to
$0$ the algorithm takes it equal to $c_2$.

$\var{nrpid}$ is the maximal number of small norm relations associated to each
ideal in the factor base. Set it to $0$ to disable the search for small norm
relations. Otherwise, reasonable values are between 4 and 20. The default is
4.

\misctitle{Warning} Make sure you understand the above! By default, most of
the \kbd{bnf} routines depend on the correctness of the GRH. In particular,
any of the class number, class group structure, class group generators,
regulator and fundamental units may be wrong, independently of each other.
Any result computed from such a \kbd{bnf} may be wrong. The only guarantee is
that the units given generate a subgroup of finite index in the full unit
group. You must use \kbd{bnfcertify} to certify the computations
unconditionally.

\misctitle{Remarks}

You do not need to supply the technical parameters (under the library you
still need to send at least an empty vector, coded as \kbd{NULL}). However,
should you choose to set some of them, they \emph{must} be given in the
requested order. For example, if you want to specify a given value of
\var{nrpid}, you must give some values as well for $c_1$ and $c_2$, and provide
a vector $[c_1,c_2,\var{nrpid}]$.

Note also that you can use an $\var{nf}$ instead of $P$, which avoids
recomputing the integral basis and analogous quantities.

\smallskip


\subsec{bnfcertify$(\var{bnf},\{\fl = 0\})$}\kbdsidx{bnfcertify}\label{se:bnfcertify}
$\var{bnf}$ being as output by
\kbd{bnfinit}, checks whether the result is correct, i.e.~whether it is
possible to remove the assumption of the Generalized Riemann
Hypothesis\sidx{GRH}. It is correct if and only if the answer is 1. If it is
incorrect, the program may output some error message, or loop indefinitely.
You can check its progress by increasing the debug level. The \var{bnf}
structure must contain the fundamental units:
\bprog
? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
  ***   at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
  ***                                        ^-------------
  *** bnfcertify: missing units in bnf.
? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
? bnfcertify(K)
%3 = 1
@eprog

If flag is present, only certify that the class group is a quotient of the
one computed in bnf (much simpler in general); likewise, the computed units
may form a subgroup of the full unit group. In this variant, the units are
no longer needed:
\bprog
? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
%4 = 1
@eprog

The library syntax is \fun{long}{bnfcertify0}{GEN bnf, long flag }.
Also available is  \fun{GEN}{bnfcertify}{GEN bnf} ($\fl=0$).

\subsec{bnfcompress$(\var{bnf})$}\kbdsidx{bnfcompress}\label{se:bnfcompress}
Computes a compressed version of \var{bnf} (from \tet{bnfinit}), a
``small Buchmann's number field'' (or \var{sbnf} for short) which contains
enough information to recover a full $\var{bnf}$ vector very rapidly, but
which is much smaller and hence easy to store and print. Calling
\kbd{bnfinit} on the result recovers a true \kbd{bnf}, in general different
from the original. Note that an \tev{snbf} is useless for almost all
purposes besides storage, and must be converted back to \tev{bnf} form
before use; for instance, no \kbd{nf*}, \kbd{bnf*} or member function
accepts them.

An \var{sbnf} is a 12 component vector $v$, as follows. Let \kbd{bnf} be
the result of a full \kbd{bnfinit}, complete with units. Then $v[1]$ is
\kbd{bnf.pol}, $v[2]$ is the number of real embeddings \kbd{bnf.sign[1]},
$v[3]$ is \kbd{bnf.disc}, $v[4]$ is \kbd{bnf.zk}, $v[5]$ is the list of roots
\kbd{bnf.roots}, $v[7]$ is the matrix $\kbd{W} = \kbd{bnf[1]}$,
$v[8]$ is the matrix $\kbd{matalpha}=\kbd{bnf[2]}$,
$v[9]$ is the prime ideal factor base \kbd{bnf[5]} coded in a compact way,
and ordered according to the permutation \kbd{bnf[6]}, $v[10]$ is the
2-component vector giving the number of roots of unity and a generator,
expressed on the integral basis, $v[11]$ is the list of fundamental units,
expressed on the integral basis, $v[12]$ is a vector containing the algebraic
numbers alpha corresponding to the columns of the matrix \kbd{matalpha},
expressed on the integral basis.

All the components are exact (integral or rational), except for the roots in
$v[5]$.

The library syntax is \fun{GEN}{bnfcompress}{GEN bnf}.

\subsec{bnfdecodemodule$(\var{nf},m)$}\kbdsidx{bnfdecodemodule}\label{se:bnfdecodemodule}
If $m$ is a module as output in the
first component of an extension given by \kbd{bnrdisclist}, outputs the
true module.
\bprog
? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[1][2]
%1 = [[Mat([8, 1]), [[0, 0, 0]]], [Mat([9, 1]), [[0, 0, 0]]]]
? bnfdecodemodule(K, s[1][1])
%2 =
[2 0]

[0 1]
@eprog

The library syntax is \fun{GEN}{decodemodule}{GEN nf, GEN m}.

\subsec{bnfinit$(P,\{\fl=0\},\{\var{tech}=[\,]\})$}\kbdsidx{bnfinit}\label{se:bnfinit}
Initializes a
\var{bnf} structure. Used in programs such as \kbd{bnfisprincipal},
\kbd{bnfisunit} or \kbd{bnfnarrow}. By default, the results are conditional
on the GRH, see \ref{se:GRHbnf}. The result is a
10-component vector \var{bnf}.

This implements \idx{Buchmann}'s sub-exponential algorithm for computing the
class group, the regulator and a system of \idx{fundamental units} of the
general algebraic number field $K$ defined by the irreducible polynomial $P$
with integer coefficients.

If the precision becomes insufficient, \kbd{gp} does not strive to compute
the units by default ($\fl=0$).

When $\fl=1$, we insist on finding the fundamental units exactly. Be
warned that this can take a very long time when the coefficients of the
fundamental units on the integral basis are very large. If the fundamental
units are simply too large to be represented in this form, an error message
is issued. They could be obtained using the so-called compact representation
of algebraic numbers as a formal product of algebraic integers. The latter is
implemented internally but not publicly accessible yet.

$\var{tech}$ is a technical vector (empty by default, see \ref{se:GRHbnf}).
Careful use of this parameter may speed up your computations,
but it is mostly obsolete and you should leave it alone.

\smallskip

The components of a \var{bnf} or \var{sbnf} are technical and never used by
the casual user. In fact: \emph{never access a component directly, always use
a proper member function.} However, for the sake of completeness and internal
documentation, their description is as follows. We use the notations
explained in the book by H. Cohen, \emph{A Course in Computational Algebraic
Number Theory}, Graduate Texts in Maths \key{138}, Springer-Verlag, 1993,
Section 6.5, and subsection 6.5.5 in particular.

$\var{bnf}[1]$ contains the matrix $W$, i.e.~the matrix in Hermite normal
form giving relations for the class group on prime ideal generators
$(\goth{p}_i)_{1\le i\le r}$.

$\var{bnf}[2]$ contains the matrix $B$, i.e.~the matrix containing the
expressions of the prime ideal factorbase in terms of the $\goth{p}_i$.
It is an $r\times c$ matrix.

$\var{bnf}[3]$ contains the complex logarithmic embeddings of the system of
fundamental units which has been found. It is an $(r_1+r_2)\times(r_1+r_2-1)$
matrix.

$\var{bnf}[4]$ contains the matrix $M''_C$ of Archimedean components of the
relations of the matrix $(W|B)$.

$\var{bnf}[5]$ contains the prime factor base, i.e.~the list of prime
ideals used in finding the relations.

$\var{bnf}[6]$ used to contain a permutation of the prime factor base, but
has been obsoleted. It contains a dummy $0$.

$\var{bnf}[7]$ or \kbd{\var{bnf}.nf} is equal to the number field data
$\var{nf}$ as would be given by \kbd{nfinit}.

$\var{bnf}[8]$ is a vector containing the classgroup \kbd{\var{bnf}.clgp}
as a finite abelian group, the regulator \kbd{\var{bnf}.reg}, a $1$ (used to
contain an obsolete ``check number''), the number of roots of unity and a
generator \kbd{\var{bnf}.tu}, the fundamental units \kbd{\var{bnf}.fu}.

$\var{bnf}[9]$ is a 3-element row vector used in \tet{bnfisprincipal} only
and obtained as follows. Let $D = U W V$ obtained by applying the
\idx{Smith normal form} algorithm to the matrix $W$ (= $\var{bnf}[1]$) and
let $U_r$ be the reduction of $U$ modulo $D$. The first elements of the
factorbase are given (in terms of \kbd{bnf.gen}) by the columns of $U_r$,
with Archimedean component $g_a$; let also $GD_a$ be the Archimedean
components of the generators of the (principal) ideals defined by the
\kbd{bnf.gen[i]\pow bnf.cyc[i]}. Then $\var{bnf}[9]=[U_r, g_a, GD_a]$.

$\var{bnf}[10]$ is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available, which
is rarely needed, hence would be too expensive to compute during the initial
\kbd{bnfinit} call. For instance, the generators of the principal ideals
\kbd{bnf.gen[i]\pow bnf.cyc[i]} (during a call to \tet{bnrisprincipal}), or
those corresponding to the relations in $W$ and $B$ (when the \kbd{bnf}
internal precision needs to be increased).

The library syntax is \fun{GEN}{bnfinit0}{GEN P, long flag, GEN tech = NULL, long prec}.

Also available is \fun{GEN}{Buchall}{GEN P, long flag, long prec},
corresponding to \kbd{tech = NULL}, where
\kbd{flag} is either $0$ (default) or \tet{nf_FORCE} (insist on finding
fundamental units). The function
\fun{GEN}{Buchall_param}{GEN P, double c1, double c2, long nrpid, long flag, long prec} gives direct access to the technical parameters.

\subsec{bnfisintnorm$(\var{bnf},x)$}\kbdsidx{bnfisintnorm}\label{se:bnfisintnorm}
Computes a complete system of
solutions (modulo units of positive norm) of the absolute norm equation
$\Norm(a)=x$,
where $a$ is an integer in $\var{bnf}$. If $\var{bnf}$ has not been certified,
the correctness of the result depends on the validity of \idx{GRH}.

See also \tet{bnfisnorm}.

The library syntax is \fun{GEN}{bnfisintnorm}{GEN bnf, GEN x}.
The function \fun{GEN}{bnfisintnormabs}{GEN bnf, GEN a}
returns a complete system of solutions modulo units of the absolute norm
equation $|\Norm(x)| = |a|$. As fast as \kbd{bnfisintnorm}, but solves
the two equations $\Norm(x) = \pm a$ simultaneously.

\subsec{bnfisnorm$(\var{bnf},x,\{\fl=1\})$}\kbdsidx{bnfisnorm}\label{se:bnfisnorm}
Tries to tell whether the
rational number $x$ is the norm of some element y in $\var{bnf}$. Returns a
vector $[a,b]$ where $x=Norm(a)*b$. Looks for a solution which is an $S$-unit,
with $S$ a certain set of prime ideals containing (among others) all primes
dividing $x$. If $\var{bnf}$ is known to be \idx{Galois}, set $\fl=0$ (in
this case, $x$ is a norm iff $b=1$). If $\fl$ is non zero the program adds to
$S$ the following prime ideals, depending on the sign of $\fl$. If $\fl>0$,
the ideals of norm less than $\fl$. And if $\fl<0$ the ideals dividing $\fl$.

Assuming \idx{GRH}, the answer is guaranteed (i.e.~$x$ is a norm iff $b=1$),
if $S$ contains all primes less than $12\log(\disc(\var{Bnf}))^2$, where
$\var{Bnf}$ is the Galois closure of $\var{bnf}$.

See also \tet{bnfisintnorm}.

The library syntax is \fun{GEN}{bnfisnorm}{GEN bnf, GEN x, long flag}.

\subsec{bnfisprincipal$(\var{bnf},x,\{\fl=1\})$}\kbdsidx{bnfisprincipal}\label{se:bnfisprincipal}
$\var{bnf}$ being the \sidx{principal ideal}
number field data output by \kbd{bnfinit}, and $x$ being an ideal, this
function tests whether the ideal is principal or not. The result is more
complete than a simple true/false answer and solves general discrete
logarithm problem. Assume the class group is $\oplus (\Z/d_i\Z)g_i$
(where the generators $g_i$ and their orders $d_i$ are respectively given by
\kbd{bnf.gen} and \kbd{bnf.cyc}). The routine returns a row vector $[e,t]$,
where $e$ is a vector of exponents $0 \leq e_i < d_i$, and $t$ is a number
field element such that
$$ x = (t) \prod_i  g_i^{e_i}.$$
For \emph{given} $g_i$ (i.e. for a given \kbd{bnf}), the $e_i$ are unique,
and $t$ is unique modulo units.

In particular, $x$ is principal if and only if $e$ is the zero vector. Note
that the empty vector, which is returned when the class number is $1$, is
considered to be a zero vector (of dimension $0$).
\bprog
? K = bnfinit(y^2+23);
? K.cyc
%2 = [3]
? K.gen
%3 = [[2, 0; 0, 1]]          \\ a prime ideal above 2
? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
? v = bnfisprincipal(K, P)
%5 = [[2]~, [3/4, 1/4]~]
? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
%6 =
[3 0]

[0 1]
? % == idealhnf(K, P)
%7 = 1
@eprog

\noindent The binary digits of \fl mean:

\item $1$: If set, outputs $[e,t]$ as explained above, otherwise returns
only $e$, which is much easier to compute. The following idiom only tests
whether an ideal is principal:
\bprog
  is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
@eprog

\item $2$: It may not be possible to recover $t$, given the initial accuracy
to which \kbd{bnf} was computed. In that case, a warning is printed and $t$ is
set equal to the empty vector \kbd{[]\til}. If this bit is set,
increase the precision and recompute needed quantities until $t$ can be
computed. Warning: setting this may induce \emph{very} lengthy computations.

The library syntax is \fun{GEN}{bnfisprincipal0}{GEN bnf, GEN x, long flag}.
Instead of the above hardcoded numerical flags, one should
rather use an or-ed combination of the symbolic flags \tet{nf_GEN} (include
generators, possibly a place holder if too difficult) and \tet{nf_FORCE}
(insist on finding the generators).

\subsec{bnfissunit$(\var{bnf},\var{sfu},x)$}\kbdsidx{bnfissunit}\label{se:bnfissunit}
$\var{bnf}$ being output by
\kbd{bnfinit}, \var{sfu} by \kbd{bnfsunit}, gives the column vector of
exponents of $x$ on the fundamental $S$-units and the roots of unity.
If $x$ is not a unit, outputs an empty vector.

The library syntax is \fun{GEN}{bnfissunit}{GEN bnf, GEN sfu, GEN x}.

\subsec{bnfisunit$(\var{bnf},x)$}\kbdsidx{bnfisunit}\label{se:bnfisunit}
\var{bnf} being the number field data
output by \kbd{bnfinit} and $x$ being an algebraic number (type integer,
rational or polmod), this outputs the decomposition of $x$ on the fundamental
units and the roots of unity if $x$ is a unit, the empty vector otherwise.
More precisely, if $u_1$,\dots,$u_r$ are the fundamental units, and $\zeta$
is the generator of the group of roots of unity (\kbd{bnf.tu}), the output is
a vector $[x_1,\dots,x_r,x_{r+1}]$ such that $x=u_1^{x_1}\cdots
u_r^{x_r}\cdot\zeta^{x_{r+1}}$. The $x_i$ are integers for $i\le r$ and is an
integer modulo the order of $\zeta$ for $i=r+1$.

Note that \var{bnf} need not contain the fundamental unit explicitly:
\bprog
? setrand(1); bnf = bnfinit(x^2-x-100000);
? bnf.fu
  ***   at top-level: bnf.fu
  ***                     ^--
  *** _.fu: missing units in .fu.
? u = [119836165644250789990462835950022871665178127611316131167, \
       379554884019013781006303254896369154068336082609238336]~;
? bnfisunit(bnf, u)
%3 = [-1, Mod(0, 2)]~
@eprog\noindent The given $u$ is the inverse of the fundamental unit
implicitly stored in \var{bnf}. In this case, the fundamental unit was not
computed and stored in algebraic form since the default accuracy was too
low. (Re-run the command at \bs g1 or higher to see such diagnostics.)

The library syntax is \fun{GEN}{bnfisunit}{GEN bnf, GEN x}.

\subsec{bnfnarrow$(\var{bnf})$}\kbdsidx{bnfnarrow}\label{se:bnfnarrow}
$\var{bnf}$ being as output by
\kbd{bnfinit}, computes the narrow class group of $\var{bnf}$. The output is
a 3-component row vector $v$ analogous to the corresponding class group
component \kbd{\var{bnf}.clgp} (\kbd{\var{bnf}[8][1]}): the first component
is the narrow class number \kbd{$v$.no}, the second component is a vector
containing the SNF\sidx{Smith normal form} cyclic components \kbd{$v$.cyc} of
the narrow class group, and the third is a vector giving the generators of
the corresponding \kbd{$v$.gen} cyclic groups. Note that this function is a
special case of \kbd{bnrinit}.

The library syntax is \fun{GEN}{buchnarrow}{GEN bnf}.

\subsec{bnfsignunit$(\var{bnf})$}\kbdsidx{bnfsignunit}\label{se:bnfsignunit}
$\var{bnf}$ being as output by
\kbd{bnfinit}, this computes an $r_1\times(r_1+r_2-1)$ matrix having $\pm1$
components, giving the signs of the real embeddings of the fundamental units.
The following functions compute generators for the totally positive units:

\bprog
/* exponents of totally positive units generators on bnf.tufu */
tpuexpo(bnf)=
{ my(S,d,K);

  S = bnfsignunit(bnf); d = matsize(S);
  S = matrix(d[1],d[2], i,j, if (S[i,j] < 0, 1,0));
  S = concat(vectorv(d[1],i,1), S);   \\ add sign(-1)
  K = lift(matker(S * Mod(1,2)));
  if (K, mathnfmodid(K, 2), 2*matid(d[1]))
}

/* totally positive units */
tpu(bnf)=
{ my(vu = bnf.tufu, ex = tpuexpo(bnf));

  vector(#ex-1, i, factorback(vu, ex[,i+1]))  \\ ex[,1] is 1
}
@eprog

The library syntax is \fun{GEN}{signunits}{GEN bnf}.

\subsec{bnfsunit$(\var{bnf},S)$}\kbdsidx{bnfsunit}\label{se:bnfsunit}
Computes the fundamental $S$-units of the
number field $\var{bnf}$ (output by \kbd{bnfinit}), where $S$ is a list of
prime ideals (output by \kbd{idealprimedec}). The output is a vector $v$ with
6 components.

$v[1]$ gives a minimal system of (integral) generators of the $S$-unit group
modulo the unit group.

$v[2]$ contains technical data needed by \kbd{bnfissunit}.

$v[3]$ is an empty vector (used to give the logarithmic embeddings of the
generators in $v[1]$ in version 2.0.16).

$v[4]$ is the $S$-regulator (this is the product of the regulator, the
determinant of $v[2]$ and the natural logarithms of the norms of the ideals
in $S$).

$v[5]$ gives the $S$-class group structure, in the usual format
(a row vector whose three components give in order the $S$-class number,
the cyclic components and the generators).

$v[6]$ is a copy of $S$.

The library syntax is \fun{GEN}{bnfsunit}{GEN bnf, GEN S, long prec}.

\subsec{bnrL1$(\var{bnr}, \{H\}, \{\fl=0\})$}\kbdsidx{bnrL1}\label{se:bnrL1}
Let \var{bnr} be the number field data output by \kbd{bnrinit(,,1)} and
\var{H} be a square matrix defining a congruence subgroup of the
ray class group corresponding to \var{bnr} (the trivial congruence subgroup
if omitted). This function returns, for each \idx{character} $\chi$ of the ray
class group which is trivial on $H$, the value at $s = 1$ (or $s = 0$) of the
abelian $L$-function associated to $\chi$. For the value at $s = 0$, the
function returns in fact for each $\chi$ a vector $[r_\chi, c_\chi]$ where
$$L(s, \chi) = c \cdot s^r + O(s^{r + 1})$$
\noindent near $0$.

The argument \fl\ is optional, its binary digits
mean 1: compute at $s = 0$ if unset or $s = 1$ if set, 2: compute the
primitive $L$-function associated to $\chi$ if unset or the $L$-function
with Euler factors at prime ideals dividing the modulus of \var{bnr} removed
if set (that is $L_S(s, \chi)$, where $S$ is the
set of infinite places of the number field together with the finite prime
ideals dividing the modulus of \var{bnr}), 3: return also the character if
set.
\bprog
K = bnfinit(x^2-229);
bnr = bnrinit(K,1,1);
bnrL1(bnr)
@eprog\noindent
returns the order and the first non-zero term of $L(s, \chi)$ at $s = 0$
where $\chi$ runs through the characters of the class group of
$K = \Q(\sqrt{229})$. Then
\bprog
bnr2 = bnrinit(K,2,1);
bnrL1(bnr2,,2)
@eprog\noindent
returns the order and the first non-zero terms of $L_S(s, \chi)$ at $s = 0$
where $\chi$ runs through the characters of the class group of $K$ and $S$ is
the set of infinite places of $K$ together with the finite prime $2$. Note
that the ray class group modulo $2$ is in fact the class group, so
\kbd{bnrL1(bnr2,0)} returns the same answer as \kbd{bnrL1(bnr,0)}.

This function will fail with the message
\bprog
 *** bnrL1: overflow in zeta_get_N0 [need too many primes].
@eprog\noindent if the approximate functional equation requires us to sum
too many terms (if the discriminant of $K$ is too large).

The library syntax is \fun{GEN}{bnrL1}{GEN bnr, GEN H = NULL, long flag, long prec}.

\subsec{bnrclassno$(A,\{B\},\{C\})$}\kbdsidx{bnrclassno}\label{se:bnrclassno}
Let $A$, $B$, $C$ define a class field $L$ over a ground field $K$
(of type \kbd{[\var{bnr}]},
\kbd{[\var{bnr}, \var{subgroup}]},
or \kbd{[\var{bnf}, \var{modulus}]},
or \kbd{[\var{bnf}, \var{modulus},\var{subgroup}]},
\secref{se:CFT}); this function returns the relative degree $[L:K]$.

In particular if $A$ is a \var{bnf} (with units), and $B$ a modulus,
this function returns the corresponding ray class number modulo $B$.
One can input the associated \var{bid} (with generators if the subgroup
$C$ is non trivial) for $B$ instead of the module itself, saving some time.

This function is faster than \kbd{bnrinit} and should be used if only the
ray class number is desired. See \tet{bnrclassnolist} if you need ray class
numbers for all moduli less than some bound.

The library syntax is \fun{GEN}{bnrclassno0}{GEN A, GEN B = NULL, GEN C = NULL}.
Also available is
\fun{GEN}{bnrclassno}{GEN bnf,GEN f} to compute the ray class number
modulo~$f$.

\subsec{bnrclassnolist$(\var{bnf},\var{list})$}\kbdsidx{bnrclassnolist}\label{se:bnrclassnolist}
$\var{bnf}$ being as
output by \kbd{bnfinit}, and \var{list} being a list of moduli (with units) as
output by \kbd{ideallist} or \kbd{ideallistarch}, outputs the list of the
class numbers of the corresponding ray class groups. To compute a single
class number, \tet{bnrclassno} is more efficient.

\bprog
? bnf = bnfinit(x^2 - 2);
? L = ideallist(bnf, 100, 2);
? H = bnrclassnolist(bnf, L);
? H[98]
%4 = [1, 3, 1]
? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
%5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
@eprog
The weird \kbd{l[i].mod[1]}, is the first component of \kbd{l[i].mod}, i.e.
the finite part of the conductor. (This is cosmetic: since by construction
the Archimedean part is trivial, I do not want to see it). This tells us that
the ray class groups modulo the ideals of norm 98 (printed as \kbd{\%5}) have
respectively order $1$, $3$ and $1$. Indeed, we may check directly:
\bprog
? bnrclassno(bnf, ids[2])
%6 = 3
@eprog

The library syntax is \fun{GEN}{bnrclassnolist}{GEN bnf, GEN list}.

\subsec{bnrconductor$(A,\{B\},\{C\},\{\fl=0\})$}\kbdsidx{bnrconductor}\label{se:bnrconductor}
Conductor $f$ of the subfield of a ray class field as defined by $[A,B,C]$
(of type \kbd{[\var{bnr}]},
\kbd{[\var{bnr}, \var{subgroup}]},
\kbd{[\var{bnf}, \var{modulus}]} or
\kbd{[\var{bnf}, \var{modulus}, \var{subgroup}]},
\secref{se:CFT})

If $\fl = 0$, returns $f$.

If $\fl = 1$, returns $[f, Cl_f, H]$, where $Cl_f$ is the ray class group
modulo $f$, as a finite abelian group; finally $H$ is the subgroup of $Cl_f$
defining the extension.

If $\fl = 2$, returns $[f, \var{bnr}(f), H]$, as above except $Cl_f$ is
replaced by a \kbd{bnr} structure, as output by $\tet{bnrinit}(,f,1)$.

The library syntax is \fun{GEN}{bnrconductor0}{GEN A, GEN B = NULL, GEN C = NULL, long flag}.

Also available is \fun{GEN}{bnrconductor}{GEN bnr, GEN H, long flag}

\subsec{bnrconductorofchar$(\var{bnr},\var{chi})$}\kbdsidx{bnrconductorofchar}\label{se:bnrconductorofchar}
\var{bnr} being a big
ray number field as output by \kbd{bnrinit}, and \var{chi} being a row vector
representing a \idx{character} as expressed on the generators of the ray
class group, gives the conductor of this character as a modulus.

The library syntax is \fun{GEN}{bnrconductorofchar}{GEN bnr, GEN chi}.

\subsec{bnrdisc$(A,\{B\},\{C\},\{\fl=0\})$}\kbdsidx{bnrdisc}\label{se:bnrdisc}
$A$, $B$, $C$ defining a class field $L$ over a ground field $K$
(of type \kbd{[\var{bnr}]},
\kbd{[\var{bnr}, \var{subgroup}]},
\kbd{[\var{bnf}, \var{modulus}]} or
\kbd{[\var{bnf}, \var{modulus}, \var{subgroup}]},
\secref{se:CFT}), outputs data $[N,r_1,D]$ giving the discriminant and
signature of $L$, depending on the binary digits of \fl:

\item 1: if this bit is unset, output absolute data related to $L/\Q$:
$N$ is the absolute degree $[L:\Q]$, $r_1$ the number of real places of $L$,
and $D$ the discriminant of $L/\Q$. Otherwise, output relative data for $L/K$:
$N$ is the relative degree $[L:K]$, $r_1$ is the number of real places of $K$
unramified in $L$ (so that the number of real places of $L$ is equal to $r_1$
times $N$), and $D$ is the relative discriminant ideal of $L/K$.

\item 2: if this bit is set and if the modulus is not the conductor of $L$,
only return 0.

The library syntax is \fun{GEN}{bnrdisc0}{GEN A, GEN B = NULL, GEN C = NULL, long flag}.

\subsec{bnrdisclist$(\var{bnf},\var{bound},\{\var{arch}\})$}\kbdsidx{bnrdisclist}\label{se:bnrdisclist}
$\var{bnf}$ being as output by \kbd{bnfinit} (with units), computes a
list of discriminants of Abelian extensions of the number field by increasing
modulus norm up to bound \var{bound}. The ramified Archimedean places are
given by \var{arch}; all possible values are taken if \var{arch} is omitted.

The alternative syntax $\kbd{bnrdisclist}(\var{bnf},\var{list})$ is
supported, where \var{list} is as output by \kbd{ideallist} or
\kbd{ideallistarch} (with units), in which case \var{arch} is disregarded.

The output $v$ is a vector of vectors, where $v[i][j]$ is understood to be in
fact $V[2^{15}(i-1)+j]$ of a unique big vector $V$. (This awkward scheme
allows for larger vectors than could be otherwise represented.)

$V[k]$ is itself a vector $W$, whose length is the number of ideals of norm
$k$. We consider first the case where \var{arch} was specified. Each
component of $W$ corresponds to an ideal $m$ of norm $k$, and
gives invariants associated to the ray class field $L$ of $\var{bnf}$ of
conductor $[m, \var{arch}]$. Namely, each contains a vector $[m,d,r,D]$ with
the following meaning: $m$ is the prime ideal factorization of the modulus,
$d = [L:\Q]$ is the absolute degree of $L$, $r$ is the number of real places
of $L$, and $D$ is the factorization of its absolute discriminant. We set $d
= r = D = 0$ if $m$ is not the finite part of a conductor.

If \var{arch} was omitted, all $t = 2^{r_1}$ possible values are taken and a
component of $W$ has the form $[m, [[d_1,r_1,D_1], \dots, [d_t,r_t,D_t]]]$,
where $m$ is the finite part of the conductor as above, and
$[d_i,r_i,D_i]$ are the invariants of the ray class field of conductor
$[m,v_i]$, where $v_i$ is the $i$-th Archimedean component, ordered by
inverse lexicographic order; so $v_1 = [0,\dots,0]$, $v_2 = [1,0\dots,0]$,
etc. Again, we set $d_i = r_i = D_i = 0$ if $[m,v_i]$ is not a conductor.

Finally, each prime ideal $pr = [p,\alpha,e,f,\beta]$ in the prime
factorization $m$ is coded as the integer $p\cdot n^2+(f-1)\cdot n+(j-1)$,
where $n$ is the degree of the base field and $j$ is such that

\kbd{pr = idealprimedec(\var{nf},p)[j]}.

\noindent $m$ can be decoded using \tet{bnfdecodemodule}.

Note that to compute such data for a single field, either \tet{bnrclassno}
or \tet{bnrdisc} is more efficient.

The library syntax is \fun{GEN}{bnrdisclist0}{GEN bnf, GEN bound, GEN arch = NULL}.

\subsec{bnrinit$(\var{bnf},f,\{\fl=0\})$}\kbdsidx{bnrinit}\label{se:bnrinit}
$\var{bnf}$ is as
output by \kbd{bnfinit}, $f$ is a modulus, initializes data linked to
the ray class group structure corresponding to this module, a so-called
\var{bnr} structure. One can input the associated \var{bid} with generators
for $f$ instead of the module itself, saving some time.
(As in \tet{idealstar}, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by \tet{idealfactor}.)

The following member functions are available
on the result: \kbd{.bnf} is the underlying \var{bnf},
\kbd{.mod} the modulus, \kbd{.bid} the \var{bid} structure associated to the
modulus; finally, \kbd{.clgp}, \kbd{.no}, \kbd{.cyc}, \kbd{.gen} refer to the
ray class group (as a finite abelian group), its cardinality, its elementary
divisors, its generators (only computed if $\fl = 1$).

The last group of functions are different from the members of the underlying
\var{bnf}, which refer to the class group; use \kbd{\var{bnr}.bnf.\var{xxx}}
to access these, e.g.~\kbd{\var{bnr}.bnf.cyc} to get the cyclic decomposition
of the class group.

They are also different from the members of the underlying \var{bid}, which
refer to $(\Z_K/f)^*$; use \kbd{\var{bnr}.bid.\var{xxx}} to access these,
e.g.~\kbd{\var{bnr}.bid.no} to get $\phi(f)$.

If $\fl=0$ (default), the generators of the ray class group are not computed,
which saves time. Hence \kbd{\var{bnr}.gen} would produce an error.

If $\fl=1$, as the default, except that generators are computed.

The library syntax is \fun{GEN}{bnrinit0}{GEN bnf, GEN f, long flag}.
Instead the above  hardcoded  numerical flags,  one should rather use
\fun{GEN}{Buchray}{GEN bnf, GEN module, long flag}
where flag is an or-ed combination of \kbd{nf\_GEN} (include generators)
and \kbd{nf\_INIT} (if omitted, return just the cardinal of the ray class group
and its structure), possibly 0.

\subsec{bnrisconductor$(A,\{B\},\{C\})$}\kbdsidx{bnrisconductor}\label{se:bnrisconductor}
$A$, $B$, $C$ represent
an extension of the base field, given by class field theory
(see~\secref{se:CFT}). Outputs 1 if this modulus is the conductor, and 0
otherwise. This is slightly faster than \kbd{bnrconductor}.

The library syntax is \fun{long}{bnrisconductor0}{GEN A, GEN B = NULL, GEN C = NULL}.

\subsec{bnrisprincipal$(\var{bnr},x,\{\fl=1\})$}\kbdsidx{bnrisprincipal}\label{se:bnrisprincipal}
\var{bnr} being the
number field data which is output by \kbd{bnrinit}$(,,1)$ and $x$ being an
ideal in any form, outputs the components of $x$ on the ray class group
generators in a way similar to \kbd{bnfisprincipal}. That is a 2-component
vector $v$ where $v[1]$ is the vector of components of $x$ on the ray class
group generators, $v[2]$ gives on the integral basis an element $\alpha$ such
that $x=\alpha\prod_ig_i^{x_i}$.

If $\fl=0$, outputs only $v_1$. In that case, \var{bnr} need not contain the
ray class group generators, i.e.~it may be created with \kbd{bnrinit}$(,,0)$
If $x$ is not coprime to the modulus of \var{bnr} the result is undefined.

The library syntax is \fun{GEN}{bnrisprincipal}{GEN bnr, GEN x, long flag}.
Instead of hardcoded  numerical flags,  one should rather
use
\fun{GEN}{isprincipalray}{GEN bnr, GEN x} for $\kbd{flag} = 0$, and if you
want generators:
\bprog
  bnrisprincipal(bnr, x, nf_GEN)
@eprog

\subsec{bnrrootnumber$(\var{bnr},\var{chi},\{\fl=0\})$}\kbdsidx{bnrrootnumber}\label{se:bnrrootnumber}
If $\chi=\var{chi}$ is a
\idx{character} over \var{bnr}, not necessarily primitive, let
$L(s,\chi) = \sum_{id} \chi(id) N(id)^{-s}$ be the associated
\idx{Artin L-function}. Returns the so-called \idx{Artin root number}, i.e.~the
complex number $W(\chi)$ of modulus 1 such that
%
$$\Lambda(1-s,\chi) = W(\chi) \Lambda(s,\overline{\chi})$$
%
\noindent where $\Lambda(s,\chi) = A(\chi)^{s/2}\gamma_\chi(s) L(s,\chi)$ is
the enlarged L-function associated to $L$.

The generators of the ray class group are needed, and you can set $\fl=1$ if
the character is known to be primitive. Example:

\bprog
bnf = bnfinit(x^2 - x - 57);
bnr = bnrinit(bnf, [7,[1,1]], 1);
bnrrootnumber(bnr, [2,1])
@eprog\noindent
returns the root number of the character $\chi$ of
$\Cl_{7\infty_1\infty_2}(\Q(\sqrt{229}))$ defined by $\chi(g_1^ag_2^b)
= \zeta_1^{2a}\zeta_2^b$. Here $g_1, g_2$ are the generators of the
ray-class group given by \kbd{bnr.gen} and $\zeta_1 = e^{2i\pi/N_1},
\zeta_2 = e^{2i\pi/N_2}$ where $N_1, N_2$ are the orders of $g_1$ and
$g_2$ respectively ($N_1=6$ and $N_2=3$ as \kbd{bnr.cyc} readily tells us).

The library syntax is \fun{GEN}{bnrrootnumber}{GEN bnr, GEN chi, long flag, long prec}.

\subsec{bnrstark$(\var{bnr},\{\var{subgroup}\})$}\kbdsidx{bnrstark}\label{se:bnrstark}
\var{bnr} being as output by \kbd{bnrinit(,,1)}, finds a relative equation
for the class field corresponding to the modulus in \var{bnr} and the given
congruence subgroup (as usual, omit $\var{subgroup}$ if you want the whole ray
class group).

The main variable of \var{bnr} must not be $x$, and the ground field and the
class field must be totally real. When the base field is $\Q$, the vastly
simpler \tet{galoissubcyclo} is used instead. Here is an example:
\bprog
bnf = bnfinit(y^2 - 3);
bnr = bnrinit(bnf, 5, 1);
bnrstark(bnr)
@eprog\noindent
returns the ray class field of $\Q(\sqrt{3})$ modulo $5$. Usually, one wants
to apply to the result one of
\bprog
rnfpolredabs(bnf, pol, 16)     \\@com compute a reduced relative polynomial
rnfpolredabs(bnf, pol, 16 + 2) \\@com compute a reduced absolute polynomial
@eprog

The routine uses \idx{Stark units} and needs to find a suitable auxiliary
conductor, which may not exist when the class field is not cyclic over the
base. In this case \kbd{bnrstark} is allowed to return a vector of
polynomials defining \emph{independent} relative extensions, whose compositum
is the requested class field. It was decided that it was more useful
to keep the extra information thus made available, hence the user has to take
the compositum herself.

Even if it exists, the auxiliary conductor may be so large that later
computations become unfeasible. (And of course, Stark's conjecture may simply
be wrong.) In case of difficulties, try \tet{rnfkummer}:
\bprog
? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2, 1);
? bnrstark(bnr)
  ***   at top-level: bnrstark(bnr)
  ***                 ^-------------
  *** bnrstark: need 3919350809720744 coefficients in initzeta.
  *** Computation impossible.
? lift( rnfkummer(bnr) )
time = 24 ms.
%2 = x^2 + (1/3*y^6 - 11/3*y^4 + 8*y^2 - 5)
@eprog

The library syntax is \fun{GEN}{bnrstark}{GEN bnr, GEN subgroup = NULL, long prec}.

\subsec{dirzetak$(\var{nf},b)$}\kbdsidx{dirzetak}\label{se:dirzetak}
Gives as a vector the first $b$
coefficients of the \idx{Dedekind} zeta function of the number field $\var{nf}$
considered as a \idx{Dirichlet series}.

The library syntax is \fun{GEN}{dirzetak}{GEN nf, GEN b}.

\subsec{factornf$(x,t)$}\kbdsidx{factornf}\label{se:factornf}
Factorization of the univariate polynomial $x$
over the number field defined by the (univariate) polynomial $t$. $x$ may
have coefficients in $\Q$ or in the number field. The algorithm reduces to
factorization over $\Q$ (\idx{Trager}'s trick). The direct approach of
\tet{nffactor}, which uses \idx{van Hoeij}'s method in a relative setting, is
in general faster.

The main variable of $t$ must be of \emph{lower} priority than that of $x$
(see \secref{se:priority}). However if non-rational number field elements
occur (as polmods or polynomials) as coefficients of $x$, the variable of
these polmods \emph{must} be the same as the main variable of $t$. For
example

\bprog
? factornf(x^2 + Mod(y, y^2+1), y^2+1);
? factornf(x^2 + y, y^2+1); \\@com these two are OK
? factornf(x^2 + Mod(z,z^2+1), y^2+1)
  ***   at top-level: factornf(x^2+Mod(z,z
  ***                 ^--------------------
  *** factornf: inconsistent data in rnf function.
? factornf(x^2 + z, y^2+1)
  ***   at top-level: factornf(x^2+z,y^2+1
  ***                 ^--------------------
  *** factornf: incorrect variable in rnf function.
@eprog

The library syntax is \fun{GEN}{polfnf}{GEN x, GEN t}.

\subsec{galoisexport$(\var{gal},\{\fl\})$}\kbdsidx{galoisexport}\label{se:galoisexport}
\var{gal} being be a Galois group as output by \tet{galoisinit},
export the underlying permutation group as a string suitable
for (no flags or $\fl=0$) GAP or ($\fl=1$) Magma. The following example
compute the index of the underlying abstract group in the GAP library:
\bprog
? G = galoisinit(x^6+108);
? s = galoisexport(G)
%2 = "Group((1, 2, 3)(4, 5, 6), (1, 4)(2, 6)(3, 5))"
? extern("echo \"IdGroup("s");\" | gap -q")
%3 = [6, 1]
? galoisidentify(G)
%4 = [6, 1]
@eprog\noindent
This command also accepts subgroups returned by \kbd{galoissubgroups}.

To \emph{import} a GAP permutation into gp (for \tet{galoissubfields} for
instance), the following GAP function may be useful:
\bprog
PermToGP := function(p, n)
  return Permuted([1..n],p);
end;

gap> p:= (1,26)(2,5)(3,17)(4,32)(6,9)(7,11)(8,24)(10,13)(12,15)(14,27)
  (16,22)(18,28)(19,20)(21,29)(23,31)(25,30)
gap> PermToGP(p,32);
[ 26, 5, 17, 32, 2, 9, 11, 24, 6, 13, 7, 15, 10, 27, 12, 22, 3, 28, 20, 19,
  29, 16, 31, 8, 30, 1, 14, 18, 21, 25, 23, 4 ]
@eprog

The library syntax is \fun{GEN}{galoisexport}{GEN gal, long flag}.

\subsec{galoisfixedfield$(\var{gal},\var{perm},\{\fl\},\{v=y\})$}\kbdsidx{galoisfixedfield}\label{se:galoisfixedfield}
\var{gal} being be a Galois group as output by \tet{galoisinit} and
\var{perm} an element of $\var{gal}.group$, a vector of such elements
or a subgroup of \var{gal} as returned by galoissubgroups,
computes the fixed field of \var{gal} by the automorphism defined by the
permutations \var{perm} of the roots $\var{gal}.roots$. $P$ is guaranteed to
be squarefree modulo $\var{gal}.p$.

If no flags or $\fl=0$, output format is the same as for \tet{nfsubfield},
returning $[P,x]$ such that $P$ is a polynomial defining the fixed field, and
$x$ is a root of $P$ expressed as a polmod in $\var{gal}.pol$.

If $\fl=1$ return only the polynomial $P$.

If $\fl=2$ return $[P,x,F]$ where $P$ and $x$ are as above and $F$ is the
factorization of $\var{gal}.pol$ over the field defined by $P$, where
variable $v$ ($y$ by default) stands for a root of $P$. The priority of $v$
must be less than the priority of the variable of $\var{gal}.pol$ (see
\secref{se:priority}). Example:

\bprog
? G = galoisinit(x^4+1);
? galoisfixedfield(G,G.group[2],2)
%2 = [x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - y*x - 1, x^2 + y*x - 1]]
@eprog\noindent
computes the factorization  $x^4+1=(x^2-\sqrt{-2}x-1)(x^2+\sqrt{-2}x-1)$

The library syntax is \fun{GEN}{galoisfixedfield}{GEN gal, GEN perm, long flag, long v = -1}, where \kbd{v} is a variable number.

\subsec{galoisgetpol$(a,\{b\},\{s\})$}\kbdsidx{galoisgetpol}\label{se:galoisgetpol}
Query the galpol package for a polynomial with Galois group isomorphic to
GAP4(a,b), totally real if $s=1$ (default) and totally complex if $s=2$. The
output is a vector [\kbd{pol}, \kbd{den}] where

\item  \kbd{pol} is the polynomial of degree $a$

\item \kbd{den} is the denominator of \kbd{nfgaloisconj(pol)}.
Pass it as an optional argument to \tet{galoisinit} or \tet{nfgaloisconj} to
speed them up:
\bprog
? [pol,den] = galoisgetpol(64,4,1);
? G = galoisinit(pol);
time = 352ms
? galoisinit(pol, den);  \\ passing 'den' speeds up the computation
time = 264ms
? % == %`
%4 = 1  \\ same answer
@eprog
If $b$ and $s$ are omitted, return the number of isomorphism classes of
groups of order $a$.

The library syntax is \fun{GEN}{galoisgetpol}{long a, long b, long s}.
Also available is \fun{GEN}{galoisnbpol}{long a} when $b$ and $s$
are omitted.

\subsec{galoisidentify$(\var{gal})$}\kbdsidx{galoisidentify}\label{se:galoisidentify}
\var{gal} being be a Galois group as output by \tet{galoisinit},
output the isomorphism class of the underlying abstract group as a
two-components vector $[o,i]$, where $o$ is the group order, and $i$ is the
group index in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina
Eick and Eamonn O'Brien.

This command also accepts subgroups returned by \kbd{galoissubgroups}.

The current implementation is limited to degree less or equal to $127$.
Some larger ``easy'' orders are also supported.

The output is similar to the output of the function \kbd{IdGroup} in GAP4.
Note that GAP4 \kbd{IdGroup} handles all groups of order less than $2000$
except $1024$, so you can use \tet{galoisexport} and GAP4 to identify large
Galois groups.

The library syntax is \fun{GEN}{galoisidentify}{GEN gal}.

\subsec{galoisinit$(\var{pol},\{\var{den}\})$}\kbdsidx{galoisinit}\label{se:galoisinit}
Computes the Galois group
and all necessary information for computing the fixed fields of the
Galois extension $K/\Q$ where $K$ is the number field defined by
$\var{pol}$ (monic irreducible polynomial in $\Z[X]$ or
a number field as output by \tet{nfinit}). The extension $K/\Q$ must be
Galois with Galois group ``weakly'' super-solvable, see below;
returns 0 otherwise. Hence this permits to quickly check whether a polynomial
of order strictly less than $36$ is Galois or not.

The algorithm used is an improved version of the paper
``An efficient algorithm for the computation of Galois automorphisms'',
Bill Allombert, Math.~Comp, vol.~73, 245, 2001, pp.~359--375.

A group $G$ is said to be ``weakly'' super-solvable if there exists a
normal series

$\{1\} = H_0 \triangleleft H_1 \triangleleft \cdots \triangleleft H_{n-1}
\triangleleft H_n$

such that each $H_i$ is normal in $G$ and for $i<n$, each quotient group
$H_{i+1}/H_i$ is cyclic, and either $H_n=G$ (then $G$ is super-solvable) or
$G/H_n$ is isomorphic to either $A_4$ or $S_4$.

In practice, almost all small groups are WKSS, the exceptions having order
36(1 exception), 48(2), 56(1), 60(1), 72(5), 75(1), 80(1), 96(10) and $\geq
108$.

This function is a prerequisite for most of the \kbd{galois}$xxx$ routines.
For instance:

\bprog
P = x^6 + 108;
G = galoisinit(P);
L = galoissubgroups(G);
vector(#L, i, galoisisabelian(L[i],1))
vector(#L, i, galoisidentify(L[i]))
@eprog

The output is an 8-component vector \var{gal}.

$\var{gal}[1]$ contains the polynomial \var{pol}
(\kbd{\var{gal}.pol}).

$\var{gal}[2]$ is a three-components vector $[p,e,q]$ where $p$ is a
prime number (\kbd{\var{gal}.p}) such that \var{pol} totally split
modulo $p$ , $e$ is an integer and $q=p^e$ (\kbd{\var{gal}.mod}) is the
modulus of the roots in \kbd{\var{gal}.roots}.

$\var{gal}[3]$ is a vector $L$ containing the $p$-adic roots of
\var{pol} as integers implicitly modulo \kbd{\var{gal}.mod}.
(\kbd{\var{gal}.roots}).

$\var{gal}[4]$ is the inverse of the Vandermonde matrix of the
$p$-adic roots of \var{pol}, multiplied by $\var{gal}[5]$.

$\var{gal}[5]$ is a multiple of the least common denominator of the
automorphisms expressed as polynomial in a root of \var{pol}.

$\var{gal}[6]$ is the Galois group $G$ expressed as a vector of
permutations of $L$ (\kbd{\var{gal}.group}).

$\var{gal}[7]$ is a generating subset $S=[s_1,\ldots,s_g]$ of $G$
expressed as a vector of permutations of $L$ (\kbd{\var{gal}.gen}).

$\var{gal}[8]$ contains the relative orders $[o_1,\ldots,o_g]$ of
the generators of $S$ (\kbd{\var{gal}.orders}).

Let $H_n$ be as above, we have the following properties:

\quad\item if $G/H_n\simeq A_4$ then $[o_1,\ldots,o_g]$ ends by
$[2,2,3]$.

\quad\item if $G/H_n\simeq S_4$ then $[o_1,\ldots,o_g]$ ends by
$[2,2,3,2]$.

\quad\item for $1\leq i \leq g$ the subgroup of $G$ generated by
$[s_1,\ldots,s_g]$ is normal, with the exception of $i=g-2$ in the
$A_4$ case and of $i=g-3$ in the $S_A$ case.

\quad\item the relative order $o_i$ of $s_i$ is its order in the
quotient group $G/\langle s_1,\ldots,s_{i-1}\rangle$, with the same
exceptions.

\quad\item for any $x\in G$ there exists a unique family
$[e_1,\ldots,e_g]$ such that (no exceptions):

-- for $1\leq i \leq g$ we have $0\leq e_i<o_i$

-- $x=g_1^{e_1}g_2^{e_2}\ldots g_n^{e_n}$

If present $den$ must be a suitable value for $\var{gal}[5]$.

The library syntax is \fun{GEN}{galoisinit}{GEN pol, GEN den = NULL}.

\subsec{galoisisabelian$(\var{gal},\{\fl=0\})$}\kbdsidx{galoisisabelian}\label{se:galoisisabelian}
\var{gal} being as output by \kbd{galoisinit}, return $0$ if
\var{gal} is not an abelian group, and the HNF matrix of \var{gal} over
\kbd{gal.gen} if $fl=0$, $1$ if $fl=1$.

This command also accepts subgroups returned by \kbd{galoissubgroups}.

The library syntax is \fun{GEN}{galoisisabelian}{GEN gal, long flag}.

\subsec{galoisisnormal$(\var{gal},\var{subgrp})$}\kbdsidx{galoisisnormal}\label{se:galoisisnormal}
\var{gal} being as output by \kbd{galoisinit}, and \var{subgrp} a subgroup
of \var{gal} as output by \kbd{galoissubgroups},return $1$ if \var{subgrp} is a
normal subgroup of \var{gal}, else return 0.

This command also accepts subgroups returned by \kbd{galoissubgroups}.

The library syntax is \fun{long}{galoisisnormal}{GEN gal, GEN subgrp}.

\subsec{galoispermtopol$(\var{gal},\var{perm})$}\kbdsidx{galoispermtopol}\label{se:galoispermtopol}
\var{gal} being a
Galois group as output by \kbd{galoisinit} and \var{perm} a element of
$\var{gal}.group$, return the polynomial defining the Galois
automorphism, as output by \kbd{nfgaloisconj}, associated with the
permutation \var{perm} of the roots $\var{gal}.roots$. \var{perm} can
also be a vector or matrix, in this case, \kbd{galoispermtopol} is
applied to all components recursively.

\noindent Note that
\bprog
G = galoisinit(pol);
galoispermtopol(G, G[6])~
@eprog\noindent
is equivalent to \kbd{nfgaloisconj(pol)}, if degree of \var{pol} is greater
or equal to $2$.

The library syntax is \fun{GEN}{galoispermtopol}{GEN gal, GEN perm}.

\subsec{galoissubcyclo$(N,H,\{\var{fl}=0\},\{v\})$}\kbdsidx{galoissubcyclo}\label{se:galoissubcyclo}
Computes the subextension
of $\Q(\zeta_n)$ fixed by the subgroup $H \subset (\Z/n\Z)^*$. By the
Kronecker-Weber theorem, all abelian number fields can be generated in this
way (uniquely if $n$ is taken to be minimal).

\noindent The pair $(n, H)$ is deduced from the parameters $(N, H)$ as follows

\item $N$ an integer: then $n = N$; $H$ is a generator, i.e. an
integer or an integer modulo $n$; or a vector of generators.

\item $N$ the output of \kbd{znstar($n$)}. $H$ as in the first case
above, or a matrix, taken to be a HNF left divisor of the SNF for $(\Z/n\Z)^*$
(of type \kbd{$N$.cyc}), giving the generators of $H$ in terms of \kbd{$N$.gen}.

\item $N$ the output of \kbd{bnrinit(bnfinit(y), $m$, 1)} where $m$ is a
module. $H$ as in the first case, or a matrix taken to be a HNF left
divisor of the SNF for the ray class group modulo $m$
(of type \kbd{$N$.cyc}), giving the generators of $H$ in terms of \kbd{$N$.gen}.

In this last case, beware that $H$ is understood relatively to $N$; in
particular, if the infinite place does not divide the module, e.g if $m$ is
an integer, then it is not a subgroup of $(\Z/n\Z)^*$, but of its quotient by
$\{\pm 1\}$.

If $fl=0$, compute a polynomial (in the variable \var{v}) defining the
the subfield of $\Q(\zeta_n)$ fixed by the subgroup \var{H} of $(\Z/n\Z)^*$.

If $fl=1$, compute only the conductor of the abelian extension, as a module.

If $fl=2$, output $[pol, N]$, where $pol$ is the polynomial as output when
$fl=0$ and $N$ the conductor as output when $fl=1$.

The following function can be used to compute all subfields of
$\Q(\zeta_n)$ (of exact degree \kbd{d}, if \kbd{d} is set):
\bprog
polsubcyclo(n, d = -1)=
{ my(bnr,L,IndexBound);
  IndexBound = if (d < 0, n, [d]);
  bnr = bnrinit(bnfinit(y), [n,[1]], 1);
  L = subgrouplist(bnr, IndexBound, 1);
  vector(#L,i, galoissubcyclo(bnr,L[i]));
}
@eprog\noindent
Setting \kbd{L = subgrouplist(bnr, IndexBound)} would produce subfields of exact
conductor $n\infty$.

The library syntax is \fun{GEN}{galoissubcyclo}{GEN N, GEN H = NULL, long fl, long v = -1}, where \kbd{v} is a variable number.

\subsec{galoissubfields$(G,\{\var{flags}=0\},\{v\})$}\kbdsidx{galoissubfields}\label{se:galoissubfields}
Outputs all the subfields of the Galois group \var{G}, as a vector.
This works by applying \kbd{galoisfixedfield} to all subgroups. The meaning of
the flag \var{fl} is the same as for \kbd{galoisfixedfield}.

The library syntax is \fun{GEN}{galoissubfields}{GEN G, long flags, long v = -1}, where \kbd{v} is a variable number.

\subsec{galoissubgroups$(G)$}\kbdsidx{galoissubgroups}\label{se:galoissubgroups}
Outputs all the subgroups of the Galois group \kbd{gal}. A subgroup is a
vector [\var{gen}, \var{orders}], with the same meaning
as for $\var{gal}.gen$ and $\var{gal}.orders$. Hence \var{gen} is a vector of
permutations generating the subgroup, and \var{orders} is the relatives
orders of the generators. The cardinal of a subgroup is the product of the
relative orders. Such subgroup can be used instead of a Galois group in the
following command: \kbd{galoisisabelian}, \kbd{galoissubgroups},
\kbd{galoisexport} and \kbd{galoisidentify}.

To get the subfield fixed by a subgroup \var{sub} of \var{gal}, use
\bprog
galoisfixedfield(gal,sub[1])
@eprog

The library syntax is \fun{GEN}{galoissubgroups}{GEN G}.

\subsec{idealadd$(\var{nf},x,y)$}\kbdsidx{idealadd}\label{se:idealadd}
Sum of the two ideals $x$ and $y$ in the number field $\var{nf}$. The
result is given in HNF.
\bprog
 ? K = nfinit(x^2 + 1);
 ? a = idealadd(K, 2, x + 1)  \\ ideal generated by 2 and 1+I
 %2 =
 [2 1]

 [0 1]
 ? pr = idealprimedec(K, 5)[1];  \\ a prime ideal above 5
 ? idealadd(K, a, pr)     \\ coprime, as expected
 %4 =
 [1 0]

 [0 1]
@eprog\noindent
This function cannot be used to add arbitrary $\Z$-modules, since it assumes
that its arguments are ideals:
\bprog
  ? b = Mat([1,0]~);
  ? idealadd(K, b, b)     \\ only square t_MATs represent ideals
  *** idealadd: non-square t_MAT in idealtyp.
  ? c = [2, 0; 2, 0]; idealadd(K, c, c)   \\ non-sense
  %6 =
  [2 0]

  [0 2]
  ? d = [1, 0; 0, 2]; idealadd(K, d, d)   \\ non-sense
  %7 =
  [1 0]

  [0 1]

@eprog\noindent In the last two examples, we get wrong results since the
matrices $c$ and $d$ do not correspond to an ideal: the $\Z$-span of their
columns (as usual interpreted as coordinates with respect to the integer basis
\kbd{K.zk}) is not an $O_K$-module. To add arbitrary $\Z$-modules generated
by the columns of matrices $A$ and $B$, use \kbd{mathnf(concat(A,B))}.

The library syntax is \fun{GEN}{idealadd}{GEN nf, GEN x, GEN y}.

\subsec{idealaddtoone$(\var{nf},x,\{y\})$}\kbdsidx{idealaddtoone}\label{se:idealaddtoone}
$x$ and $y$ being two co-prime
integral ideals (given in any form), this gives a two-component row vector
$[a,b]$ such that $a\in x$, $b\in y$ and $a+b=1$.

The alternative syntax $\kbd{idealaddtoone}(\var{nf},v)$, is supported, where
$v$ is a $k$-component vector of ideals (given in any form) which sum to
$\Z_K$. This outputs a $k$-component vector $e$ such that $e[i]\in x[i]$ for
$1\le i\le k$ and $\sum_{1\le i\le k}e[i]=1$.

The library syntax is \fun{GEN}{idealaddtoone0}{GEN nf, GEN x, GEN y = NULL}.

\subsec{idealappr$(\var{nf},x,\{\fl=0\})$}\kbdsidx{idealappr}\label{se:idealappr}
If $x$ is a fractional ideal
(given in any form), gives an element $\alpha$ in $\var{nf}$ such that for
all prime ideals $\goth{p}$ such that the valuation of $x$ at $\goth{p}$ is
non-zero, we have $v_{\goth{p}}(\alpha)=v_{\goth{p}}(x)$, and
$v_{\goth{p}}(\alpha)\ge0$ for all other $\goth{p}$.

If $\fl$ is non-zero, $x$ must be given as a prime ideal factorization, as
output by \kbd{idealfactor}, but possibly with zero or negative exponents.
This yields an element $\alpha$ such that for all prime ideals $\goth{p}$
occurring in $x$, $v_{\goth{p}}(\alpha)$ is equal to the exponent of
$\goth{p}$ in $x$, and for all other prime ideals,
$v_{\goth{p}}(\alpha)\ge0$. This generalizes $\kbd{idealappr}(\var{nf},x,0)$
since zero exponents are allowed. Note that the algorithm used is slightly
different, so that
\bprog
  idealappr(nf, idealfactor(nf,x))
@eprog\noindent
may not be the same as \kbd{idealappr(nf,x,1)}.

The library syntax is \fun{GEN}{idealappr0}{GEN nf, GEN x, long flag}.

\subsec{idealchinese$(\var{nf},x,y)$}\kbdsidx{idealchinese}\label{se:idealchinese}
$x$ being a prime ideal factorization
(i.e.~a 2 by 2 matrix whose first column contains prime ideals, and the second
column integral exponents), $y$ a vector of elements in $\var{nf}$ indexed by
the ideals in $x$, computes an element $b$ such that

$v_{\goth{p}}(b - y_{\goth{p}}) \geq v_{\goth{p}}(x)$ for all prime ideals
in $x$ and $v_{\goth{p}}(b)\geq 0$ for all other $\goth{p}$.

The library syntax is \fun{GEN}{idealchinese}{GEN nf, GEN x, GEN y}.

\subsec{idealcoprime$(\var{nf},x,y)$}\kbdsidx{idealcoprime}\label{se:idealcoprime}
Given two integral ideals $x$ and $y$
in the number field $\var{nf}$, returns a $\beta$ in the field,
such that $\beta\cdot x$ is an integral ideal coprime to $y$.

The library syntax is \fun{GEN}{idealcoprime}{GEN nf, GEN x, GEN y}.

\subsec{idealdiv$(\var{nf},x,y,\{\fl=0\})$}\kbdsidx{idealdiv}\label{se:idealdiv}
Quotient $x\cdot y^{-1}$ of the two ideals $x$ and $y$ in the number
field $\var{nf}$. The result is given in HNF.

If $\fl$ is non-zero, the quotient $x \cdot y^{-1}$ is assumed to be an
integral ideal. This can be much faster when the norm of the quotient is
small even though the norms of $x$ and $y$ are large.

The library syntax is \fun{GEN}{idealdiv0}{GEN nf, GEN x, GEN y, long flag}.
Also available are \fun{GEN}{idealdiv}{GEN nf, GEN x, GEN y}
($\fl=0$) and \fun{GEN}{idealdivexact}{GEN nf, GEN x, GEN y} ($\fl=1$).

\subsec{idealfactor$(\var{nf},x)$}\kbdsidx{idealfactor}\label{se:idealfactor}
Factors into prime ideal powers the
ideal $x$ in the number field $\var{nf}$. The output format is similar to the
\kbd{factor} function, and the prime ideals are represented in the form
output by the \kbd{idealprimedec} function, i.e.~as 5-element vectors.

The library syntax is \fun{GEN}{idealfactor}{GEN nf, GEN x}.

\subsec{idealfactorback$(\var{nf},f,\{e\},\{\fl = 0\})$}\kbdsidx{idealfactorback}\label{se:idealfactorback}
Gives back the ideal corresponding to a factorization. The integer $1$
corresponds to the empty factorization.
If $e$ is present, $e$ and $f$ must be vectors of the same length ($e$ being
integral), and the corresponding factorization is the product of the
$f[i]^{e[i]}$.

If not, and $f$ is vector, it is understood as in the preceding case with $e$
a vector of 1s: we return the product of the $f[i]$. Finally, $f$ can be a
regular factorization, as produced by \kbd{idealfactor}.
\bprog
? nf = nfinit(y^2+1); idealfactor(nf, 4 + 2*y)
%1 =
[[2, [1, 1]~, 2, 1, [1, 1]~] 2]

[[5, [2, 1]~, 1, 1, [-2, 1]~] 1]

? idealfactorback(nf, %)
%2 =
[10 4]

[0  2]

? f = %1[,1]; e = %1[,2]; idealfactorback(nf, f, e)
%3 =
[10 4]

[0  2]

? % == idealhnf(nf, 4 + 2*y)
%4 = 1
@eprog
If \kbd{flag} is non-zero, perform ideal reductions (\tet{idealred}) along the
way. This is most useful if the ideals involved are all \emph{extended}
ideals (for instance with trivial principal part), so that the principal parts
extracted by \kbd{idealred} are not lost. Here is an example:
\bprog
? f = vector(#f, i, [f[i], [;]]);  \\ transform to extended ideals
? idealfactorback(nf, f, e, 1)
%6 = [[1, 0; 0, 1], [2, 1; [2, 1]~, 1]]
? nffactorback(nf, %[2])
%7 = [4, 2]~
@eprog
The extended ideal returned in \kbd{\%6} is the trivial ideal $1$, extended
with a principal generator given in factored form. We use \tet{nffactorback}
to recover it in standard form.

The library syntax is \fun{GEN}{idealfactorback}{GEN nf, GEN f, GEN e = NULL, long flag }.

\subsec{idealfrobenius$(\var{nf},\var{gal},\var{pr})$}\kbdsidx{idealfrobenius}\label{se:idealfrobenius}
Let $K$ be the number field defined by $nf$ and assume $K/\Q$ be a
Galois extension with Galois group given \kbd{gal=galoisinit(nf)},
and that $pr$ is the prime ideal $\goth{P}$ in prid format, and that
$\goth{P}$ is unramified.
This function returns a permutation of \kbd{gal.group} which defines the
automorphism $\sigma=\left(\goth{P}\over K/\Q \right)$, i.e the Frobenius
element associated to $\goth{P}$. If $p$ is the unique prime number
in $\goth{P}$, then $\sigma(x)\equiv x^p\mod\P$ for all $x\in\Z_K$.
\bprog
? nf = nfinit(polcyclo(31));
? gal = galoisinit(nf);
? pr = idealprimedec(nf,101)[1];
? g = idealfrobenius(nf,gal,pr);
? galoispermtopol(gal,g)
%5 = x^8
@eprog\noindent This is correct since $101\equiv 8\mod{31}$.

The library syntax is \fun{GEN}{idealfrobenius}{GEN nf, GEN gal, GEN pr}.

\subsec{idealhnf$(\var{nf},u,\{v\})$}\kbdsidx{idealhnf}\label{se:idealhnf}
Gives the \idx{Hermite normal form} of the ideal $u\Z_K+v\Z_K$, where $u$
and $v$ are elements of the number field $K$ defined by \kbd{nf}.
\bprog
? nf = nfinit(y^3 - 2);
? idealhnf(nf, 2, y+1)
%2 =
[1 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, y/2, [0,0,1/3]~)
%3 =
[1/3 0 0]

[0 1/6 0]

[0 0 1/6]
@eprog

If $b$ is omitted, returns the HNF of the ideal defined by $u$: $u$ may be an
algebraic number (defining a principal ideal), a maximal ideal (as given by
\kbd{idealprimedec} or \kbd{idealfactor}), or a matrix whose columns give
generators for the ideal. This last format is a little complicated, but
useful to reduce general modules to the canonical form once in a while:

\item if strictly less than $N = [K:\Q]$ generators are given, $u$
is the $\Z_K$-module they generate,

\item if $N$ or more are given, it is \emph{assumed} that they form a
$\Z$-basis of the ideal, in particular that the matrix has maximal rank $N$.
This acts as \kbd{mathnf} since the $\Z_K$-module structure is (taken for
granted hence) not taken into account in this case.
\bprog
? idealhnf(nf, idealprimedec(nf,2)[1])
%4 =
[2 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, [1,2;2,3;3,4])
%5 =
[1 0 0]

[0 1 0]

[0 0 1]
@eprog\noindent Finally, when $K$ is quadratic with discriminant $D_K$, we
allow $u =$ \kbd{Qfb(a,b,c)}, provided $b^2 - 4ac = D_K$. As usual,
this represents the ideal $a \Z + (1/2)(-b + \sqrt{D_K}) \Z$.
\bprog
? K = nfinit(x^2 - 60); K.disc
%1 = 60
? idealhnf(K, qfbprimeform(60,2))
%2 =
[2 1]

[0 1]
? idealhnf(K, Qfb(1,2,3))
  ***   at top-level: idealhnf(K,Qfb(1,2,3
  ***                 ^--------------------
  *** idealhnf: Qfb(1, 2, 3) has discriminant != 60 in idealhnf.
@eprog

The library syntax is \fun{GEN}{idealhnf0}{GEN nf, GEN u, GEN v = NULL}.
Also available is \fun{GEN}{idealhnf}{GEN nf, GEN a}.

\subsec{idealintersect$(\var{nf},A,B)$}\kbdsidx{idealintersect}\label{se:idealintersect}
Intersection of the two ideals
$A$ and $B$ in the number field $\var{nf}$. The result is given in HNF.
\bprog
? nf = nfinit(x^2+1);
? idealintersect(nf, 2, x+1)
%2 =
[2 0]

[0 2]
@eprog

This function does not apply to general $\Z$-modules, e.g.~orders, since its
arguments are replaced by the ideals they generate. The following script
intersects $\Z$-modules $A$ and $B$ given by matrices of compatible
dimensions with integer coefficients:
\bprog
ZM_intersect(A,B) =
{ my(Ker = matkerint(concat(A,B)));
  mathnf( A * Ker[1..#A,] )
}
@eprog

The library syntax is \fun{GEN}{idealintersect}{GEN nf, GEN A, GEN B}.

\subsec{idealinv$(\var{nf},x)$}\kbdsidx{idealinv}\label{se:idealinv}
Inverse of the ideal $x$ in the
number field $\var{nf}$, given in HNF. If $x$ is an extended
ideal\sidx{ideal (extended)}, its principal part is suitably
updated: i.e. inverting $[I,t]$, yields $[I^{-1}, 1/t]$.

The library syntax is \fun{GEN}{idealinv}{GEN nf, GEN x}.

\subsec{ideallist$(\var{nf},\var{bound},\{\fl=4\})$}\kbdsidx{ideallist}\label{se:ideallist}
Computes the list
of all ideals of norm less or equal to \var{bound} in the number field
\var{nf}. The result is a row vector with exactly \var{bound} components.
Each component is itself a row vector containing the information about
ideals of a given norm, in no specific order, depending on the value of
$\fl$:

The possible values of $\fl$ are:

\quad 0: give the \var{bid} associated to the ideals, without generators.

\quad 1: as 0, but include the generators in the \var{bid}.

\quad 2: in this case, \var{nf} must be a \var{bnf} with units. Each
component is of the form $[\var{bid},U]$, where \var{bid} is as case 0
and $U$ is a vector of discrete logarithms of the units. More precisely, it
gives the \kbd{ideallog}s with respect to \var{bid} of \kbd{bnf.tufu}.
This structure is technical, and only meant to be used in conjunction with
\tet{bnrclassnolist} or \tet{bnrdisclist}.

\quad 3: as 2, but include the generators in the \var{bid}.

\quad 4: give only the HNF of the ideal.

\bprog
? nf = nfinit(x^2+1);
? L = ideallist(nf, 100);
? L[1]
%3 = [[1, 0; 0, 1]]  \\@com A single ideal of norm 1
? #L[65]
%4 = 4               \\@com There are 4 ideals of norm 4 in $\Z[i]$
@eprog
If one wants more information, one could do instead:
\bprog
? nf = nfinit(x^2+1);
? L = ideallist(nf, 100, 0);
? l = L[25]; vector(#l, i, l[i].clgp)
%3 = [[20, [20]], [16, [4, 4]], [20, [20]]]
? l[1].mod
%4 = [[25, 18; 0, 1], []]
? l[2].mod
%5 = [[5, 0; 0, 5], []]
? l[3].mod
%6 = [[25, 7; 0, 1], []]
@eprog\noindent where we ask for the structures of the $(\Z[i]/I)^*$ for all
three ideals of norm $25$. In fact, for all moduli with finite part of norm
$25$ and trivial Archimedean part, as the last 3 commands show. See
\tet{ideallistarch} to treat general moduli.

The library syntax is \fun{GEN}{ideallist0}{GEN nf, long bound, long flag}.

\subsec{ideallistarch$(\var{nf},\var{list},\var{arch})$}\kbdsidx{ideallistarch}\label{se:ideallistarch}
\var{list} is a vector of vectors of bid's, as output by \tet{ideallist} with
flag $0$ to $3$. Return a vector of vectors with the same number of
components as the original \var{list}. The leaves give information about
moduli whose finite part is as in original list, in the same order, and
Archimedean part is now \var{arch} (it was originally trivial). The
information contained is of the same kind as was present in the input; see
\tet{ideallist}, in particular the meaning of \fl.

\bprog
? bnf = bnfinit(x^2-2);
? bnf.sign
%2 = [2, 0]                         \\@com two places at infinity
? L = ideallist(bnf, 100, 0);
? l = L[98]; vector(#l, i, l[i].clgp)
%4 = [[42, [42]], [36, [6, 6]], [42, [42]]]
? La = ideallistarch(bnf, L, [1,1]); \\@com add them to the modulus
? l = La[98]; vector(#l, i, l[i].clgp)
%6 = [[168, [42, 2, 2]], [144, [6, 6, 2, 2]], [168, [42, 2, 2]]]
@eprog
Of course, the results above are obvious: adding $t$ places at infinity will
add $t$ copies of $\Z/2\Z$ to the ray class group. The following application
is more typical:
\bprog
? L = ideallist(bnf, 100, 2);        \\@com units are required now
? La = ideallistarch(bnf, L, [1,1]);
? H = bnrclassnolist(bnf, La);
? H[98];
%6 = [2, 12, 2]
@eprog

The library syntax is \fun{GEN}{ideallistarch}{GEN nf, GEN list, GEN arch}.

\subsec{ideallog$(\var{nf},x,\var{bid})$}\kbdsidx{ideallog}\label{se:ideallog}
$\var{nf}$ is a number field,
\var{bid} is as output by \kbd{idealstar(nf, D, \dots)} and $x$ a
non-necessarily integral element of \var{nf} which must have valuation
equal to 0 at all prime ideals in the support of $\kbd{D}$. This function
computes the discrete logarithm of $x$ on the generators given in
\kbd{\var{bid}.gen}. In other words, if $g_i$ are these generators, of orders
$d_i$ respectively, the result is a column vector of integers $(x_i)$ such
that $0\le x_i<d_i$ and
$$x \equiv \prod_i g_i^{x_i} \pmod{\ ^*D}\enspace.$$
Note that when the support of \kbd{D} contains places at infinity, this
congruence implies also sign conditions on the associated real embeddings.
See \tet{znlog} for the limitations of the underlying discrete log algorithms.

The library syntax is \fun{GEN}{ideallog}{GEN nf, GEN x, GEN bid}.

\subsec{idealmin$(\var{nf},\var{ix},\{\var{vdir}\})$}\kbdsidx{idealmin}\label{se:idealmin}
\emph{This function is useless and kept for backward compatibility only,
use \kbd{idealred}}. Computes a pseudo-minimum of the ideal $x$ in the
direction \var{vdir} in the number field \var{nf}.

The library syntax is \fun{GEN}{idealmin}{GEN nf, GEN ix, GEN vdir = NULL}.

\subsec{idealmul$(\var{nf},x,y,\{\fl=0\})$}\kbdsidx{idealmul}\label{se:idealmul}
Ideal multiplication of the ideals $x$ and $y$ in the number field
\var{nf}; the result is the ideal product in HNF. If either $x$ or $y$
are extended ideals\sidx{ideal (extended)}, their principal part is suitably
updated: i.e. multiplying $[I,t]$, $[J,u]$ yields $[IJ, tu]$; multiplying
$I$ and $[J, u]$ yields $[IJ, u]$.
\bprog
? nf = nfinit(x^2 + 1);
? idealmul(nf, 2, x+1)
%2 =
[4 2]

[0 2]
? idealmul(nf, [2, x], x+1)        \\ extended ideal * ideal
%4 = [[4, 2; 0, 2], x]
? idealmul(nf, [2, x], [x+1, x])   \\ two extended ideals
%5 = [[4, 2; 0, 2], [-1, 0]~]
@eprog\noindent
If $\fl$ is non-zero, reduce the result using \kbd{idealred}.

The library syntax is \fun{GEN}{idealmul0}{GEN nf, GEN x, GEN y, long flag}.

\noindent See also
\fun{GEN}{idealmul}{GEN nf, GEN x, GEN y} ($\fl=0$) and
\fun{GEN}{idealmulred}{GEN nf, GEN x, GEN y} ($\fl\neq0$).

\subsec{idealnorm$(\var{nf},x)$}\kbdsidx{idealnorm}\label{se:idealnorm}
Computes the norm of the ideal~$x$ in the number field~$\var{nf}$.

The library syntax is \fun{GEN}{idealnorm}{GEN nf, GEN x}.

\subsec{idealnumden$(\var{nf},x)$}\kbdsidx{idealnumden}\label{se:idealnumden}
Returns $[A,B]$, where $A,B$ are coprime integer ideals
such that $x = A/B$, in the number field $\var{nf}$.
\bprog
? nf = nfinit(x^2+1);
? idealnumden(nf, (x+1)/2)
%2 = [[1, 0; 0, 1], [2, 1; 0, 1]]
@eprog

The library syntax is \fun{GEN}{idealnumden}{GEN nf, GEN x}.

\subsec{idealpow$(\var{nf},x,k,\{\fl=0\})$}\kbdsidx{idealpow}\label{se:idealpow}
Computes the $k$-th power of
the ideal $x$ in the number field $\var{nf}$; $k\in\Z$.
If $x$ is an extended
ideal\sidx{ideal (extended)}, its principal part is suitably
updated: i.e. raising $[I,t]$ to the $k$-th power, yields $[I^k, t^k]$.

If $\fl$ is non-zero, reduce the result using \kbd{idealred}, \emph{throughout
the (binary) powering process}; in particular, this is \emph{not} the same as
as $\kbd{idealpow}(\var{nf},x,k)$ followed by reduction.

The library syntax is \fun{GEN}{idealpow0}{GEN nf, GEN x, GEN k, long flag}.

\noindent See also
\fun{GEN}{idealpow}{GEN nf, GEN x, GEN k} and
\fun{GEN}{idealpows}{GEN nf, GEN x, long k} ($\fl = 0$).
Corresponding to $\fl=1$ is \fun{GEN}{idealpowred}{GEN nf, GEN vp, GEN k}.

\subsec{idealprimedec$(\var{nf},p)$}\kbdsidx{idealprimedec}\label{se:idealprimedec}
Computes the prime ideal
decomposition of the (positive) prime number $p$ in the number field $K$
represented by \var{nf}. If a non-prime $p$ is given the result is undefined.

The result is a vector of \tev{prid} structures, each representing one of the
prime ideals above $p$ in the number field $\var{nf}$. The representation
$\kbd{pr}=[p,a,e,f,\var{mb}]$ of a prime ideal means the following: $a$ and
is an algebraic integer in the maximal order $\Z_K$ and the prime ideal is
equal to $\goth{p} = p\Z_K + a\Z_K$;
$e$ is the ramification index; $f$ is the residual index;
finally, \var{mb} is the multiplication table associated to the algebraic
integer $b$ is such that $\goth{p}^{-1}=\Z_K+ b/ p\Z_K$, which is used
internally to compute valuations. In other words if $p$ is inert,
then \var{mb} is the integer $1$, and otherwise it's a square \typ{MAT}
whose $j$-th column is $b \cdot \kbd{nf.zk[j]}$.

The algebraic number $a$ is guaranteed to have a
valuation equal to 1 at the prime ideal (this is automatic if $e>1$).

The components of \kbd{pr} should be accessed by member functions: \kbd{pr.p},
\kbd{pr.e}, \kbd{pr.f}, and \kbd{pr.gen} (returns the vector $[p,a]$):
\bprog
? K = nfinit(x^3-2);
? L = idealprimedec(K, 5);
? #L       \\ 2 primes above 5 in Q(2^(1/3))
%3 = 2
? p1 = L[1]; p2 = L[2];
? [p1.e, p1.f]    \\ the first is unramified of degree 1
%4 = [1, 1]
? [p2.e, p2.f]    \\ the second is unramified of degree 2
%5 = [1, 2]
? p1.gen
%6 = [5, [2, 1, 0]~]
? nfbasistoalg(K, %[2])  \\ a uniformizer for p1
%7 = Mod(x + 2, x^3 - 2)
@eprog

The library syntax is \fun{GEN}{idealprimedec}{GEN nf, GEN p}.

\subsec{idealprincipalunits$(\var{nf},\var{pr},k)$}\kbdsidx{idealprincipalunits}\label{se:idealprincipalunits}
Given a prime ideal in \tet{idealprimedec} format,
returns the multiplicative group $(1 + \var{pr}) / (1 + \var{pr}^k)$ as an
abelian group. This function is much faster than \tet{idealstar} when the
norm of \var{pr} is large, since it avoids (useless) work in the
multiplicative group of the residue field.
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K,2)[1];
? G = idealprincipalunits(K, P, 20);
? G.cyc
[512, 256, 4]   \\ Z/512 x Z/256 x Z/4
? G.gen
%5 = [[-1, -2]~, 1021, [0, -1]~] \\ minimal generators of given order
@eprog

The library syntax is \fun{GEN}{idealprincipalunits}{GEN nf, GEN pr, long k}.

\subsec{idealramgroups$(\var{nf},\var{gal},\var{pr})$}\kbdsidx{idealramgroups}\label{se:idealramgroups}
Let $K$ be the number field defined by \var{nf} and assume that $K/\Q$ is
Galois with Galois group $G$ given by \kbd{gal=galoisinit(nf)}.
Let \var{pr} be the prime ideal $\goth{P}$ in prid format.
This function returns a vector $g$ of subgroups of \kbd{gal}
as follow:

\item \kbd{g[1]} is the decomposition group of $\goth{P}$,

\item \kbd{g[2]} is $G_0(\goth{P})$, the inertia group of $\goth{P}$,

and for $i\geq 2$,

\item \kbd{g[i]} is $G_{i-2}(\goth{P})$, the $i-2$-th \idx{ramification
group} of $\goth{P}$.

\noindent The length of $g$ is the number of non-trivial groups in the
sequence, thus is $0$ if $e=1$ and $f=1$, and $1$ if $f>1$ and $e=1$.
The following function computes the cardinality of a subgroup of $G$,
as given by the components of $g$:
\bprog
card(H) =my(o=H[2]); prod(i=1,#o,o[i]);
@eprog
\bprog
? nf=nfinit(x^6+3); gal=galoisinit(nf); pr=idealprimedec(nf,3)[1];
? g = idealramgroups(nf, gal, pr);
? apply(card,g)
%4 = [6, 6, 3, 3, 3] \\ cardinalities of the G_i
@eprog

\bprog
? nf=nfinit(x^6+108); gal=galoisinit(nf); pr=idealprimedec(nf,2)[1];
? iso=idealramgroups(nf,gal,pr)[2]
%4 = [[Vecsmall([2, 3, 1, 5, 6, 4])], Vecsmall([3])]
? nfdisc(galoisfixedfield(gal,iso,1))
%5 = -3
@eprog\noindent The field fixed by the inertia group of $2$ is not ramified at
$2$.

The library syntax is \fun{GEN}{idealramgroups}{GEN nf, GEN gal, GEN pr}.

\subsec{idealred$(\var{nf},I,\{v=0\})$}\kbdsidx{idealred}\label{se:idealred}
\idx{LLL} reduction of
the ideal $I$ in the number field \var{nf}, along the direction $v$.
The $v$ parameter is best left omitted, but if it is present, it must
be an $\kbd{nf.r1} + \kbd{nf.r2}$-component vector of \emph{non-negative}
integers. (What counts is the relative magnitude of the entries: if all
entries are equal, the effect is the same as if the vector had been omitted.)

This function finds a ``small'' $a$ in $I$ (see the end for technical details).
The result is the Hermite normal form of
the ``reduced'' ideal $J = r I/a$, where $r$ is the unique rational number such
that $J$ is integral and primitive. (This is usually not a reduced ideal in
the sense of \idx{Buchmann}.)
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K,5)[1];
? idealred(K, P)
%3 =
[1 0]

[0 1]
@eprog\noindent More often than not, a \idx{principal ideal} yields the unit
ideal as above. This is a quick and dirty way to check if ideals are principal,
but it is not a necessary condition: a non-trivial result does not prove that
the ideal is non-principal. For guaranteed results, see \kbd{bnfisprincipal},
which requires the computation of a full \kbd{bnf} structure.

If the input is an extended ideal $[I,s]$, the output is $[J,sa/r]$; this way,
one can keep track of the principal ideal part:
\bprog
? idealred(K, [P, 1])
%5 = [[1, 0; 0, 1], [-2, 1]~]
@eprog\noindent
meaning that $P$ is generated by $[-2, 1]~$. The number field element in the
extended part is an algebraic number in any form \emph{or} a factorization
matrix (in terms of number field elements, not ideals!). In the latter case,
elements stay in factored form, which is a convenient way to avoid
coefficient explosion; see also \tet{idealpow}.

\misctitle{Technical note} The routine computes an LLL-reduced
basis for the lattice $I$ equipped with the quadratic form
$$|| x ||_v^2 = \sum_{i=1}^{r_1+r_2} 2^{v_i}\varepsilon_i|\sigma_i(x)|^2,$$
where as usual the $\sigma_i$ are the (real and) complex embeddings and
$\varepsilon_i = 1$, resp.~$2$, for a real, resp.~complex place. The element
$a$ is simply the first vector in the LLL basis. The only reason you may want
to try to change some directions and set some $v_i\neq 0$ is to randomize
the elements found for a fixed ideal, which is heuristically useful in index
calculus algorithms like \tet{bnfinit} and \tet{bnfisprincipal}.

\misctitle{Even more technical note} In fact, the above is a white lie.
We do not use $||\cdot||_v$ exactly but a rescaled rounded variant which
gets us faster and simpler LLLs. There's no harm since we are not using any
theoretical property of $a$ after all, except that it belongs to $I$ and is
``expected to be small''.

The library syntax is \fun{GEN}{idealred0}{GEN nf, GEN I, GEN v = NULL}.

\subsec{idealstar$(\var{nf},I,\{\fl=1\})$}\kbdsidx{idealstar}\label{se:idealstar}
Outputs a \var{bid} structure,
necessary for computing in the finite abelian group $G = (\Z_K/I)^*$. Here,
\var{nf} is a number field and $I$ is a \var{modulus}: either an ideal in any
form, or a row vector whose first component is an ideal and whose second
component is a row vector of $r_1$ 0 or 1. Ideals can also be given
by a factorization into prime ideals, as produced by \tet{idealfactor}.

This \var{bid} is used in \tet{ideallog} to compute discrete logarithms. It
also contains useful information which can be conveniently retrieved as
\kbd{\var{bid}.mod} (the modulus),
\kbd{\var{bid}.clgp} ($G$ as a finite abelian group),
\kbd{\var{bid}.no} (the cardinality of $G$),
\kbd{\var{bid}.cyc} (elementary divisors) and
\kbd{\var{bid}.gen} (generators).

If $\fl=1$ (default), the result is a \var{bid} structure without
generators.

If $\fl=2$, as $\fl=1$, but including generators, which wastes some time.

If $\fl=0$, only outputs $(\Z_K/I)^*$ as an abelian group,
i.e as a 3-component vector $[h,d,g]$: $h$ is the order, $d$ is the vector of
SNF\sidx{Smith normal form} cyclic components and $g$ the corresponding
generators.

The library syntax is \fun{GEN}{idealstar0}{GEN nf, GEN I, long flag}.
Instead the above hardcoded numerical flags, one should rather use
\fun{GEN}{Idealstar}{GEN nf, GEN ideal, long flag}, where \kbd{flag} is
an or-ed combination of \tet{nf_GEN} (include generators) and \tet{nf_INIT}
(return a full \kbd{bid}, not a group), possibly $0$. This offers
one more combination: gen, but no init.

\subsec{idealtwoelt$(\var{nf},x,\{a\})$}\kbdsidx{idealtwoelt}\label{se:idealtwoelt}
Computes a two-element
representation of the ideal $x$ in the number field $\var{nf}$, combining a
random search and an approximation theorem; $x$ is an ideal
in any form (possibly an extended ideal, whose principal part is ignored)

\item When called as \kbd{idealtwoelt(nf,x)}, the result is a row vector
$[a,\alpha]$ with two components such that $x=a\Z_K+\alpha\Z_K$ and $a$ is
chosen to be the positive generator of $x\cap\Z$, unless $x$ was given as a
principal ideal (in which case we may choose $a = 0$). The algorithm
uses a fast lazy factorization of $x\cap \Z$ and runs in randomized
polynomial time.

\item When called as \kbd{idealtwoelt(nf,x,a)} with an explicit non-zero $a$
supplied as third argument, the function assumes that $a \in x$ and returns
$\alpha\in x$ such that $x = a\Z_K + \alpha\Z_K$. Note that we must factor
$a$ in this case, and the algorithm is generally much slower than the
default variant.

The library syntax is \fun{GEN}{idealtwoelt0}{GEN nf, GEN x, GEN a = NULL}.
Also available are
\fun{GEN}{idealtwoelt}{GEN nf, GEN x} and
\fun{GEN}{idealtwoelt2}{GEN nf, GEN x, GEN a}.

\subsec{idealval$(\var{nf},x,\var{pr})$}\kbdsidx{idealval}\label{se:idealval}
Gives the valuation of the ideal $x$ at the prime ideal \var{pr} in the
number field $\var{nf}$, where \var{pr} is in \kbd{idealprimedec} format.

The library syntax is \fun{long}{idealval}{GEN nf, GEN x, GEN pr}.

\subsec{matalgtobasis$(\var{nf},x)$}\kbdsidx{matalgtobasis}\label{se:matalgtobasis}
$\var{nf}$ being a number field in \kbd{nfinit} format, and $x$ a
(row or column) vector or matrix, apply \tet{nfalgtobasis} to each entry
of $x$.

The library syntax is \fun{GEN}{matalgtobasis}{GEN nf, GEN x}.

\subsec{matbasistoalg$(\var{nf},x)$}\kbdsidx{matbasistoalg}\label{se:matbasistoalg}
$\var{nf}$ being a number field in \kbd{nfinit} format, and $x$ a
(row or column) vector or matrix, apply \tet{nfbasistoalg} to each entry
of $x$.

The library syntax is \fun{GEN}{matbasistoalg}{GEN nf, GEN x}.

\subsec{modreverse$(z)$}\kbdsidx{modreverse}\label{se:modreverse}
Let $z = \kbd{Mod(A, T)}$ be a polmod, and $Q$ be its minimal
polynomial, which must satisfy $\text{deg}(Q) = \text{deg}(T)$.
Returns a ``reverse polmod'' \kbd{Mod(B, Q)}, which is a root of $T$.

This is quite useful when one changes the generating element in algebraic
extensions:
\bprog
? u = Mod(x, x^3 - x -1); v = u^5;
? w = modreverse(v)
%2 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
@eprog\noindent
which means that $x^3 - 5x^2 + 4x -1$ is another defining polynomial for the
cubic field
$$\Q(u) = \Q[x]/(x^3 - x - 1) = \Q[x]/(x^3 - 5x^2 + 4x - 1) = \Q(v),$$
and that $u \to v^2 - 4v + 1$ gives an explicit isomorphism. From this, it is
easy to convert elements between the $A(u)\in \Q(u)$ and $B(v)\in \Q(v)$
representations:
\bprog
? A = u^2 + 2*u + 3; subst(lift(A), 'x, w)
%3 = Mod(x^2 - 3*x + 3, x^3 - 5*x^2 + 4*x - 1)
? B = v^2 + v + 1;   subst(lift(B), 'x, v)
%4 = Mod(26*x^2 + 31*x + 26, x^3 - x - 1)
@eprog
If the minimal polynomial of $z$ has lower degree than expected, the routine
fails
\bprog
? u = Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)
? modreverse(u)
 *** modreverse: domain error in modreverse: deg(minpoly(z)) < 4
 ***   Break loop: type 'break' to go back to GP prompt
break> Vec( dbg_err() ) \\ ask for more info
["e_DOMAIN", "modreverse", "deg(minpoly(z))", "<", 4,
  Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)]
break> minpoly(u)
x^2 - 8
@eprog

The library syntax is \fun{GEN}{modreverse}{GEN z}.

\subsec{newtonpoly$(x,p)$}\kbdsidx{newtonpoly}\label{se:newtonpoly}
Gives the vector of the slopes of the Newton
polygon of the polynomial $x$ with respect to the prime number $p$. The $n$
components of the vector are in decreasing order, where $n$ is equal to the
degree of $x$. Vertical slopes occur iff the constant coefficient of $x$ is
zero and are denoted by \tet{LONG_MAX}, the biggest single precision
integer representable on the machine ($2^{31}-1$ (resp.~$2^{63}-1$) on 32-bit
(resp.~64-bit) machines), see \secref{se:valuation}.

The library syntax is \fun{GEN}{newtonpoly}{GEN x, GEN p}.

\subsec{nfalgtobasis$(\var{nf},x)$}\kbdsidx{nfalgtobasis}\label{se:nfalgtobasis}
Given an algebraic number $x$ in the number field $\var{nf}$,
transforms it to a column vector on the integral basis \kbd{\var{nf}.zk}.
\bprog
? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfalgtobasis(nf, [1,1]~)
%3 = [1, 1]~
? nfalgtobasis(nf, y)
%4 = [0, 2]~
? nfalgtobasis(nf, Mod(y, y^2+4))
%4 = [0, 2]~
@eprog
This is the inverse function of \kbd{nfbasistoalg}.

The library syntax is \fun{GEN}{algtobasis}{GEN nf, GEN x}.

\subsec{nfbasis$(T)$}\kbdsidx{nfbasis}\label{se:nfbasis}
Let $T(X)$ be an irreducible polynomial with integral coefficients. This
function returns an \idx{integral basis} of the number field defined by $T$,
that is a $\Z$-basis of its maximal order. The basis elements are given as
elements in $\Q[X]/(T)$:
\bprog
? nfbasis(x^2 + 1)
%1 = [1, x]
@eprog
This function uses a modified version of the \idx{round 4} algorithm,
due to David \idx{Ford}, Sebastian \idx{Pauli} and Xavier \idx{Roblot}.

\misctitle{Local basis, orders maximal at certain primes}

Obtaining the maximal order is hard: it requires factoring the discriminant
$D$ of $T$. Obtaining an order which is maximal at a finite explicit set of
primes is easy, but if may then be a strict suborder of the maximal order. To
specify that we are interested in a given set of places only, we can replace
the argument $T$ by an argument $[T,\var{listP}]$, where \var{listP} encodes
the primes we are interested in: it must be a factorization matrix, a vector
of integers or a single integer.

\item Vector: we assume that it contains distinct \emph{prime} numbers.

\item Matrix: we assume that it is a two-column matrix of a
(partial) factorization of $D$; namely the first column contains
\emph{primes} and the second one the valuation of $D$ at each of these
primes.

\item Integer $B$: this is replaced by the vector of primes up to $B$. Note
that the function will use at least $O(B)$ time: a small value, about
$10^5$, should be enough for most applications. Values larger than $2^{32}$
are not supported.

In all these cases, the primes may or may not divide the discriminant $D$
of $T$. The function then returns a $\Z$-basis of an order whose index is
not divisible by any of these prime numbers. The result is actually a global
integral basis if all prime divisors of the \emph{field} discriminant are
included! Note that \kbd{nfinit} has built-in support for such
a check:
\bprog
? K = nfinit([T, listP]);
? nfcertify(K)   \\ we computed an actual maximal order
%2 = [];
@eprog\noindent The first line initializes a number field structure
incorporating \kbd{nfbasis([T, listP]} in place of a proven integral basis.
The second line certifies that the resulting structure is correct. This
allows to create an \kbd{nf} structure associated to the number field $K =
\Q[X]/(T)$, when the discriminant of $T$ cannot be factored completely,
whereas the prime divisors of $\disc K$ are known.

Of course, if \var{listP} contains a single prime number $p$,
the function returns a local integral basis for $\Z_p[X]/(T)$:
\bprog
? nfbasis(x^2+x-1001)
%1 = [1, 1/3*x - 1/3]
? nfbasis( [x^2+x-1001, [2]] )
%2 = [1, x]
@eprog

\misctitle{The Buchmann-Lenstra algorithm}

We now complicate the picture: it is in fact allowed to include
\emph{composite} numbers instead of primes
in \kbd{listP} (Vector or Matrix case), provided they are pairwise coprime.
The result will still be a correct integral basis \emph{if}
the field discriminant factors completely over the actual primes in the list.
Adding a composite $C$ such that $C^2$ \emph{divides} $D$ may help because
when we consider $C$ as a prime and run the algorithm, two good things can
happen: either we
succeed in proving that no prime dividing $C$ can divide the index
(without actually needing to find those primes), or the computation
exhibits a non-trivial zero divisor, thereby factoring $C$ and
we go on with the refined factorization. (Note that including a $C$
such that $C^2$ does not divide $D$ is useless.) If neither happen, then the
computed basis need not generate the maximal order. Here is an example:
\bprog
? B = 10^5;
? P = factor(poldisc(T), B)[,1]; \\ primes <= B dividing D + cofactor
? basis = nfbasis([T, listP])
? disc = nfdisc([T, listP])
@eprog\noindent We obtain the maximal order and its discriminant if the
field discriminant factors
completely over the primes less than $B$ (together with the primes
contained in the \tet{addprimes} table). This can be tested as follows:
\bprog
  check = factor(disc, B);
  lastp = check[-1..-1,1];
  if (lastp > B && !setsearch(addprimes(), lastp),
    warning("nf may be incorrect!"))
@eprog\noindent
This is a sufficient but not a necessary condition, hence the warning,
instead of an error. N.B. \kbd{lastp} is the last entry
in the first column of the \kbd{check} matrix, i.e. the largest prime
dividing \kbd{nf.disc} if $\leq B$ or if it belongs to the prime table.

The function \tet{nfcertify} speeds up and automates the above process:
\bprog
? B = 10^5;
? nf = nfinit([T, B]);
? nfcertify(nf)
%3 = []      \\ nf is unconditionally correct
? basis = nf.zk;
? disc = nf.disc;
@eprog

\synt{nfbasis}{GEN T, GEN *d, GEN listP = NULL}, which returns the order
basis, and where \kbd{*d} receives the order discriminant.

\subsec{nfbasistoalg$(\var{nf},x)$}\kbdsidx{nfbasistoalg}\label{se:nfbasistoalg}
Given an algebraic number $x$ in the number field \kbd{nf}, transforms it
into \typ{POLMOD} form.
\bprog
? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfbasistoalg(nf, [1,1]~)
%3 = Mod(1/2*y + 1, y^2 + 4)
? nfbasistoalg(nf, y)
%4 = Mod(y, y^2 + 4)
? nfbasistoalg(nf, Mod(y, y^2+4))
%4 = Mod(y, y^2 + 4)
@eprog
This is the inverse function of \kbd{nfalgtobasis}.

The library syntax is \fun{GEN}{basistoalg}{GEN nf, GEN x}.

\subsec{nfcertify$(\var{nf})$}\kbdsidx{nfcertify}\label{se:nfcertify}
$\var{nf}$ being as output by
\kbd{nfinit}, checks whether the integer basis is known unconditionally.
This is in particular useful when the argument to \kbd{nfinit} was of the
form $[T, \kbd{listP}]$, specifying a finite list of primes when
$p$-maximality had to be proven.

The function returns a vector of composite integers. If this vector is
empty, then \kbd{nf.zk} and \kbd{nf.disc} are correct. Otherwise, the
result is dubious. In order to obtain a certified result, one must
completely factor each of the given integers, then \kbd{addprime} each of
them, then check whether \kbd{nfdisc(nf.pol)} is equal to \kbd{nf.disc}.

The library syntax is \fun{GEN}{nfcertify}{GEN nf}.

\subsec{nfdetint$(\var{nf},x)$}\kbdsidx{nfdetint}\label{se:nfdetint}
Given a pseudo-matrix $x$, computes a
non-zero ideal contained in (i.e.~multiple of) the determinant of $x$. This
is particularly useful in conjunction with \kbd{nfhnfmod}.

The library syntax is \fun{GEN}{nfdetint}{GEN nf, GEN x}.

\subsec{nfdisc$(T)$}\kbdsidx{nfdisc}\label{se:nfdisc}
\idx{field discriminant} of the number field defined by the integral,
preferably monic, irreducible polynomial $T(X)$. Returns the discriminant of
the number field $\Q[X]/(T)$, using the Round $4$ algorithm.

\misctitle{Local discriminants, valuations at certain primes}

As in \kbd{nfbasis}, the argument $T$ can be replaced by $[T,\var{listP}]$,
where \kbd{listP} is as in \kbd{nfbasis}: a vector of
pairwise coprime integers (usually distinct primes), a factorization matrix,
or a single integer. In that case, the function returns the discriminant of
an order whose basis is given by \kbd{nfbasis(T,listP)}, which need not be
the maximal order, and whose valuation at a prime entry in \kbd{listP} is the
same as the valuation of the field discriminant.

In particular, if \kbd{listP} is $[p]$ for a prime $p$, we can
return the $p$-adic discriminant of the maximal order of $\Z_p[X]/(T)$,
as a power of $p$, as follows:
\bprog
? padicdisc(T,p) = p^valuation(nfdisc(T,[p]), p);
? nfdisc(x^2 + 6)
%1 = -24
? padicdisc(x^2 + 6, 2)
%2 = 8
? padicdisc(x^2 + 6, 3)
%3 = 3
@eprog

\synt{nfdisc}{GEN T} (\kbd{listP = NULL}). Also available is
\fun{GEN}{nfbasis}{GEN T, GEN *d, GEN listP = NULL}, which returns the order
basis, and where \kbd{*d} receives the order discriminant.

\subsec{nfeltadd$(\var{nf},x,y)$}\kbdsidx{nfeltadd}\label{se:nfeltadd}
Given two elements $x$ and $y$ in
\var{nf}, computes their sum $x+y$ in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfadd}{GEN nf, GEN x, GEN y}.

\subsec{nfeltdiv$(\var{nf},x,y)$}\kbdsidx{nfeltdiv}\label{se:nfeltdiv}
Given two elements $x$ and $y$ in
\var{nf}, computes their quotient $x/y$ in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfdiv}{GEN nf, GEN x, GEN y}.

\subsec{nfeltdiveuc$(\var{nf},x,y)$}\kbdsidx{nfeltdiveuc}\label{se:nfeltdiveuc}
Given two elements $x$ and $y$ in
\var{nf}, computes an algebraic integer $q$ in the number field $\var{nf}$
such that the components of $x-qy$ are reasonably small. In fact, this is
functionally identical to \kbd{round(nfdiv(\var{nf},x,y))}.

The library syntax is \fun{GEN}{nfdiveuc}{GEN nf, GEN x, GEN y}.

\subsec{nfeltdivmodpr$(\var{nf},x,y,\var{pr})$}\kbdsidx{nfeltdivmodpr}\label{se:nfeltdivmodpr}
Given two elements $x$
and $y$ in \var{nf} and \var{pr} a prime ideal in \kbd{modpr} format (see
\tet{nfmodprinit}), computes their quotient $x / y$ modulo the prime ideal
\var{pr}.

The library syntax is \fun{GEN}{nfdivmodpr}{GEN nf, GEN x, GEN y, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltdivrem$(\var{nf},x,y)$}\kbdsidx{nfeltdivrem}\label{se:nfeltdivrem}
Given two elements $x$ and $y$ in
\var{nf}, gives a two-element row vector $[q,r]$ such that $x=qy+r$, $q$ is
an algebraic integer in $\var{nf}$, and the components of $r$ are
reasonably small.

The library syntax is \fun{GEN}{nfdivrem}{GEN nf, GEN x, GEN y}.

\subsec{nfeltmod$(\var{nf},x,y)$}\kbdsidx{nfeltmod}\label{se:nfeltmod}
Given two elements $x$ and $y$ in
\var{nf}, computes an element $r$ of $\var{nf}$ of the form $r=x-qy$ with
$q$ and algebraic integer, and such that $r$ is small. This is functionally
identical to
$$\kbd{x - nfmul(\var{nf},round(nfdiv(\var{nf},x,y)),y)}.$$

The library syntax is \fun{GEN}{nfmod}{GEN nf, GEN x, GEN y}.

\subsec{nfeltmul$(\var{nf},x,y)$}\kbdsidx{nfeltmul}\label{se:nfeltmul}
Given two elements $x$ and $y$ in
\var{nf}, computes their product $x*y$ in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfmul}{GEN nf, GEN x, GEN y}.

\subsec{nfeltmulmodpr$(\var{nf},x,y,\var{pr})$}\kbdsidx{nfeltmulmodpr}\label{se:nfeltmulmodpr}
Given two elements $x$ and
$y$ in \var{nf} and \var{pr} a prime ideal in \kbd{modpr} format (see
\tet{nfmodprinit}), computes their product $x*y$ modulo the prime ideal
\var{pr}.

The library syntax is \fun{GEN}{nfmulmodpr}{GEN nf, GEN x, GEN y, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltnorm$(\var{nf},x)$}\kbdsidx{nfeltnorm}\label{se:nfeltnorm}
Returns the absolute norm of $x$.

The library syntax is \fun{GEN}{nfnorm}{GEN nf, GEN x}.

\subsec{nfeltpow$(\var{nf},x,k)$}\kbdsidx{nfeltpow}\label{se:nfeltpow}
Given an element $x$ in \var{nf}, and a positive or negative integer $k$,
computes $x^k$ in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfpow}{GEN nf, GEN x, GEN k}.
\fun{GEN}{nfinv}{GEN nf, GEN x} correspond to $k = -1$, and
\fun{GEN}{nfsqr}{GEN nf,GEN x} to $k = 2$.

\subsec{nfeltpowmodpr$(\var{nf},x,k,\var{pr})$}\kbdsidx{nfeltpowmodpr}\label{se:nfeltpowmodpr}
Given an element $x$ in \var{nf}, an integer $k$ and a prime ideal
\var{pr} in \kbd{modpr} format
(see \tet{nfmodprinit}), computes $x^k$ modulo the prime ideal \var{pr}.

The library syntax is \fun{GEN}{nfpowmodpr}{GEN nf, GEN x, GEN k, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltreduce$(\var{nf},a,\var{id})$}\kbdsidx{nfeltreduce}\label{se:nfeltreduce}
Given an ideal \var{id} in
Hermite normal form and an element $a$ of the number field $\var{nf}$,
finds an element $r$ in $\var{nf}$ such that $a-r$ belongs to the ideal
and $r$ is small.

The library syntax is \fun{GEN}{nfreduce}{GEN nf, GEN a, GEN id}.

\subsec{nfeltreducemodpr$(\var{nf},x,\var{pr})$}\kbdsidx{nfeltreducemodpr}\label{se:nfeltreducemodpr}
Given an element $x$ of the number field $\var{nf}$ and a prime ideal
\var{pr} in \kbd{modpr} format compute a canonical representative for the
class of $x$ modulo \var{pr}.

The library syntax is \fun{GEN}{nfreducemodpr}{GEN nf, GEN x, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfelttrace$(\var{nf},x)$}\kbdsidx{nfelttrace}\label{se:nfelttrace}
Returns the absolute trace of $x$.

The library syntax is \fun{GEN}{nftrace}{GEN nf, GEN x}.

\subsec{nfeltval$(\var{nf},x,\var{pr})$}\kbdsidx{nfeltval}\label{se:nfeltval}
Given an element $x$ in
\var{nf} and a prime ideal \var{pr} in the format output by
\kbd{idealprimedec}, computes the valuation at \var{pr} of the
element $x$. The same result can be obtained using
\kbd{idealval(\var{nf},x,\var{pr})}, since $x$ is then converted to a
principal ideal.

The library syntax is \fun{long}{nfval}{GEN nf, GEN x, GEN pr}.

\subsec{nffactor$(\var{nf},T)$}\kbdsidx{nffactor}\label{se:nffactor}
Factorization of the univariate
polynomial $T$ over the number field $\var{nf}$ given by \kbd{nfinit}; $T$
has coefficients in $\var{nf}$ (i.e.~either scalar, polmod, polynomial or
column vector). The factors are sorted by increasing degree.

The main variable of $\var{nf}$ must be of \emph{lower}
priority than that of $T$, see \secref{se:priority}. However if
the polynomial defining the number field occurs explicitly  in the
coefficients of $T$ as modulus of a \typ{POLMOD} or as a \typ{POL}
coefficient, its main variable must be \emph{the same} as the main variable
of $T$. For example,
\bprog
? nf = nfinit(y^2 + 1);
? nffactor(nf, x^2 + y); \\@com OK
? nffactor(nf, x^2 + Mod(y, y^2+1)); \\ @com OK
? nffactor(nf, x^2 + Mod(z, z^2+1)); \\ @com WRONG
@eprog

It is possible to input a defining polynomial for \var{nf}
instead, but this is in general less efficient since parts of an \kbd{nf}
structure will then be computed internally. This is useful in two
situations: when you do not need the \kbd{nf} elsewhere, or when you cannot
compute the field discriminant due to integer factorization difficulties. In
the latter case, if you must use a partial discriminant factorization (as
allowed by both \tet{nfdisc} or \tet{nfbasis}) to build a partially correct
\var{nf} structure, always input \kbd{nf.pol} to \kbd{nffactor}, and not your
makeshift \var{nf}: otherwise factors could be missed.

The library syntax is \fun{GEN}{nffactor}{GEN nf, GEN T}.

\subsec{nffactorback$(\var{nf},f,\{e\})$}\kbdsidx{nffactorback}\label{se:nffactorback}
Gives back the \kbd{nf} element corresponding to a factorization.
The integer $1$ corresponds to the empty factorization.

If $e$ is present, $e$ and $f$ must be vectors of the same length ($e$ being
integral), and the corresponding factorization is the product of the
$f[i]^{e[i]}$.

If not, and $f$ is vector, it is understood as in the preceding case with $e$
a vector of 1s: we return the product of the $f[i]$. Finally, $f$ can be a
regular factorization matrix.
\bprog
? nf = nfinit(y^2+1);
? nffactorback(nf, [3, y+1, [1,2]~], [1, 2, 3])
%2 = [12, -66]~
? 3 * (I+1)^2 * (1+2*I)^3
%3 = 12 - 66*I
@eprog

The library syntax is \fun{GEN}{nffactorback}{GEN nf, GEN f, GEN e = NULL}.

\subsec{nffactormod$(\var{nf},Q,\var{pr})$}\kbdsidx{nffactormod}\label{se:nffactormod}
Factors the univariate polynomial $Q$ modulo the prime ideal \var{pr} in
the number field $\var{nf}$. The coefficients of $Q$ belong to the number
field (scalar, polmod, polynomial, even column vector) and the main variable
of $\var{nf}$ must be of lower priority than that of $Q$ (see
\secref{se:priority}). The prime ideal \var{pr} is either in
\tet{idealprimedec} or (preferred) \tet{modprinit} format. The coefficients
of the polynomial factors are lifted to elements of \var{nf}:
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? nffactormod(K, x^2 + y*x + 18*y+1, P)
%3 =
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
? P = nfmodprinit(K, P);  \\ convert to nfmodprinit format
? nffactormod(K, x^2 + y*x + 18*y+1)
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
@eprog\noindent Same result, of course, here about 10\% faster due to the
precomputation.

The library syntax is \fun{GEN}{nffactormod}{GEN nf, GEN Q, GEN pr}.

\subsec{nfgaloisapply$(\var{nf},\var{aut},x)$}\kbdsidx{nfgaloisapply}\label{se:nfgaloisapply}
Let $\var{nf}$ be a
number field as output by \kbd{nfinit}, and let \var{aut} be a \idx{Galois}
automorphism of $\var{nf}$ expressed by its image on the field generator
(such automorphisms can be found using \kbd{nfgaloisconj}). The function
computes the action of the automorphism \var{aut} on the object $x$ in the
number field; $x$ can be a number field element, or an ideal (possibly
extended). Because of possible confusion with elements and ideals, other
vector or matrix arguments are forbidden.
 \bprog
 ? nf = nfinit(x^2+1);
 ? L = nfgaloisconj(nf)
 %2 = [-x, x]~
 ? aut = L[1]; /* the non-trivial automorphism */
 ? nfgaloisapply(nf, aut, x)
 %4 = Mod(-x, x^2 + 1)
 ? P = idealprimedec(nf,5); /* prime ideals above 5 */
 ? nfgaloisapply(nf, aut, P[2]) == P[1]
 %7 = 0 \\ !!!!
 ? idealval(nf, nfgaloisapply(nf, aut, P[2]), P[1])
 %8 = 1
@eprog\noindent The surprising failure of the equality test (\kbd{\%7}) is
due to the fact that although the corresponding prime ideals are equal, their
representations are not. (A prime ideal is specified by a uniformizer, and
there is no guarantee that applying automorphisms yields the same elements
as a direct \kbd{idealprimedec} call.)

The automorphism can also be given as a column vector, representing the
image of \kbd{Mod(x, nf.pol)} as an algebraic number. This last
representation is more efficient and should be preferred if a given
automorphism must be used in many such calls.
\bprog
 ? nf = nfinit(x^3 - 37*x^2 + 74*x - 37);
 ? l = nfgaloisconj(nf); aut = l[2] \\ @com automorphisms in basistoalg form
 %2 = -31/11*x^2 + 1109/11*x - 925/11
 ? L = matalgtobasis(nf, l); AUT = L[2] \\ @com same in algtobasis form
 %3 = [16, -6, 5]~
 ? v = [1, 2, 3]~; nfgaloisapply(nf, aut, v) == nfgaloisapply(nf, AUT, v)
 %4 = 1 \\ @com same result...
 ? for (i=1,10^5, nfgaloisapply(nf, aut, v))
 time = 1,451 ms.
 ? for (i=1,10^5, nfgaloisapply(nf, AUT, v))
 time = 1,045 ms.  \\ @com but the latter is faster
@eprog

The library syntax is \fun{GEN}{galoisapply}{GEN nf, GEN aut, GEN x}.

\subsec{nfgaloisconj$(\var{nf},\{\fl=0\},\{d\})$}\kbdsidx{nfgaloisconj}\label{se:nfgaloisconj}
$\var{nf}$ being a number field as output by \kbd{nfinit}, computes the
conjugates of a root $r$ of the non-constant polynomial $x=\var{nf}[1]$
expressed as polynomials in $r$. This also makes sense when the number field
is not \idx{Galois} since some conjugates may lie in the field.
$\var{nf}$ can simply be a polynomial.

If no flags or $\fl=0$, use a combination of flag $4$ and $1$ and the result
is always complete. There is no point whatsoever in using the other flags.

If $\fl=1$, use \kbd{nfroots}: a little slow, but guaranteed to work in
polynomial time.

If $\fl=2$ (OBSOLETE), use complex approximations to the roots and an integral
\idx{LLL}. The result is not guaranteed to be complete: some
conjugates may be missing (a warning is issued if the result is not proved
complete), especially so if the corresponding polynomial has a huge index,
and increasing the default precision may help. This variant is slow and
unreliable: don't use it.

If $\fl=4$, use \kbd{galoisinit}: very fast, but only applies to (most) Galois
fields. If the field is Galois with weakly
super-solvable Galois group (see \tet{galoisinit}), return the complete list
of automorphisms, else only the identity element. If present, $d$ is assumed to
be a multiple of the least common denominator of the conjugates expressed as
polynomial in a root of \var{pol}.

This routine can only compute $\Q$-automorphisms, but it may be used to get
$K$-automorphism for any base field $K$ as follows:
\bprog
rnfgaloisconj(nfK, R) = \\ K-automorphisms of L = K[X] / (R)
{ my(polabs, N);
  R *= Mod(1, nfK.pol);             \\ convert coeffs to polmod elts of K
  polabs = rnfequation(nfK, R);
  N = nfgaloisconj(polabs) % R;     \\ Q-automorphisms of L
  \\ select the ones that fix K
  select(s->subst(R, variable(R), Mod(s,R)) == 0, N);
}
K  = nfinit(y^2 + 7);
rnfgaloisconj(K, x^4 - y*x^3 - 3*x^2 + y*x + 1)  \\ K-automorphisms of L
@eprog

The library syntax is \fun{GEN}{galoisconj0}{GEN nf, long flag, GEN d = NULL, long prec}.
Use directly
\fun{GEN}{galoisconj}{GEN nf, GEN d}, corresponding to $\fl = 0$, the others
only have historical interest.

\subsec{nfhilbert$(\var{nf},a,b,\{\var{pr}\})$}\kbdsidx{nfhilbert}\label{se:nfhilbert}
If \var{pr} is omitted,
compute the global quadratic \idx{Hilbert symbol} $(a,b)$ in $\var{nf}$, that
is $1$ if $x^2 - a y^2 - b z^2$ has a non trivial solution $(x,y,z)$ in
$\var{nf}$, and $-1$ otherwise. Otherwise compute the local symbol modulo
the prime ideal \var{pr}, as output by \kbd{idealprimedec}.

The library syntax is \fun{long}{nfhilbert0}{GEN nf, GEN a, GEN b, GEN pr = NULL}.

Also available is \fun{long}{nfhilbert}{GEN bnf,GEN a,GEN b} (global
quadratic Hilbert symbol).

\subsec{nfhnf$(\var{nf},x)$}\kbdsidx{nfhnf}\label{se:nfhnf}
Given a pseudo-matrix $(A,I)$, finds a
pseudo-basis in \idx{Hermite normal form} of the module it generates.

The library syntax is \fun{GEN}{nfhnf}{GEN nf, GEN x}.
Also available:

\fun{GEN}{rnfsimplifybasis}{GEN bnf, GEN x} simplifies the pseudo-basis
given by $x = (A,I)$. The ideals in the list $I$ are integral, primitive and
either trivial (equal to the full ring of integer) or non-principal.

\subsec{nfhnfmod$(\var{nf},x,\var{detx})$}\kbdsidx{nfhnfmod}\label{se:nfhnfmod}
Given a pseudo-matrix $(A,I)$
and an ideal \var{detx} which is contained in (read integral multiple of) the
determinant of $(A,I)$, finds a pseudo-basis in \idx{Hermite normal form}
of the module generated by $(A,I)$. This avoids coefficient explosion.
\var{detx} can be computed using the function \kbd{nfdetint}.

The library syntax is \fun{GEN}{nfhnfmod}{GEN nf, GEN x, GEN detx}.

\subsec{nfinit$(\var{pol},\{\fl=0\})$}\kbdsidx{nfinit}\label{se:nfinit}
\var{pol} being a non-constant,
preferably monic, irreducible polynomial in $\Z[X]$, initializes a
\emph{number field} structure (\kbd{nf}) associated to the field $K$ defined
by \var{pol}. As such, it's a technical object passed as the first argument
to most \kbd{nf}\var{xxx} functions, but it contains some information which
may be directly useful. Access to this information via \emph{member
functions} is preferred since the specific data organization specified below
may change in the future. Currently, \kbd{nf} is a row vector with 9
components:

$\var{nf}[1]$ contains the polynomial \var{pol} (\kbd{\var{nf}.pol}).

$\var{nf}[2]$ contains $[r1,r2]$ (\kbd{\var{nf}.sign}, \kbd{\var{nf}.r1},
\kbd{\var{nf}.r2}), the number of real and complex places of $K$.

$\var{nf}[3]$ contains the discriminant $d(K)$ (\kbd{\var{nf}.disc}) of $K$.

$\var{nf}[4]$ contains the index of $\var{nf}[1]$ (\kbd{\var{nf}.index}),
i.e.~$[\Z_K : \Z[\theta]]$, where $\theta$ is any root of $\var{nf}[1]$.

$\var{nf}[5]$ is a vector containing 7 matrices $M$, $G$, \var{roundG}, $T$,
$MD$, $TI$, $MDI$ useful for certain computations in the number field $K$.

\quad\item $M$ is the $(r1+r2)\times n$ matrix whose columns represent
the numerical values of the conjugates of the elements of the integral
basis.

\quad\item $G$ is an $n\times n$ matrix such that $T2 = {}^t G G$,
where $T2$ is the quadratic form $T_2(x) = \sum |\sigma(x)|^2$, $\sigma$
running over the embeddings of $K$ into $\C$.

\quad\item \var{roundG} is a rescaled copy of $G$, rounded to nearest
integers.

\quad\item $T$ is the $n\times n$ matrix whose coefficients are
$\text{Tr}(\omega_i\omega_j)$ where the $\omega_i$ are the elements of the
integral basis. Note also that $\det(T)$ is equal to the discriminant of the
field $K$. Also, when understood as an ideal, the matrix $T^{-1}$
generates the codifferent ideal.

\quad\item The columns of $MD$ (\kbd{\var{nf}.diff}) express a $\Z$-basis
of the different of $K$ on the integral basis.

\quad\item $TI$ is equal to the primitive part of $T^{-1}$, which has integral
coefficients.

\quad\item Finally, $MDI$ is a two-element representation (for faster
ideal product) of $d(K)$ times the codifferent ideal
(\kbd{\var{nf}.disc$*$\var{nf}.codiff}, which is an integral ideal). $MDI$
is only used in \tet{idealinv}.

$\var{nf}[6]$ is the vector containing the $r1+r2$ roots
(\kbd{\var{nf}.roots}) of $\var{nf}[1]$ corresponding to the $r1+r2$
embeddings of the number field into $\C$ (the first $r1$ components are real,
the next $r2$ have positive imaginary part).

$\var{nf}[7]$ is an integral basis for $\Z_K$ (\kbd{\var{nf}.zk}) expressed
on the powers of~$\theta$. Its first element is guaranteed to be $1$. This
basis is LLL-reduced with respect to $T_2$ (strictly speaking, it is a
permutation of such a basis, due to the condition that the first element be
$1$).

$\var{nf}[8]$ is the $n\times n$ integral matrix expressing the power
basis in terms of the integral basis, and finally

$\var{nf}[9]$ is the $n\times n^2$ matrix giving the multiplication table
of the integral basis.

If a non monic polynomial is input, \kbd{nfinit} will transform it into a
monic one, then reduce it (see $\fl=3$). It is allowed, though not very
useful given the existence of \tet{nfnewprec}, to input a \kbd{nf} or a
\kbd{bnf} instead of a polynomial.

\bprog
? nf = nfinit(x^3 - 12); \\ initialize number field Q[X] / (X^3 - 12)
? nf.pol   \\ defining polynomial
%2 = x^3 - 12
? nf.disc  \\ field discriminant
%3 = -972
? nf.index \\ index of power basis order in maximal order
%4 = 2
? nf.zk    \\ integer basis, lifted to Q[X]
%5 = [1, x, 1/2*x^2]
? nf.sign  \\ signature
%6 = [1, 1]
? factor(abs(nf.disc ))  \\ determines ramified primes
%7 =
[2 2]

[3 5]
? idealfactor(nf, 2)
%8 =
[[2, [0, 0, -1]~, 3, 1, [0, 1, 0]~] 3]  \\ @com $\goth{p}_2^3$
@eprog

\misctitle{Huge discriminants, helping nfdisc}

In case \var{pol} has a huge discriminant which is difficult to factor,
it is hard to compute from scratch the maximal order. The special input
format $[\var{pol}, B]$ is also accepted where \var{pol} is a polynomial as
above and $B$ has one of the following forms

\item an integer basis, as would be computed by \tet{nfbasis}: a vector of
polynomials with first element $1$. This is useful if the maximal order is
known in advance.

\item an argument \kbd{listP} which specifies a list of primes (see
\tet{nfbasis}). Instead of the maximal order, \kbd{nfinit} then computes an
order which is maximal at these particular primes as well as the primes
contained in the private prime table (see \tet{addprimes}). The result is
unconditionaly correct when the discriminant \kbd{nf.disc} factors
completely over this set of primes. The function \tet{nfcertify} automates
this:
\bprog
? pol = polcompositum(x^5 - 101, polcyclo(7))[1];
? nf = nfinit( [pol, 10^3] );
? nfcertify(nf)
%3 = []
@eprog\noindent A priori, \kbd{nf.zk} defines an order which is only known
to be maximal at all primes $\leq 10^3$ (no prime $\leq 10^3$ divides
\kbd{nf.index}). The certification step proves the correctness of the
computation.
\medskip

If $\fl=2$: \var{pol} is changed into another polynomial $P$ defining the same
number field, which is as simple as can easily be found using the
\tet{polredbest} algorithm, and all the subsequent computations are done
using this new polynomial. In particular, the first component of the result
is the modified polynomial.

If $\fl=3$, apply \kbd{polredbest} as in case 2, but outputs
$[\var{nf},\kbd{Mod}(a,P)]$, where $\var{nf}$ is as before and
$\kbd{Mod}(a,P)=\kbd{Mod}(x,\var{pol})$ gives the change of
variables. This is implicit when \var{pol} is not monic: first a linear change
of variables is performed, to get a monic polynomial, then \kbd{polredbest}.

The library syntax is \fun{GEN}{nfinit0}{GEN pol, long flag, long prec}.
Also available are
\fun{GEN}{nfinit}{GEN x, long prec} ($\fl = 0$),
\fun{GEN}{nfinitred}{GEN x, long prec} ($\fl = 2$),
\fun{GEN}{nfinitred2}{GEN x, long prec} ($\fl = 3$).
Instead of the above hardcoded numerical flags in \kbd{nfinit0}, one should
rather use

\fun{GEN}{nfinitall}{GEN x, long flag, long prec}, where \fl\ is an
or-ed combination of

\item \tet{nf_RED}: find a simpler defining polynomial,

\item \tet{nf_ORIG}: if \tet{nf_RED} set, also return the change of variable,

\item \tet{nf_ROUND2}: \emph{Deprecated}. Slow down the routine by using an
obsolete normalization algorithm (do not use this one!),

\item \tet{nf_PARTIALFACT}: \emph{Deprecated}. Lazy factorization of the
polynomial discriminant. Result is conditional unless \kbd{nfcertify}
can certify it.

\subsec{nfisideal$(\var{nf},x)$}\kbdsidx{nfisideal}\label{se:nfisideal}
Returns 1 if $x$ is an ideal in the number field $\var{nf}$, 0 otherwise.

The library syntax is \fun{long}{isideal}{GEN nf, GEN x}.

\subsec{nfisincl$(x,y)$}\kbdsidx{nfisincl}\label{se:nfisincl}
Tests whether the number field $K$ defined
by the polynomial $x$ is conjugate to a subfield of the field $L$ defined
by $y$ (where $x$ and $y$ must be in $\Q[X]$). If they are not, the output
is the number 0. If they are, the output is a vector of polynomials, each
polynomial $a$ representing an embedding of $K$ into $L$, i.e.~being such
that $y\mid x\circ a$.

If $y$ is a number field (\var{nf}), a much faster algorithm is used
(factoring $x$ over $y$ using \tet{nffactor}). Before version 2.0.14, this
wasn't guaranteed to return all the embeddings, hence was triggered by a
special flag. This is no more the case.

The library syntax is \fun{GEN}{nfisincl}{GEN x, GEN y}.

\subsec{nfisisom$(x,y)$}\kbdsidx{nfisisom}\label{se:nfisisom}
As \tet{nfisincl}, but tests for isomorphism. If either $x$ or $y$ is a
number field, a much faster algorithm will be used.

The library syntax is \fun{GEN}{nfisisom}{GEN x, GEN y}.

\subsec{nfkermodpr$(\var{nf},x,\var{pr})$}\kbdsidx{nfkermodpr}\label{se:nfkermodpr}
Kernel of the matrix $a$ in $\Z_K/\var{pr}$, where \var{pr} is in
\key{modpr} format (see \kbd{nfmodprinit}).

The library syntax is \fun{GEN}{nfkermodpr}{GEN nf, GEN x, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nfM\_to\_FqM}, then work there.

\subsec{nfmodprinit$(\var{nf},\var{pr})$}\kbdsidx{nfmodprinit}\label{se:nfmodprinit}
Transforms the prime ideal \var{pr} into \tet{modpr} format necessary
for all operations modulo \var{pr} in the number field \var{nf}.

The library syntax is \fun{GEN}{nfmodprinit}{GEN nf, GEN pr}.

\subsec{nfnewprec$(\var{nf})$}\kbdsidx{nfnewprec}\label{se:nfnewprec}
Transforms the number field $\var{nf}$
into the corresponding data using current (usually larger) precision. This
function works as expected if $\var{nf}$ is in fact a $\var{bnf}$ (update
$\var{bnf}$ to current precision) but may be quite slow (many generators of
principal ideals have to be computed).

The library syntax is \fun{GEN}{nfnewprec}{GEN nf, long prec}.
See also \fun{GEN}{bnfnewprec}{GEN bnf, long prec}
and \fun{GEN}{bnrnewprec}{GEN bnr, long prec}.

\subsec{nfroots$(\{\var{nf}\},x)$}\kbdsidx{nfroots}\label{se:nfroots}
Roots of the polynomial $x$ in the
number field $\var{nf}$ given by \kbd{nfinit} without multiplicity (in $\Q$
if $\var{nf}$ is omitted). $x$ has coefficients in the number field (scalar,
polmod, polynomial, column vector). The main variable of $\var{nf}$ must be
of lower priority than that of $x$ (see \secref{se:priority}). However if the
coefficients of the number field occur explicitly (as polmods) as
coefficients of $x$, the variable of these polmods \emph{must} be the same as
the main variable of $t$ (see \kbd{nffactor}).

It is possible to input a defining polynomial for \var{nf}
instead, but this is in general less efficient since parts of an \kbd{nf}
structure will be computed internally. This is useful in two situations: when
you don't need the \kbd{nf}, or when you can't compute its discriminant due
to integer factorization difficulties. In the latter case, \tet{addprimes} is
a possibility but a dangerous one: roots will probably be missed if the
(true) field discriminant and an \kbd{addprimes} entry are strictly divisible
by some prime. If you have such an unsafe \var{nf}, it is safer to input
\kbd{nf.pol}.

The library syntax is \fun{GEN}{nfroots}{GEN nf = NULL, GEN x}.
See also \fun{GEN}{nfrootsQ}{GEN x},
corresponding to $\kbd{nf} = \kbd{NULL}$.

\subsec{nfrootsof1$(\var{nf})$}\kbdsidx{nfrootsof1}\label{se:nfrootsof1}
Returns a two-component vector $[w,z]$ where $w$ is the number of roots of
unity in the number field \var{nf}, and $z$ is a primitive $w$-th root
of unity.
\bprog
? K = nfinit(polcyclo(11));
? nfrootsof1(K)
%2 = [22, [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]~]
? z = nfbasistoalg(K, %[2])   \\ in algebraic form
%3 = Mod(-x^5, x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
? [lift(z^11), lift(z^2)]     \\ proves that the order of z is 22
%4 = [-1, -x^9 - x^8 - x^7 - x^6 - x^5 - x^4 - x^3 - x^2 - x - 1]
@eprog
This function guesses the number $w$ as the gcd of the $\#k(v)^*$ for
unramified $v$ above odd primes, then computes the roots in \var{nf}
of the $w$-th cyclotomic polynomial: the algorithm is polynomial time with
respect to the field degree and the bitsize of the multiplication table in
\var{nf} (both of them polynomially bounded in terms of the size of the
discriminant). Fields of degree up to $100$ or so should require less than
one minute.

The library syntax is \fun{GEN}{rootsof1}{GEN nf}.
Also available is \fun{GEN}{rootsof1_kannan}{GEN nf}, that computes
all algebraic integers of $T_2$ norm equal to the field degree
(all roots of $1$, by Kronecker's theorem). This is in general a little
faster than the default when there \emph{are} roots of $1$ in the field
(say twice faster), but can be much slower (say, \emph{days} slower), since
the algorithm is a priori exponential in the field degree.

\subsec{nfsnf$(\var{nf},x)$}\kbdsidx{nfsnf}\label{se:nfsnf}
Given a $\Z_K$-module $x$ associated to the integral pseudo-matrix
$(A,I,J)$, returns an ideal list $d_1,\dots,d_n$ which is the \idx{Smith
normal form} of $x$. In other words, $x$ is isomorphic to
$\Z_K/d_1\oplus\cdots\oplus\Z_K/d_n$ and $d_i$ divides $d_{i-1}$ for $i\ge2$.

See \secref{se:ZKmodules} for the definition of integral pseudo-matrix;
briefly, it is input as a 3-component row vector $[A,I,J]$ where
$I = [b_1,\dots,b_n]$ and $J = [a_1,\dots,a_n]$ are two ideal lists,
and $A$ is a square $n\times n$ matrix with columns $(A_1,\dots,A_n)$,
seen as elements in $K^n$ (with canonical basis $(e_1,\dots,e_n)$).
This data defines the $\Z_K$ module $x$ given by
$$ (b_1e_1\oplus\cdots\oplus b_ne_n) / (a_1A_1\oplus\cdots\oplus a_nA_n)
\enspace, $$
The integrality condition is $a_{i,j} \in b_i a_j^{-1}$ for all $i,j$. If it
is not satisfied, then the $d_i$ will not be integral. Note that every
finitely generated torsion module is isomorphic to a module of this form and
even with $b_i=Z_K$ for all $i$.

The library syntax is \fun{GEN}{nfsnf}{GEN nf, GEN x}.

\subsec{nfsolvemodpr$(\var{nf},a,b,P)$}\kbdsidx{nfsolvemodpr}\label{se:nfsolvemodpr}
Let $P$ be a prime ideal in \key{modpr} format (see \kbd{nfmodprinit}),
let $a$ be a matrix, invertible over the residue field, and let $b$ be
a column vector or matrix. This function returns a solution of $a\cdot x =
b$; the coefficients of $x$ are lifted to \var{nf} elements.
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? P = nfmodprinit(K, P);
? a = [y+1, y; y, 0]; b = [1, y]~
? nfsolvemodpr(K, a,b, P)
%5 = [1, 2]~
@eprog

The library syntax is \fun{GEN}{nfsolvemodpr}{GEN nf, GEN a, GEN b, GEN P}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nfM\_to\_FqM}, then work there.

\subsec{nfsubfields$(\var{pol},\{d=0\})$}\kbdsidx{nfsubfields}\label{se:nfsubfields}
Finds all subfields of degree
$d$ of the number field defined by the (monic, integral) polynomial
\var{pol} (all subfields if $d$ is null or omitted). The result is a vector
of subfields, each being given by $[g,h]$, where $g$ is an absolute equation
and $h$ expresses one of the roots of $g$ in terms of the root $x$ of the
polynomial defining $\var{nf}$. This routine uses J.~Kl\"uners's algorithm
in the general case, and B.~Allombert's \tet{galoissubfields} when \var{nf}
is Galois (with weakly supersolvable Galois group).\sidx{Galois}\sidx{subfield}

The library syntax is \fun{GEN}{nfsubfields}{GEN pol, long d}.

\subsec{polcompositum$(P,Q,\{\fl=0\})$}\kbdsidx{polcompositum}\label{se:polcompositum}
\sidx{compositum} $P$ and $Q$
being squarefree polynomials in $\Z[X]$ in the same variable, outputs
the simple factors of the \'etale $\Q$-algebra $A = \Q(X, Y) / (P(X), Q(Y))$.
The factors are given by a list of polynomials $R$ in $\Z[X]$, associated to
the number field $\Q(X)/ (R)$, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.

Note that it is more efficient to reduce to the case where $P$ and $Q$ are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor $R$ if and only if the number
fields defined by $P$ and $Q$ are disjoint.

Assuming $P$ is irreducible (of smaller degree than $Q$ for efficiency), it
is in general much faster to proceed as follows
\bprog
nf = nfinit(P); L = nffactor(nf, Q)[,1];
vector(#L, i, rnfequation(nf, L[i]))
@eprog\noindent
to obtain the same result. If you are only interested in the degrees of the
simple factors, the \kbd{rnfequation} instruction can be replaced by a
trivial \kbd{poldegree(P) * poldegree(L[i])}.

If $\fl=1$, outputs a vector of 4-component vectors $[R,a,b,k]$, where $R$
ranges through the list of all possible compositums as above, and $a$
(resp. $b$) expresses the root of $P$ (resp. $Q$) as an element of
$\Q(X)/(R)$. Finally, $k$ is a small integer such that $b + ka = X$ modulo
$R$.

A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field $\Q(\zeta_5, 5^{1/5})$:
\bprog
? L = polcompositum(x^5 - 5, polcyclo(5), 1); \\@com list of $[R,a,b,k]$
? [R, a] = L[1];  \\@com pick the single factor, extract $R,a$ (ignore $b,k$)
? R               \\@com defines the compositum
%3 = x^20 + 5*x^19 + 15*x^18 + 35*x^17 + 70*x^16 + 141*x^15 + 260*x^14\
+ 355*x^13 + 95*x^12 - 1460*x^11 - 3279*x^10 - 3660*x^9 - 2005*x^8    \
+ 705*x^7 + 9210*x^6 + 13506*x^5 + 7145*x^4 - 2740*x^3 + 1040*x^2     \
- 320*x + 256
? a^5 - 5         \\@com a fifth root of $5$
%4 = 0
? [T, X] = polredbest(R, 1);
? T     \\@com simpler defining polynomial for $\Q[x]/(R)$
%6 = x^20 + 25*x^10 + 5
? X     \\ @com root of $R$ in $\Q[y]/(T(y))$
%7 = Mod(-1/11*x^15 - 1/11*x^14 + 1/22*x^10 - 47/22*x^5 - 29/11*x^4 + 7/22,\
x^20 + 25*x^10 + 5)
? a = subst(a.pol, 'x, X)  \\@com \kbd{a} in the new coordinates
%8 = Mod(1/11*x^14 + 29/11*x^4, x^20 + 25*x^10 + 5)
? a^5 - 5
%9 = 0
@eprog

The library syntax is \fun{GEN}{polcompositum0}{GEN P, GEN Q, long flag}.
Also available are
\fun{GEN}{compositum}{GEN P, GEN Q} ($\fl = 0$) and
\fun{GEN}{compositum2}{GEN P, GEN Q} ($\fl = 1$).

\subsec{polgalois$(T)$}\kbdsidx{polgalois}\label{se:polgalois}
\idx{Galois} group of the non-constant
polynomial $T\in\Q[X]$. In the present version \vers, $T$ must be irreducible
and the degree $d$ of $T$ must be less than or equal to 7. If the
\tet{galdata} package has been installed, degrees 8, 9, 10 and 11 are also
implemented. By definition, if $K = \Q[x]/(T)$, this computes the action of
the Galois group of the Galois closure of $K$ on the $d$ distinct roots of
$T$, up to conjugacy (corresponding to different root orderings).

The output is a 4-component vector $[n,s,k,name]$ with the
following meaning: $n$ is the cardinality of the group, $s$ is its signature
($s=1$ if the group is a subgroup of the alternating group $A_d$, $s=-1$
otherwise) and name is a character string containing name of the transitive
group according to the GAP 4 transitive groups library by Alexander Hulpke.

$k$ is more arbitrary and the choice made up to version~2.2.3 of PARI is rather
unfortunate: for $d > 7$, $k$ is the numbering of the group among all
transitive subgroups of $S_d$, as given in ``The transitive groups of degree up
to eleven'', G.~Butler and J.~McKay, \emph{Communications in Algebra}, vol.~11,
1983,
pp.~863--911 (group $k$ is denoted $T_k$ there). And for $d \leq 7$, it was ad
hoc, so as to ensure that a given triple would denote a unique group.
Specifically, for polynomials of degree $d\leq 7$, the groups are coded as
follows, using standard notations
\smallskip
In degree 1: $S_1=[1,1,1]$.
\smallskip
In degree 2: $S_2=[2,-1,1]$.
\smallskip
In degree 3: $A_3=C_3=[3,1,1]$, $S_3=[6,-1,1]$.
\smallskip
In degree 4: $C_4=[4,-1,1]$, $V_4=[4,1,1]$, $D_4=[8,-1,1]$, $A_4=[12,1,1]$,
$S_4=[24,-1,1]$.
\smallskip
In degree 5: $C_5=[5,1,1]$, $D_5=[10,1,1]$, $M_{20}=[20,-1,1]$,
$A_5=[60,1,1]$, $S_5=[120,-1,1]$.
\smallskip
In degree 6: $C_6=[6,-1,1]$, $S_3=[6,-1,2]$, $D_6=[12,-1,1]$, $A_4=[12,1,1]$,
$G_{18}=[18,-1,1]$, $S_4^-=[24,-1,1]$, $A_4\times C_2=[24,-1,2]$,
$S_4^+=[24,1,1]$, $G_{36}^-=[36,-1,1]$, $G_{36}^+=[36,1,1]$,
$S_4\times C_2=[48,-1,1]$, $A_5=PSL_2(5)=[60,1,1]$, $G_{72}=[72,-1,1]$,
$S_5=PGL_2(5)=[120,-1,1]$, $A_6=[360,1,1]$, $S_6=[720,-1,1]$.
\smallskip
In degree 7: $C_7=[7,1,1]$, $D_7=[14,-1,1]$, $M_{21}=[21,1,1]$,
$M_{42}=[42,-1,1]$, $PSL_2(7)=PSL_3(2)=[168,1,1]$, $A_7=[2520,1,1]$,
$S_7=[5040,-1,1]$.
\smallskip
This is deprecated and obsolete, but for reasons of backward compatibility,
we cannot change this behavior yet. So you can use the default
\tet{new_galois_format} to switch to a consistent naming scheme, namely $k$ is
always the standard numbering of the group among all transitive subgroups of
$S_n$. If this default is in effect, the above groups will be coded as:
\smallskip
In degree 1: $S_1=[1,1,1]$.
\smallskip
In degree 2: $S_2=[2,-1,1]$.
\smallskip
In degree 3: $A_3=C_3=[3,1,1]$, $S_3=[6,-1,2]$.
\smallskip
In degree 4: $C_4=[4,-1,1]$, $V_4=[4,1,2]$, $D_4=[8,-1,3]$, $A_4=[12,1,4]$,
$S_4=[24,-1,5]$.
\smallskip
In degree 5: $C_5=[5,1,1]$, $D_5=[10,1,2]$, $M_{20}=[20,-1,3]$,
$A_5=[60,1,4]$, $S_5=[120,-1,5]$.
\smallskip
In degree 6: $C_6=[6,-1,1]$, $S_3=[6,-1,2]$, $D_6=[12,-1,3]$, $A_4=[12,1,4]$,
$G_{18}=[18,-1,5]$, $A_4\times C_2=[24,-1,6]$, $S_4^+=[24,1,7]$,
$S_4^-=[24,-1,8]$, $G_{36}^-=[36,-1,9]$, $G_{36}^+=[36,1,10]$,
$S_4\times C_2=[48,-1,11]$, $A_5=PSL_2(5)=[60,1,12]$, $G_{72}=[72,-1,13]$,
$S_5=PGL_2(5)=[120,-1,14]$, $A_6=[360,1,15]$, $S_6=[720,-1,16]$.
\smallskip
In degree 7: $C_7=[7,1,1]$, $D_7=[14,-1,2]$, $M_{21}=[21,1,3]$,
$M_{42}=[42,-1,4]$, $PSL_2(7)=PSL_3(2)=[168,1,5]$, $A_7=[2520,1,6]$,
$S_7=[5040,-1,7]$.
\smallskip

\misctitle{Warning} The method used is that of resolvent polynomials and is
sensitive to the current precision. The precision is updated internally but,
in very rare cases, a wrong result may be returned if the initial precision
was not sufficient.

The library syntax is \fun{GEN}{polgalois}{GEN T, long prec}.
To enable the new format in library mode,
set the global variable \tet{new_galois_format} to $1$.

\subsec{polred$(T,\{\fl=0\})$}\kbdsidx{polred}\label{se:polred}
This function is \emph{deprecated}, use \tet{polredbest} instead.
Finds polynomials with reasonably small coefficients defining subfields of
the number field defined by $T$. One of the polynomials always defines $\Q$
(hence is equal to $x-1$), and another always defines the same number field
as $T$ if $T$ is irreducible.

All $T$ accepted by \tet{nfinit} are also allowed here;
in particular, the format \kbd{[T, listP]} is recommended, e.g. with
$\kbd{listP} = 10^5$ or a vector containing all ramified primes. Otherwise,
the maximal order of $\Q[x]/(T)$ must be computed.

The following binary digits of $\fl$ are significant:

1: Possibly use a suborder of the maximal order. The
primes dividing the index of the order chosen are larger than
\tet{primelimit} or divide integers stored in the \tet{addprimes} table.
This flag is \emph{deprecated}, the \kbd{[T, listP]} format is more
flexible.

2: gives also elements. The result is a two-column matrix, the first column
giving primitive elements defining these subfields, the second giving the
corresponding minimal polynomials.
\bprog
? M = polred(x^4 + 8, 2)
%1 =
[1 x - 1]

[1/2*x^2 x^2 + 2]

[1/4*x^3 x^4 + 2]

[x x^4 + 8]
? minpoly(Mod(M[2,1], x^4+8))
%2 = x^2 + 2
@eprog

\synt{polred}{GEN T} ($\fl = 0$). Also available is
\fun{GEN}{polred2}{GEN T} ($\fl = 2$). The function \kbd{polred0} is
deprecated, provided for backward compatibility.

\subsec{polredabs$(T,\{\fl=0\})$}\kbdsidx{polredabs}\label{se:polredabs}
Returns a canonical defining polynomial $P$ for the number field
$\Q[X]/(T)$ defined by $T$, such that the sum of the squares of the modulus
of the roots (i.e.~the $T_2$-norm) is minimal. Different $T$ defining
isomorphic number fields will yield the same $P$. All $T$ accepted by
\tet{nfinit} are also allowed here, e.g. non-monic polynomials, or pairs
\kbd{[T, listP]} specifying that a non-maximal order may be used.

\misctitle{Warning 1} Using a \typ{POL} $T$ requires fully factoring the
discriminant of $T$, which may be very hard. The format \kbd{[T, listP]}
computes only a suborder of the maximal order and replaces this part of the
algorithm by a polynomial time computation. In that case the polynomial $P$
is a priori no longer canonical, and it may happen that it does not have
minimal $T_2$ norm. The routine attempts to certify the result independently
of this order computation (as per \tet{nfcertify}: we try to prove that the
order is maximal); if it fails, the routine returns $0$ instead of $P$.
In order to force an output in that case as well, you may either use
\tet{polredbest}, or \kbd{polredabs(,16)}, or
\bprog
  polredabs([T, nfbasis([T, listP])])
@eprog\noindent (In all three cases, the result is no longer canonical.)

\misctitle{Warning 2} Apart from the factorization of the discriminant of
$T$, this routine runs in polynomial time for a \emph{fixed} degree.
But the complexity is exponential in the degree: this routine
may be exceedingly slow when the number field has many subfields, hence a
lot of elements of small $T_2$-norm. If you do not need a canonical
polynomial, the function \tet{polredbest} is in general much faster (it runs
in polynomial time), and tends to return polynomials with smaller
discriminants.

The binary digits of $\fl$ mean

1: outputs a two-component row vector $[P,a]$, where $P$ is the default
output and \kbd{Mod(a, P)} is a root of the original $T$.

4: gives \emph{all} polynomials of minimal $T_2$ norm; of the two polynomials
$P(x)$ and $\pm P(-x)$, only one is given.

16: Possibly use a suborder of the maximal order, \emph{without} attempting to
certify the result as in Warning 1: we always return a polynomial and never
$0$. The result is a priori not canonical.

\bprog
? T = x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 \
      - 7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225
? T1 = polredabs(T); T2 = polredbest(T);
? [ norml2(polroots(T1)), norml2(polroots(T2)) ]
%3 = [88.0000000, 120.000000]
? [ sizedigit(poldisc(T1)), sizedigit(poldisc(T2)) ]
%4 = [75, 67]
@eprog

The library syntax is \fun{GEN}{polredabs0}{GEN T, long flag}.
Instead of the above hardcoded numerical flags, one should use an
or-ed combination of

\item \tet{nf_PARTIALFACT}: possibly use a suborder of the maximal order,
\emph{without} attempting to certify the result.

\item \tet{nf_ORIG}: return $[P, a]$, where \kbd{Mod(a, P)} is a root of $T$.

\item \tet{nf_RAW}: return $[P, b]$, where \kbd{Mod(b, T)} is a root of $P$.
The algebraic integer $b$ is the raw result produced by the small vectors
enumeration in the maximal order; $P$ was computed as the characteristic
polynomial of \kbd{Mod(b, T)}. \kbd{Mod(a, P)} as in \tet{nf_ORIG}
is obtained with \tet{modreverse}.

\item \tet{nf_ADDZK}: if $r$ is the result produced with some of the above
flags (of the form $P$ or $[P,c]$), return \kbd{[r,zk]}, where \kbd{zk} is a
$\Z$-basis for the maximal order of $\Q[X]/(P)$.

\item \tet{nf_ALL}: return a vector of results of the above form, for all
polynomials of minimal $T_2$-norm.

\subsec{polredbest$(T,\{\fl=0\})$}\kbdsidx{polredbest}\label{se:polredbest}
Finds a polynomial with reasonably
small coefficients defining the same number field as $T$.
All $T$ accepted by \tet{nfinit} are also allowed here (e.g. non-monic
polynomials, \kbd{nf}, \kbd{bnf}, \kbd{[T,Z\_K\_basis]}). Contrary to
\tet{polredabs}, this routine runs in polynomial time, but it offers no
guarantee as to the minimality of its result.

This routine computes an LLL-reduced basis for the ring of integers of
$\Q[X]/(T)$, then examines small linear combinations of the basis vectors,
computing their characteristic polynomials. It returns the \emph{separable}
$P$ polynomial of smallest discriminant (the one with lexicographically
smallest \kbd{abs(Vec(P))} in case of ties). This is a good candidate
for subsequent number field computations, since it guarantees that
the denominators of algebraic integers, when expressed in the power basis,
are reasonably small. With no claim of minimality, though.

It can happen that iterating this functions yields better and better
polynomials, until it stabilizes:
\bprog
? \p5
? P = X^12+8*X^8-50*X^6+16*X^4-3069*X^2+625;
? poldisc(P)*1.
%2 = 1.2622 E55
? P = polredbest(P);
? poldisc(P)*1.
%4 = 2.9012 E51
? P = polredbest(P);
? poldisc(P)*1.
%6 = 8.8704 E44
@eprog\noindent In this example, the initial polynomial $P$ is the one
returned by \tet{polredabs}, and the last one is stable.

If $\fl = 1$: outputs a two-component row vector $[P,a]$,  where $P$ is the
default output and \kbd{Mod(a, P)} is a root of the original $T$.
\bprog
? [P,a] = polredbest(x^4 + 8, 1)
%1 = [x^4 + 2, Mod(x^3, x^4 + 2)]
? charpoly(a)
%2 = x^4 + 8
@eprog\noindent In particular, the map $\Q[x]/(T) \to \Q[x]/(P)$,
$x\mapsto \kbd{Mod(a,P)}$ defines an isomorphism of number fields, which can
be computed as
\bprog
  subst(lift(Q), 'x, a)
@eprog\noindent if $Q$ is a \typ{POLMOD} modulo $T$; \kbd{b = modreverse(a)}
returns a \typ{POLMOD} giving the inverse of the above map (which should be
useless since $\Q[x]/(P)$ is a priori a better representation for the number
field and its elements).

The library syntax is \fun{GEN}{polredbest}{GEN T, long flag}.

\subsec{polredord$(x)$}\kbdsidx{polredord}\label{se:polredord}
Finds polynomials with reasonably small
coefficients and of the same degree as that of $x$ defining suborders of the
order defined by $x$. One of the polynomials always defines $\Q$ (hence
is equal to $(x-1)^n$, where $n$ is the degree), and another always defines
the same order as $x$ if $x$ is irreducible. Useless function: try
\kbd{polredbest}.

The library syntax is \fun{GEN}{polredord}{GEN x}.

\subsec{poltschirnhaus$(x)$}\kbdsidx{poltschirnhaus}\label{se:poltschirnhaus}
Applies a random Tschirnhausen
transformation to the polynomial $x$, which is assumed to be non-constant
and separable, so as to obtain a new equation for the \'etale algebra
defined by $x$. This is for instance useful when computing resolvents,
hence is used by the \kbd{polgalois} function.

The library syntax is \fun{GEN}{tschirnhaus}{GEN x}.

\subsec{rnfalgtobasis$(\var{rnf},x)$}\kbdsidx{rnfalgtobasis}\label{se:rnfalgtobasis}
Expresses $x$ on the relative
integral basis. Here, $\var{rnf}$ is a relative number field extension $L/K$
as output by \kbd{rnfinit}, and $x$ an element of $L$ in absolute form, i.e.
expressed as a polynomial or polmod with polmod coefficients, \emph{not} on
the relative integral basis.

The library syntax is \fun{GEN}{rnfalgtobasis}{GEN rnf, GEN x}.

\subsec{rnfbasis$(\var{bnf},M)$}\kbdsidx{rnfbasis}\label{se:rnfbasis}
Let $K$ the field represented by
\var{bnf}, as output by \kbd{bnfinit}. $M$ is a projective $\Z_K$-module
of rank $n$ ($M\otimes K$ is an $n$-dimensional $K$-vector space), given by a
pseudo-basis of size $n$. The routine returns either a true $\Z_K$-basis of
$M$ (of size $n$) if it exists, or an $n+1$-element generating set of $M$ if
not.

It is allowed to use an irreducible polynomial $P$ in $K[X]$ instead of $M$,
in which case, $M$ is defined as the ring of integers of $K[X]/(P)$, viewed
as a $\Z_K$-module.

The library syntax is \fun{GEN}{rnfbasis}{GEN bnf, GEN M}.

\subsec{rnfbasistoalg$(\var{rnf},x)$}\kbdsidx{rnfbasistoalg}\label{se:rnfbasistoalg}
Computes the representation of $x$
as a polmod with polmods coefficients. Here, $\var{rnf}$ is a relative number
field extension $L/K$ as output by \kbd{rnfinit}, and $x$ an element of
$L$ expressed on the relative integral basis.

The library syntax is \fun{GEN}{rnfbasistoalg}{GEN rnf, GEN x}.

\subsec{rnfcharpoly$(\var{nf},T,a,\{\var{var}='x\})$}\kbdsidx{rnfcharpoly}\label{se:rnfcharpoly}
Characteristic polynomial of
$a$ over $\var{nf}$, where $a$ belongs to the algebra defined by $T$ over
$\var{nf}$, i.e.~$\var{nf}[X]/(T)$. Returns a polynomial in variable $v$
($x$ by default).
\bprog
? nf = nfinit(y^2+1);
? rnfcharpoly(nf, x^2+y*x+1, x+y)
%2 = x^2 + Mod(-y, y^2 + 1)*x + 1
@eprog

The library syntax is \fun{GEN}{rnfcharpoly}{GEN nf, GEN T, GEN a, long var = -1}, where \kbd{var} is a variable number.

\subsec{rnfconductor$(\var{bnf},\var{pol})$}\kbdsidx{rnfconductor}\label{se:rnfconductor}
Given $\var{bnf}$
as output by \kbd{bnfinit}, and \var{pol} a relative polynomial defining an
\idx{Abelian extension}, computes the class field theory conductor of this
Abelian extension. The result is a 3-component vector
$[\var{conductor},\var{rayclgp},\var{subgroup}]$, where \var{conductor} is
the conductor of the extension given as a 2-component row vector
$[f_0,f_\infty]$, \var{rayclgp} is the full ray class group corresponding to
the conductor given as a 3-component vector [h,cyc,gen] as usual for a group,
and \var{subgroup} is a matrix in HNF defining the subgroup of the ray class
group on the given generators gen.

The library syntax is \fun{GEN}{rnfconductor}{GEN bnf, GEN pol}.

\subsec{rnfdedekind$(\var{nf},\var{pol},\{\var{pr}\},\{\fl=0\})$}\kbdsidx{rnfdedekind}\label{se:rnfdedekind}
Given a number field $K$ coded by $\var{nf}$ and a monic
polynomial $P\in \Z_K[X]$, irreducible over $K$ and thus defining a relative
extension $L$ of $K$, applies \idx{Dedekind}'s criterion to the order
$\Z_K[X]/(P)$, at the prime ideal \var{pr}. It is possible to set \var{pr}
to a vector of prime ideals (test maximality at all primes in the vector),
or to omit altogether, in which case maximality at \emph{all} primes is tested;
in this situation \fl\ is automatically set to $1$.

The default historic behavior (\fl\ is 0 or omitted and \var{pr} is a
single prime ideal) is not so useful since
\kbd{rnfpseudobasis} gives more information and is generally not that
much slower. It returns a 3-component vector $[\var{max}, \var{basis}, v]$:

\item \var{basis} is a pseudo-basis of an enlarged order $O$ produced by
Dedekind's criterion, containing the original order $\Z_K[X]/(P)$
with index a power of \var{pr}. Possibly equal to the original order.

\item \var{max} is a flag equal to 1 if the enlarged order $O$
could be proven to be \var{pr}-maximal and to 0 otherwise; it may still be
maximal in the latter case if \var{pr} is ramified in $L$,

\item $v$ is the valuation at \var{pr} of the order discriminant.

If \fl\ is non-zero, on the other hand, we just return $1$ if the order
$\Z_K[X]/(P)$ is \var{pr}-maximal (resp.~maximal at all relevant primes, as
described above), and $0$ if not. This is much faster than the default,
since the enlarged order is not computed.
\bprog
? nf = nfinit(y^2-3); P = x^3 - 2*y;
? pr3 = idealprimedec(nf,3)[1];
? rnfdedekind(nf, P, pr3)
%2 = [1, [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, 1]], 8]
? rnfdedekind(nf, P, pr3, 1)
%3 = 1
@eprog\noindent In this example, \kbd{pr3} is the ramified ideal above $3$,
and the order generated by the cube roots of $y$ is already
\kbd{pr3}-maximal. The order-discriminant has valuation $8$. On the other
hand, the order is not maximal at the prime above 2:
\bprog
? pr2 = idealprimedec(nf,2)[1];
? rnfdedekind(nf, P, pr2, 1)
%5 = 0
? rnfdedekind(nf, P, pr2)
%6 = [0, [[2, 0, 0; 0, 1, 0; 0, 0, 1], [[1, 0; 0, 1], [1, 0; 0, 1],
     [1, 1/2; 0, 1/2]]], 2]
@eprog
The enlarged order is not proven to be \kbd{pr2}-maximal yet. In fact, it
is; it is in fact the maximal order:
\bprog
? B = rnfpseudobasis(nf, P)
%7 = [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, [1, 1/2; 0, 1/2]],
     [162, 0; 0, 162], -1]
? idealval(nf,B[3], pr2)
%4 = 2
@eprog\noindent
It is possible to use this routine with non-monic
$P = \sum_{i\leq n} a_i X^i \in \Z_K[X]$ if $\fl = 1$;
in this case, we test maximality of Dedekind's order generated by
$$1, a_n \alpha, a_n\alpha^2 + a_{n-1}\alpha, \dots,
a_n\alpha^{n-1} + a_{n-1}\alpha^{n-2} + \cdots + a_1\alpha.$$
The routine will fail if $P$ is $0$ on the projective line over the residue
field $\Z_K/\kbd{pr}$ (FIXME).

The library syntax is \fun{GEN}{rnfdedekind}{GEN nf, GEN pol, GEN pr = NULL, long flag}.

\subsec{rnfdet$(\var{nf},M)$}\kbdsidx{rnfdet}\label{se:rnfdet}
Given a pseudo-matrix $M$ over the maximal
order of $\var{nf}$, computes its determinant.

The library syntax is \fun{GEN}{rnfdet}{GEN nf, GEN M}.

\subsec{rnfdisc$(\var{nf},\var{pol})$}\kbdsidx{rnfdisc}\label{se:rnfdisc}
Given a number field $\var{nf}$ as
output by \kbd{nfinit} and a polynomial \var{pol} with coefficients in
$\var{nf}$ defining a relative extension $L$ of $\var{nf}$, computes the
relative discriminant of $L$. This is a two-element row vector $[D,d]$, where
$D$ is the relative ideal discriminant and $d$ is the relative discriminant
considered as an element of $\var{nf}^*/{\var{nf}^*}^2$. The main variable of
$\var{nf}$ \emph{must} be of lower priority than that of \var{pol}, see
\secref{se:priority}.

The library syntax is \fun{GEN}{rnfdiscf}{GEN nf, GEN pol}.

\subsec{rnfeltabstorel$(\var{rnf},x)$}\kbdsidx{rnfeltabstorel}\label{se:rnfeltabstorel}
$\var{rnf}$ being a relative
number field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an
element of $L$ expressed as a polynomial modulo the absolute equation
\kbd{\var{rnf}.pol}, computes $x$ as an element of the relative extension
$L/K$ as a polmod with polmod coefficients.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltabstorel(L, Mod(x, L.pol))
%3 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltabstorel(L, Mod(2, L.pol))
%4 = 2
? rnfeltabstorel(L, Mod(x, x^2-y))
 ***   at top-level: rnfeltabstorel(L,Mod
 ***                 ^--------------------
 *** rnfeltabstorel: inconsistent moduli in rnfeltabstorel: x^2-y != x^4+1
@eprog

The library syntax is \fun{GEN}{rnfeltabstorel}{GEN rnf, GEN x}.

\subsec{rnfeltdown$(\var{rnf},x)$}\kbdsidx{rnfeltdown}\label{se:rnfeltdown}
$\var{rnf}$ being a relative number
field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an element of
$L$ expressed as a polynomial or polmod with polmod coefficients, computes
$x$ as an element of $K$ as a polmod, assuming $x$ is in $K$ (otherwise a
domain error occurs).
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltdown(L, Mod(x^2, L.pol))
%3 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(y, x^2-y))
%4 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(y,K.pol))
%5 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(x, L.pol))
 ***   at top-level: rnfeltdown(L,Mod(x,x
 ***                 ^--------------------
 *** rnfeltdown: domain error in rnfeltdown: element not in the base field
@eprog

The library syntax is \fun{GEN}{rnfeltdown}{GEN rnf, GEN x}.

\subsec{rnfeltnorm$(\var{rnf},x)$}\kbdsidx{rnfeltnorm}\label{se:rnfeltnorm}
$\var{rnf}$ being a relative number field extension $L/K$ as output by
\kbd{rnfinit} and $x$ being an element of $L$, returns the relative norm
$N_{L/K}(x)$ as an element of $K$.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfeltnorm(L, Mod(x, L.pol))
%2 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltnorm(L, 2)
%3 = 4
? rnfeltnorm(L, Mod(x, x^2-y))
@eprog

The library syntax is \fun{GEN}{rnfeltnorm}{GEN rnf, GEN x}.

\subsec{rnfeltreltoabs$(\var{rnf},x)$}\kbdsidx{rnfeltreltoabs}\label{se:rnfeltreltoabs}
$\var{rnf}$ being a relative
number field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an
element of $L$ expressed as a polynomial or polmod with polmod
coefficients, computes $x$ as an element of the absolute extension $L/\Q$ as
a polynomial modulo the absolute equation \kbd{\var{rnf}.pol}.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltreltoabs(L, Mod(x, L.pol))
%3 = Mod(x, x^4 + 1)
? rnfeltreltoabs(L, Mod(y, x^2-y))
%4 = Mod(x^2, x^4 + 1)
? rnfeltreltoabs(L, Mod(y,K.pol))
%5 = Mod(x^2, x^4 + 1)
@eprog

The library syntax is \fun{GEN}{rnfeltreltoabs}{GEN rnf, GEN x}.

\subsec{rnfelttrace$(\var{rnf},x)$}\kbdsidx{rnfelttrace}\label{se:rnfelttrace}
$\var{rnf}$ being a relative number field extension $L/K$ as output by
\kbd{rnfinit} and $x$ being an element of $L$, returns the relative trace
$N_{L/K}(x)$ as an element of $K$.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfelttrace(L, Mod(x, L.pol))
%2 = 0
? rnfelttrace(L, 2)
%3 = 4
? rnfelttrace(L, Mod(x, x^2-y))
@eprog

The library syntax is \fun{GEN}{rnfelttrace}{GEN rnf, GEN x}.

\subsec{rnfeltup$(\var{rnf},x)$}\kbdsidx{rnfeltup}\label{se:rnfeltup}
$\var{rnf}$ being a relative number field extension $L/K$ as output by
\kbd{rnfinit} and $x$ being an element of $K$, computes $x$ as an element of
the absolute extension $L/\Q$ as a polynomial modulo the absolute equation
\kbd{\var{rnf}.pol}.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltup(L, Mod(y, K.pol))
%4 = Mod(x^2, x^4 + 1)
? rnfeltup(L, y)
%5 = Mod(x^2, x^4 + 1)
? rnfeltup(L, [1,2]~) \\ in terms of K.zk
%6 = Mod(2*x^2 + 1, x^4 + 1)
@eprog

The library syntax is \fun{GEN}{rnfeltup}{GEN rnf, GEN x}.

\subsec{rnfequation$(\var{nf},\var{pol},\{\fl=0\})$}\kbdsidx{rnfequation}\label{se:rnfequation}
Given a number field
$\var{nf}$ as output by \kbd{nfinit} (or simply a polynomial) and a
polynomial \var{pol} with coefficients in $\var{nf}$ defining a relative
extension $L$ of $\var{nf}$, computes an absolute equation of $L$ over
$\Q$.

The main variable of $\var{nf}$ \emph{must} be of lower priority than that
of \var{pol} (see \secref{se:priority}). Note that for efficiency, this does
not check whether the relative equation is irreducible over $\var{nf}$, but
only if it is squarefree. If it is reducible but squarefree, the result will
be the absolute equation of the \'etale algebra defined by \var{pol}. If
\var{pol} is not squarefree, raise an \kbd{e\_DOMAIN} exception.
\bprog
? rnfequation(y^2+1, x^2 - y)
%1 = x^4 + 1
? T = y^3-2; rnfequation(nfinit(T), (x^3-2)/(x-Mod(y,T)))
%2 = x^6 + 108  \\ Galois closure of Q(2^(1/3))
@eprog

If $\fl$ is non-zero, outputs a 3-component row vector $[z,a,k]$, where

\item $z$ is the absolute equation of $L$ over $\Q$, as in the default
behavior,

\item $a$ expresses as a \typ{POLMOD} modulo $z$ a root $\alpha$ of the
polynomial defining the base field $\var{nf}$,

\item $k$ is a small integer such that $\theta = \beta+k\alpha$
is a root of $z$, where $\beta$ is a root of $\var{pol}$.
\bprog
? T = y^3-2; pol = x^2 +x*y + y^2;
? [z,a,k] = rnfequation(T, pol, 1);
? z
%4 = x^6 + 108
? subst(T, y, a)
%5 = 0
? alpha= Mod(y, T);
? beta = Mod(x*Mod(1,T), pol);
? subst(z, x, beta + k*alpha)
%8 = 0
@eprog

The library syntax is \fun{GEN}{rnfequation0}{GEN nf, GEN pol, long flag}.
Also available are
\fun{GEN}{rnfequation}{GEN nf, GEN pol} ($\fl = 0$) and
\fun{GEN}{rnfequation2}{GEN nf, GEN pol} ($\fl = 1$).

\subsec{rnfhnfbasis$(\var{bnf},x)$}\kbdsidx{rnfhnfbasis}\label{se:rnfhnfbasis}
Given $\var{bnf}$ as output by
\kbd{bnfinit}, and either a polynomial $x$ with coefficients in $\var{bnf}$
defining a relative extension $L$ of $\var{bnf}$, or a pseudo-basis $x$ of
such an extension, gives either a true $\var{bnf}$-basis of $L$ in upper
triangular Hermite normal form, if it exists, and returns $0$ otherwise.

The library syntax is \fun{GEN}{rnfhnfbasis}{GEN bnf, GEN x}.

\subsec{rnfidealabstorel$(\var{rnf},x)$}\kbdsidx{rnfidealabstorel}\label{se:rnfidealabstorel}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and $x$ be an ideal of
the absolute extension $L/\Q$ given by a $\Z$-basis of elements of $L$.
Returns the relative pseudo-matrix in HNF giving the ideal $x$ considered as
an ideal of the relative extension $L/K$, i.e.~as a $\Z_K$-module.

The reason why the input does not use the customary HNF in terms of a fixed
$\Z$-basis for $\Z_L$ is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) \var{nf}
structure \kbd{Labs} associated to $L$, and $m$ is in HNF, defining
an (absolute) ideal with respect to the $\Z$-basis \kbd{Labs.zk}, then
\kbd{Labs.zk * m} is a suitable $\Z$-basis for the ideal, and
\bprog
  rnfidealabstorel(rnf, Labs.zk * m)
@eprog\noindent converts $m$ to a relative ideal.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y); Labs = nfinit(L.pol);
? m = idealhnf(Labs, 17, x^3+2);
? B = rnfidealabstorel(L, Labs.zk * m)
%3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]]  \\ pseudo-basis for m as Z_K-module
? A = rnfidealreltoabs(L, B)
%4 = [17, x^2 + 4, x + 8, x^3 + 8*x^2]   \\ Z-basis for m in Q[x]/(L.pol)
? mathnf(matalgtobasis(Labs, A))
%5 =
[17 8 4 2]

[ 0 1 0 0]

[ 0 0 1 0]

[ 0 0 0 1]
? % == m
%6 = 1
@eprog

The library syntax is \fun{GEN}{rnfidealabstorel}{GEN rnf, GEN x}.

\subsec{rnfidealdown$(\var{rnf},x)$}\kbdsidx{rnfidealdown}\label{se:rnfidealdown}
Let $\var{rnf}$ be a relative number
field extension $L/K$ as output by \kbd{rnfinit}, and $x$ an ideal of
$L$, given either in relative form or by a $\Z$-basis of elements of $L$
(see \secref{se:rnfidealabstorel}). This function returns the ideal of $K$
below $x$, i.e.~the intersection of $x$ with $K$.

The library syntax is \fun{GEN}{rnfidealdown}{GEN rnf, GEN x}.

\subsec{rnfidealhnf$(\var{rnf},x)$}\kbdsidx{rnfidealhnf}\label{se:rnfidealhnf}
$\var{rnf}$ being a relative number
field extension $L/K$ as output by \kbd{rnfinit} and $x$ being a relative
ideal (which can be, as in the absolute case, of many different types,
including of course elements), computes the HNF pseudo-matrix associated to
$x$, viewed as a $\Z_K$-module.

The library syntax is \fun{GEN}{rnfidealhnf}{GEN rnf, GEN x}.

\subsec{rnfidealmul$(\var{rnf},x,y)$}\kbdsidx{rnfidealmul}\label{se:rnfidealmul}
$\var{rnf}$ being a relative number
field extension $L/K$ as output by \kbd{rnfinit} and $x$ and $y$ being ideals
of the relative extension $L/K$ given by pseudo-matrices, outputs the ideal
product, again as a relative ideal.

The library syntax is \fun{GEN}{rnfidealmul}{GEN rnf, GEN x, GEN y}.

\subsec{rnfidealnormabs$(\var{rnf},x)$}\kbdsidx{rnfidealnormabs}\label{se:rnfidealnormabs}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the norm of the
$x$ considered as an ideal of the absolute extension $L/\Q$. This is
identical to
\bprog
   idealnorm(rnf, rnfidealnormrel(rnf,x))
@eprog\noindent but faster.

The library syntax is \fun{GEN}{rnfidealnormabs}{GEN rnf, GEN x}.

\subsec{rnfidealnormrel$(\var{rnf},x)$}\kbdsidx{rnfidealnormrel}\label{se:rnfidealnormrel}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the relative
norm of $x$ as an ideal of $K$ in HNF.

The library syntax is \fun{GEN}{rnfidealnormrel}{GEN rnf, GEN x}.

\subsec{rnfidealreltoabs$(\var{rnf},x)$}\kbdsidx{rnfidealreltoabs}\label{se:rnfidealreltoabs}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be a
relative ideal, given as a $\Z_K$-module by a pseudo matrix $[A,I]$.
This function returns the ideal $x$ as an absolute ideal of $L/\Q$ in
the form of a $\Z$-basis, given by a vector of polynomials (modulo
\kbd{rnf.pol}).

The reason why we do not return the customary HNF in terms of a fixed
$\Z$-basis for $\Z_L$ is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) \var{nf}
structure \kbd{Labs} associated to $L$, then
\bprog
  xabs = rnfidealreltoabs(L, x);
  xLabs = mathnf(matalgtobasis(Labs, xabs));
@eprog\noindent computes a traditional HNF \kbd{xLabs} for $x$ in terms of
the fixed $\Z$-basis \kbd{Labs.zk}.

The library syntax is \fun{GEN}{rnfidealreltoabs}{GEN rnf, GEN x}.

\subsec{rnfidealtwoelt$(\var{rnf},x)$}\kbdsidx{rnfidealtwoelt}\label{se:rnfidealtwoelt}
$\var{rnf}$ being a relative
number field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an
ideal of the relative extension $L/K$ given by a pseudo-matrix, gives a
vector of two generators of $x$ over $\Z_L$ expressed as polmods with polmod
coefficients.

The library syntax is \fun{GEN}{rnfidealtwoelement}{GEN rnf, GEN x}.

\subsec{rnfidealup$(\var{rnf},x)$}\kbdsidx{rnfidealup}\label{se:rnfidealup}
Let $\var{rnf}$ be a relative number
field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be an ideal of
$K$. This function returns the ideal $x\Z_L$ as an absolute ideal of $L/\Q$,
in the form of a $\Z$-basis, given by a vector of polynomials (modulo
\kbd{rnf.pol}).

The reason why we do not return the customary HNF in terms of a fixed
$\Z$-basis for $\Z_L$ is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) \var{nf}
structure \kbd{Labs} associated to $L$, then
\bprog
  xabs = rnfidealup(L, x);
  xLabs = mathnf(matalgtobasis(Labs, xabs));
@eprog\noindent computes a traditional HNF \kbd{xLabs} for $x$ in terms of
the fixed $\Z$-basis \kbd{Labs.zk}.

The library syntax is \fun{GEN}{rnfidealup}{GEN rnf, GEN x}.

\subsec{rnfinit$(\var{nf},\var{pol})$}\kbdsidx{rnfinit}\label{se:rnfinit}
$\var{nf}$ being a number field in \kbd{nfinit}
format considered as base field, and \var{pol} a polynomial defining a relative
extension over $\var{nf}$, this computes data to work in the
relative extension. The main variable of \var{pol} must be of higher priority
(see \secref{se:priority}) than that of $\var{nf}$, and the coefficients of
\var{pol} must be in $\var{nf}$.

The result is a row vector, whose components are technical. In the following
description, we let $K$ be the base field defined by $\var{nf}$ and $L/K$
the large field associated to the \var{rnf}. Furthermore, we let
$m = [K:\Q]$ the degree of the base field, $n = [L:K]$ the relative degree,
$r_1$ and $r_2$ the number of real and complex places of $K$. Access to this
information via \emph{member functions} is preferred since the specific
data organization specified below will change in the future.

$\var{rnf}[1]$(\kbd{rnf.pol}) contains the relative polynomial \var{pol}.

$\var{rnf}[2]$ contains the integer basis $[A,d]$ of $K$, as
(integral) elements of $L/\Q$. More precisely, $A$ is a vector of
polynomial with integer coefficients, $d$ is a denominator, and the integer
basis is given by $A/d$.

$\var{rnf}[3]$ (\kbd{rnf.disc}) is a two-component row vector
$[\goth{d}(L/K),s]$ where $\goth{d}(L/K)$ is the relative ideal discriminant
of $L/K$ and $s$ is the discriminant of $L/K$ viewed as an element of
$K^*/(K^*)^2$, in other words it is the output of \kbd{rnfdisc}.

$\var{rnf}[4]$(\kbd{rnf.index}) is the ideal index $\goth{f}$, i.e.~such
that $d(pol)\Z_K=\goth{f}^2\goth{d}(L/K)$.

$\var{rnf}[5]$ is currently unused.

$\var{rnf}[6]$ is currently unused.

$\var{rnf}[7]$ (\kbd{rnf.zk}) is the pseudo-basis $(A,I)$ for the maximal
order $\Z_L$ as a $\Z_K$-module: $A$ is the relative integral pseudo basis
expressed as polynomials (in the variable of $pol$) with polmod coefficients
in $\var{nf}$, and the second component $I$ is the ideal list of the
pseudobasis in HNF.

$\var{rnf}[8]$ is the inverse matrix of the integral basis matrix, with
coefficients polmods in $\var{nf}$.

$\var{rnf}[9]$ is currently unused.

$\var{rnf}[10]$ (\kbd{rnf.nf}) is $\var{nf}$.

$\var{rnf}[11]$ is the output of \kbd{rnfequation(K, pol, 1)}. Namely, a
vector $[P, a, k]$ describing the \emph{absolute} extension
$L/\Q$: $P$ is an absolute equation, more conveniently obtained
as \kbd{rnf.polabs}; $a$ expresses the generator $\alpha = y \mod \kbd{K.pol}$
of the number field $K$ as an element of $L$, i.e.~a polynomial modulo the
absolute equation $P$;

$k$ is a small integer such that, if $\beta$ is an abstract root of \var{pol}
and $\alpha$ the generator of $K$ given above, then $P(\beta + k\alpha) = 0$.

\misctitle{Caveat.} Be careful if $k\neq0$ when dealing simultaneously with
absolute and relative quantities since $L = \Q(\beta + k\alpha) =
K(\alpha)$, and the generator chosen for the absolute extension is not the
same as for the relative one. If this happens, one can of course go on
working, but we advise to change the relative polynomial so that its root
becomes $\beta + k \alpha$. Typical GP instructions would be
\bprog
  [P,a,k] = rnfequation(K, pol, 1);
  if (k, pol = subst(pol, x, x - k*Mod(y, K.pol)));
  L = rnfinit(K, pol);
@eprog

$\var{rnf}[12]$ is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available (which
is rarely needed, hence would be too expensive to compute during the initial
\kbd{rnfinit} call).

The library syntax is \fun{GEN}{rnfinit}{GEN nf, GEN pol}.

\subsec{rnfisabelian$(\var{nf},T)$}\kbdsidx{rnfisabelian}\label{se:rnfisabelian}
$T$ being a relative polynomial with coefficients
in \var{nf}, return 1 if it defines an abelian extension, and 0 otherwise.
\bprog
? K = nfinit(y^2 + 23);
? rnfisabelian(K, x^3 - 3*x - y)
%2 = 1
@eprog

The library syntax is \fun{long}{rnfisabelian}{GEN nf, GEN T}.

\subsec{rnfisfree$(\var{bnf},x)$}\kbdsidx{rnfisfree}\label{se:rnfisfree}
Given $\var{bnf}$ as output by
\kbd{bnfinit}, and either a polynomial $x$ with coefficients in $\var{bnf}$
defining a relative extension $L$ of $\var{bnf}$, or a pseudo-basis $x$ of
such an extension, returns true (1) if $L/\var{bnf}$ is free, false (0) if
not.

The library syntax is \fun{long}{rnfisfree}{GEN bnf, GEN x}.

\subsec{rnfisnorm$(T,a,\{\fl=0\})$}\kbdsidx{rnfisnorm}\label{se:rnfisnorm}
Similar to
\kbd{bnfisnorm} but in the relative case. $T$ is as output by
\tet{rnfisnorminit} applied to the extension $L/K$. This tries to decide
whether the element $a$ in $K$ is the norm of some $x$ in the extension
$L/K$.

The output is a vector $[x,q]$, where $a = \Norm(x)*q$. The
algorithm looks for a solution $x$ which is an $S$-integer, with $S$ a list
of places of $K$ containing at least the ramified primes, the generators of
the class group of $L$, as well as those primes dividing $a$. If $L/K$ is
Galois, then this is enough; otherwise, $\fl$ is used to add more primes to
$S$: all the places above the primes $p \leq \fl$ (resp.~$p|\fl$) if $\fl>0$
(resp.~$\fl<0$).

The answer is guaranteed (i.e.~$a$ is a norm iff $q = 1$) if the field is
Galois, or, under \idx{GRH}, if $S$ contains all primes less than
$12\log^2\left|\disc(M)\right|$, where $M$ is the normal
closure of $L/K$.

If \tet{rnfisnorminit} has determined (or was told) that $L/K$ is
\idx{Galois}, and $\fl \neq 0$, a Warning is issued (so that you can set
$\fl = 1$ to check whether $L/K$ is known to be Galois, according to $T$).
Example:

\bprog
bnf = bnfinit(y^3 + y^2 - 2*y - 1);
p = x^2 + Mod(y^2 + 2*y + 1, bnf.pol);
T = rnfisnorminit(bnf, p);
rnfisnorm(T, 17)
@eprog\noindent
checks whether $17$ is a norm in the Galois extension $\Q(\beta) /
\Q(\alpha)$, where $\alpha^3 + \alpha^2 - 2\alpha - 1 = 0$ and $\beta^2 +
\alpha^2 + 2\alpha + 1 = 0$ (it is).

The library syntax is \fun{GEN}{rnfisnorm}{GEN T, GEN a, long flag}.

\subsec{rnfisnorminit$(\var{pol},\var{polrel},\{\fl=2\})$}\kbdsidx{rnfisnorminit}\label{se:rnfisnorminit}
Let $K$ be defined by a root of \var{pol}, and $L/K$ the extension defined
by the polynomial \var{polrel}. As usual, \var{pol} can in fact be an \var{nf},
or \var{bnf}, etc; if \var{pol} has degree $1$ (the base field is $\Q$),
polrel is also allowed to be an \var{nf}, etc. Computes technical data needed
by \tet{rnfisnorm} to solve norm equations $Nx = a$, for $x$ in $L$, and $a$
in $K$.

If $\fl = 0$, do not care whether $L/K$ is Galois or not.

If $\fl = 1$, $L/K$ is assumed to be Galois (unchecked), which speeds up
\tet{rnfisnorm}.

If $\fl = 2$, let the routine determine whether $L/K$ is Galois.

The library syntax is \fun{GEN}{rnfisnorminit}{GEN pol, GEN polrel, long flag}.

\subsec{rnfkummer$(\var{bnr},\{\var{subgp}\},\{d=0\})$}\kbdsidx{rnfkummer}\label{se:rnfkummer}
\var{bnr}
being as output by \kbd{bnrinit}, finds a relative equation for the
class field corresponding to the module in \var{bnr} and the given
congruence subgroup (the full ray class field if \var{subgp} is omitted).
If $d$ is positive, outputs the list of all relative equations of
degree $d$ contained in the ray class field defined by \var{bnr}, with
the \emph{same} conductor as $(\var{bnr}, \var{subgp})$.

\misctitle{Warning} This routine only works for subgroups of prime index. It
uses Kummer theory, adjoining necessary roots of unity (it needs to compute a
tough \kbd{bnfinit} here), and finds a generator via Hecke's characterization
of ramification in Kummer extensions of prime degree. If your extension does
not have prime degree, for the time being, you have to split it by hand as a
tower / compositum of such extensions.

The library syntax is \fun{GEN}{rnfkummer}{GEN bnr, GEN subgp = NULL, long d, long prec}.

\subsec{rnflllgram$(\var{nf},\var{pol},\var{order})$}\kbdsidx{rnflllgram}\label{se:rnflllgram}
Given a polynomial
\var{pol} with coefficients in \var{nf} defining a relative extension $L$ and
a suborder \var{order} of $L$ (of maximal rank), as output by
\kbd{rnfpseudobasis}$(\var{nf},\var{pol})$ or similar, gives
$[[\var{neworder}],U]$, where \var{neworder} is a reduced order and $U$ is
the unimodular transformation matrix.

The library syntax is \fun{GEN}{rnflllgram}{GEN nf, GEN pol, GEN order, long prec}.

\subsec{rnfnormgroup$(\var{bnr},\var{pol})$}\kbdsidx{rnfnormgroup}\label{se:rnfnormgroup}
\var{bnr} being a big ray
class field as output by \kbd{bnrinit} and \var{pol} a relative polynomial
defining an \idx{Abelian extension}, computes the norm group (alias Artin
or Takagi group) corresponding to the Abelian extension of
$\var{bnf}=$\kbd{bnr.bnf}
defined by \var{pol}, where the module corresponding to \var{bnr} is assumed
to be a multiple of the conductor (i.e.~\var{pol} defines a subextension of
bnr). The result is the HNF defining the norm group on the given generators
of \kbd{bnr.gen}. Note that neither the fact that \var{pol} defines an
Abelian extension nor the fact that the module is a multiple of the conductor
is checked. The result is undefined if the assumption is not correct.

The library syntax is \fun{GEN}{rnfnormgroup}{GEN bnr, GEN pol}.

\subsec{rnfpolred$(\var{nf},\var{pol})$}\kbdsidx{rnfpolred}\label{se:rnfpolred}
THIS FUNCTION IS OBSOLETE: use \tet{rnfpolredbest} instead.
Relative version of \kbd{polred}. Given a monic polynomial \var{pol} with
coefficients in $\var{nf}$, finds a list of relative polynomials defining some
subfields, hopefully simpler and containing the original field. In the present
version \vers, this is slower and less efficient than \kbd{rnfpolredbest}.

\misctitle{Remark} this function is based on an incomplete reduction
theory of lattices over number fields, implemented by \kbd{rnflllgram}, which
deserves to be improved.

The library syntax is \fun{GEN}{rnfpolred}{GEN nf, GEN pol, long prec}.

\subsec{rnfpolredabs$(\var{nf},\var{pol},\{\fl=0\})$}\kbdsidx{rnfpolredabs}\label{se:rnfpolredabs}
THIS FUNCTION IS OBSOLETE: use \tet{rnfpolredbest} instead.
Relative version of \kbd{polredabs}. Given a monic polynomial \var{pol}
with coefficients in $\var{nf}$, finds a simpler relative polynomial defining
the same field. The binary digits of $\fl$ mean

The binary digits of $\fl$ correspond to $1$: add information to convert
elements to the new representation, $2$: absolute polynomial, instead of
relative, $16$: possibly use a suborder of the maximal order. More precisely:

0: default, return $P$

1: returns $[P,a]$ where $P$ is the default output and $a$,
a \typ{POLMOD} modulo $P$, is a root of \var{pol}.

2: returns \var{Pabs}, an absolute, instead of a relative, polynomial.
Same as but faster than
\bprog
  rnfequation(nf, rnfpolredabs(nf,pol))
@eprog

3: returns $[\var{Pabs},a,b]$, where \var{Pabs} is an absolute polynomial
as above, $a$, $b$ are \typ{POLMOD} modulo \var{Pabs}, roots of \kbd{nf.pol}
and \var{pol} respectively.

16: possibly use a suborder of the maximal order. This is slower than the
default when the relative discriminant is smooth, and much faster otherwise.
See \secref{se:polredabs}.

\misctitle{Warning} In the present implementation, \kbd{rnfpolredabs}
produces smaller polynomials than \kbd{rnfpolred} and is usually
faster, but its complexity is still exponential in the absolute degree.
The function \tet{rnfpolredbest} runs in polynomial time, and  tends  to
return polynomials with smaller discriminants.

The library syntax is \fun{GEN}{rnfpolredabs}{GEN nf, GEN pol, long flag}.

\subsec{rnfpolredbest$(\var{nf},\var{pol},\{\fl=0\})$}\kbdsidx{rnfpolredbest}\label{se:rnfpolredbest}
Relative version of \kbd{polredbest}. Given a monic polynomial \var{pol}
with coefficients in $\var{nf}$, finds a simpler relative polynomial $P$
defining the same field. As opposed to \tet{rnfpolredabs} this function does
not return a \emph{smallest} (canonical) polynomial with respect to some
measure, but it does run in polynomial time.

The binary digits of $\fl$ correspond to $1$: add information to convert
elements to the new representation, $2$: absolute polynomial, instead of
relative. More precisely:

0: default, return $P$

1: returns $[P,a]$ where $P$ is the default output and $a$,
a \typ{POLMOD} modulo $P$, is a root of \var{pol}.

2: returns \var{Pabs}, an absolute, instead of a relative, polynomial.
Same as but faster than
\bprog
  rnfequation(nf, rnfpolredbest(nf,pol))
@eprog

3: returns $[\var{Pabs},a,b]$, where \var{Pabs} is an absolute polynomial
as above, $a$, $b$ are \typ{POLMOD} modulo \var{Pabs}, roots of \kbd{nf.pol}
and \var{pol} respectively.

\bprog
? K = nfinit(y^3-2); pol = x^2 +x*y + y^2;
? [P, a] = rnfpolredbest(K,pol,1);
? P
%3 = x^2 - x + Mod(y - 1, y^3 - 2)
? a
%4 = Mod(Mod(2*y^2+3*y+4,y^3-2)*x + Mod(-y^2-2*y-2,y^3-2),
         x^2 - x + Mod(y-1,y^3-2))
? subst(K.pol,y,a)
%5 = 0
? [Pabs, a, b] = rnfpolredbest(K,pol,3);
? Pabs
%7 = x^6 - 3*x^5 + 5*x^3 - 3*x + 1
? a
%8 = Mod(-x^2+x+1, x^6-3*x^5+5*x^3-3*x+1)
? b
%9 = Mod(2*x^5-5*x^4-3*x^3+10*x^2+5*x-5, x^6-3*x^5+5*x^3-3*x+1)
? subst(K.pol,y,a)
%10 = 0
? substvec(pol,[x,y],[a,b])
%11 = 0
@eprog

The library syntax is \fun{GEN}{rnfpolredbest}{GEN nf, GEN pol, long flag}.

\subsec{rnfpseudobasis$(\var{nf},\var{pol})$}\kbdsidx{rnfpseudobasis}\label{se:rnfpseudobasis}
Given a number field
$\var{nf}$ as output by \kbd{nfinit} and a polynomial \var{pol} with
coefficients in $\var{nf}$ defining a relative extension $L$ of $\var{nf}$,
computes a pseudo-basis $(A,I)$ for the maximal order $\Z_L$ viewed as a
$\Z_K$-module, and the relative discriminant of $L$. This is output as a
four-element row vector $[A,I,D,d]$, where $D$ is the relative ideal
discriminant and $d$ is the relative discriminant considered as an element of
$\var{nf}^*/{\var{nf}^*}^2$.

The library syntax is \fun{GEN}{rnfpseudobasis}{GEN nf, GEN pol}.

\subsec{rnfsteinitz$(\var{nf},x)$}\kbdsidx{rnfsteinitz}\label{se:rnfsteinitz}
Given a number field $\var{nf}$ as
output by \kbd{nfinit} and either a polynomial $x$ with coefficients in
$\var{nf}$ defining a relative extension $L$ of $\var{nf}$, or a pseudo-basis
$x$ of such an extension as output for example by \kbd{rnfpseudobasis},
computes another pseudo-basis $(A,I)$ (not in HNF in general) such that all
the ideals of $I$ except perhaps the last one are equal to the ring of
integers of $\var{nf}$, and outputs the four-component row vector $[A,I,D,d]$
as in \kbd{rnfpseudobasis}. The name of this function comes from the fact
that the ideal class of the last ideal of $I$, which is well defined, is the
\idx{Steinitz class} of the $\Z_K$-module $\Z_L$ (its image in $SK_0(\Z_K)$).

The library syntax is \fun{GEN}{rnfsteinitz}{GEN nf, GEN x}.

\subsec{subgrouplist$(\var{bnr},\{\var{bound}\},\{\fl=0\})$}\kbdsidx{subgrouplist}\label{se:subgrouplist}
\var{bnr} being as output by \kbd{bnrinit} or a list of cyclic components
of a finite Abelian group $G$, outputs the list of subgroups of $G$. Subgroups
are given as HNF left divisors of the SNF matrix corresponding to $G$.

If $\fl=0$ (default) and \var{bnr} is as output by \kbd{bnrinit}, gives
only the subgroups whose modulus is the conductor. Otherwise, the modulus is
not taken into account.

If \var{bound} is present, and is a positive integer, restrict the output to
subgroups of index less than \var{bound}. If \var{bound} is a vector
containing a single positive integer $B$, then only subgroups of index
exactly equal to $B$ are computed. For instance
\bprog
? subgrouplist([6,2])
%1 = [[6, 0; 0, 2], [2, 0; 0, 2], [6, 3; 0, 1], [2, 1; 0, 1], [3, 0; 0, 2],
[1, 0; 0, 2], [6, 0; 0, 1], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],3)    \\@com index less than 3
%2 = [[2, 1; 0, 1], [1, 0; 0, 2], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],[3])  \\@com index 3
%3 = [[3, 0; 0, 1]]
? bnr = bnrinit(bnfinit(x), [120,[1]], 1);
? L = subgrouplist(bnr, [8]);
@eprog\noindent
In the last example, $L$ corresponds to the 24 subfields of
$\Q(\zeta_{120})$, of degree $8$ and conductor $120\infty$ (by setting \fl,
we see there are a total of $43$ subgroups of degree $8$).
\bprog
? vector(#L, i, galoissubcyclo(bnr, L[i]))
@eprog\noindent
will produce their equations. (For a general base field, you would
have to rely on \tet{bnrstark}, or \tet{rnfkummer}.)

The library syntax is \fun{GEN}{subgrouplist0}{GEN bnr, GEN bound = NULL, long flag}.

\subsec{zetak$(\var{nfz},x,\{\fl=0\})$}\kbdsidx{zetak}\label{se:zetak}
\var{znf} being a number
field initialized by \kbd{zetakinit} (\emph{not} by \kbd{nfinit}),
computes the value of the \idx{Dedekind} zeta function of the number
field at the complex number $x$. If $\fl=1$ computes Dedekind $\Lambda$
function instead (i.e.~the product of the Dedekind zeta function by its gamma
and exponential factors).

\misctitle{CAVEAT} This implementation is not satisfactory and must be
rewritten. In particular

\item The accuracy of the result depends in an essential way on the
accuracy of both the \kbd{zetakinit} program and the current accuracy.
Be wary in particular that $x$ of large imaginary part or, on the
contrary, very close to an ordinary integer will suffer from precision
loss, yielding fewer significant digits than expected. Computing with 28
digits of relative accuracy, we have
\bprog
? zeta(3)
%1 = 1.202056903159594285399738161
? zeta(3-1e-20)
%2 = 1.202056903159594285401719424
? zetak(zetakinit(x), 3-1e-20)
%3 = 1.2020569031595952919  \\ 5 digits are wrong
? zetak(zetakinit(x), 3-1e-28)
%4 = -25.33411749           \\ junk
@eprog

\item As the precision increases, results become unexpectedly
completely wrong:
\bprog
? \p100
? zetak(zetakinit(x^2-5), -1) - 1/30
%1 = 7.26691813 E-108    \\ perfect
? \p150
? zetak(zetakinit(x^2-5), -1) - 1/30
%2 = -2.486113578 E-156  \\ perfect
? \p200
? zetak(zetakinit(x^2-5), -1) - 1/30
%3 = 4.47... E-75        \\ more than half of the digits are wrong
? \p250
? zetak(zetakinit(x^2-5), -1) - 1/30
%4 = 1.6 E43             \\ junk
@eprog

The library syntax is \fun{GEN}{gzetakall}{GEN nfz, GEN x, long flag, long prec}.
See also \fun{GEN}{glambdak}{GEN znf, GEN x, long prec} or
\fun{GEN}{gzetak}{GEN znf, GEN x, long prec}.

\subsec{zetakinit$(\var{bnf})$}\kbdsidx{zetakinit}\label{se:zetakinit}
Computes a number of initialization data
concerning the number field associated to \kbd{bnf} so as to be able
to compute the \idx{Dedekind} zeta and lambda functions, respectively
$\kbd{zetak}(x)$ and $\kbd{zetak}(x,1)$, at the current real precision. If
you do not need the \kbd{bnfinit} data somewhere else, you may call it
with an irreducible polynomial instead of a \var{bnf}: it will call
\kbd{bnfinit} itself.

The result is a 9-component vector $v$ whose components are very technical
and cannot really be used except through the \kbd{zetak} function.

This function is very inefficient and should be rewritten. It needs to
computes millions of coefficients of the corresponding Dirichlet series if
the precision is big. Unless the discriminant is small it will not be able
to handle more than 9 digits of relative precision. For instance,
\kbd{zetakinit(x\pow 8 - 2)} needs 440MB of memory at default precision.

This function will fail with the message
\bprog
 *** bnrL1: overflow in zeta_get_N0 [need too many primes].
@eprog\noindent if the approximate functional equation requires us to sum
too many terms (if the discriminant of the number field is too large).

The library syntax is \fun{GEN}{initzeta}{GEN bnf, long prec}.
%SECTION: number_fields

\section{Polynomials and power series}

We group here all functions which are specific to polynomials or power
series. Many other functions which can be applied on these objects are
described in the other sections. Also, some of the functions described here
can be applied to other types.


\subsec{O$(p\hbox{\kbd{\pow}}e)$}\kbdsidx{O}\label{se:O}
If $p$ is an integer
greater than $2$, returns a $p$-adic $0$ of precision $e$. In all other
cases, returns a power series zero with precision given by $e v$, where $v$
is the $X$-adic valuation of $p$ with respect to its main variable.

The library syntax is \fun{GEN}{ggrando}{}.
\fun{GEN}{zeropadic}{GEN p, long e} for a $p$-adic and
\fun{GEN}{zeroser}{long v, long e} for a power series zero in variable $v$.

\subsec{bezoutres$(A,B,\{v\})$}\kbdsidx{bezoutres}\label{se:bezoutres}
Deprecated alias for \kbd{polresultantext}

The library syntax is \fun{GEN}{polresultantext0}{GEN A, GEN B, long v = -1}, where \kbd{v} is a variable number.

\subsec{deriv$(x,\{v\})$}\kbdsidx{deriv}\label{se:deriv}
Derivative of $x$ with respect to the main
variable if $v$ is omitted, and with respect to $v$ otherwise. The derivative
of a scalar type is zero, and the derivative of a vector or matrix is done
componentwise. One can use $x'$ as a shortcut if the derivative is with
respect to the main variable of $x$.

By definition, the main variable of a \typ{POLMOD} is the main variable among
the coefficients from its two polynomial components (representative and
modulus); in other words, assuming a polmod represents an element of
$R[X]/(T(X))$, the variable $X$ is a mute variable and the derivative is
taken with respect to the main variable used in the base ring $R$.

The library syntax is \fun{GEN}{deriv}{GEN x, long v = -1}, where \kbd{v} is a variable number.

\subsec{diffop$(x,v,d,\{n=1\})$}\kbdsidx{diffop}\label{se:diffop}
Let $v$ be a vector of variables, and $d$ a vector of the same length,
return the image of $x$ by the $n$-power ($1$ if n is not given) of the differential
operator $D$ that assumes the value \kbd{d[i]} on the variable \kbd{v[i]}.
The value of $D$ on a scalar type is zero, and $D$ applies componentwise to a vector
or matrix. When applied to a \typ{POLMOD}, if no value is provided for the variable
of the modulus, such value is derived using the implicit function theorem.

Some examples:
This function can be used to differentiate formal expressions:
If $E=\exp(X^2)$ then we have $E'=2*X*E$. We can derivate $X*exp(X^2)$ as follow:
\bprog
? diffop(E*X,[X,E],[1,2*X*E])
%1 = (2*X^2 + 1)*E
@eprog
Let \kbd{Sin} and \kbd{Cos} be two function such that $\kbd{Sin}^2+\kbd{Cos}^2=1$
and $\kbd{Cos}'=-\kbd{Sin}$. We can differentiate $\kbd{Sin}/\kbd{Cos}$ as follow,
PARI inferring the value of $\kbd{Sin}'$ from the equation:
\bprog
? diffop(Mod('Sin/'Cos,'Sin^2+'Cos^2-1),['Cos],[-'Sin])
%1 = Mod(1/Cos^2, Sin^2 + (Cos^2 - 1))

@eprog
Compute the Bell polynomials (both complete and partial) via the Faa di Bruno formula:
\bprog
Bell(k,n=-1)=
{
  my(var(i)=eval(Str("X",i)));
  my(x,v,dv);
  v=vector(k,i,if(i==1,'E,var(i-1)));
  dv=vector(k,i,if(i==1,'X*var(1)*'E,var(i)));
  x=diffop('E,v,dv,k)/'E;
  if(n<0,subst(x,'X,1),polcoeff(x,n,'X))
}
@eprog

The library syntax is \fun{GEN}{diffop0}{GEN x, GEN v, GEN d, long n}.

For $n=1$, the function \fun{GEN}{diffop}{GEN x, GEN v, GEN d} is also available.

\subsec{eval$(x)$}\kbdsidx{eval}\label{se:eval}
Replaces in $x$ the formal variables by the values that
have been assigned to them after the creation of $x$. This is mainly useful
in GP, and not in library mode. Do not confuse this with substitution (see
\kbd{subst}).

If $x$ is a character string, \kbd{eval($x$)} executes $x$ as a GP
command, as if directly input from the keyboard, and returns its
output.
\bprog
? x1 = "one"; x2 = "two";
? n = 1; eval(Str("x", n))
%2 = "one"
? f = "exp"; v = 1;
? eval(Str(f, "(", v, ")"))
%4 = 2.7182818284590452353602874713526624978
@eprog\noindent Note that the first construct could be implemented in a
simpler way by using a vector \kbd{x = ["one","two"]; x[n]}, and the second
by using a closure \kbd{f = exp; f(v)}. The final example is more interesting:
\bprog
? genmat(u,v) = matrix(u,v,i,j, eval( Str("x",i,j) ));
? genmat(2,3)   \\ generic 2 x 3 matrix
%2 =
[x11 x12 x13]

[x21 x22 x23]
@eprog

A syntax error in the evaluation expression raises an \kbd{e\_SYNTAX}
exception, which can be trapped as usual:
\bprog
? 1a
 ***   unused characters: 1a
 ***                       ^-
? E(expr) =
  {
    iferr(eval(expr),
          e, print("syntax error"),
          errname(e) == "e_SYNTAX");
  }
? E("1+1")
%1 = 2
? E("1a")
syntax error
@eprog
\synt{geval}{GEN x}.

\subsec{factorpadic$(\var{pol},p,r)$}\kbdsidx{factorpadic}\label{se:factorpadic}
$p$-adic factorization
of the polynomial \var{pol} to precision $r$, the result being a
two-column matrix as in \kbd{factor}. Note that this is not the same
as a factorization over $\Z/p^r\Z$ (polynomials over that ring do not form a
unique factorization domain, anyway), but approximations in $\Q/p^r\Z$ of
the true factorization in $\Q_p[X]$.
\bprog
? factorpadic(x^2 + 9, 3,5)
%1 =
[(1 + O(3^5))*x^2 + O(3^5)*x + (3^2 + O(3^5)) 1]
? factorpadic(x^2 + 1, 5,3)
%2 =
[  (1 + O(5^3))*x + (2 + 5 + 2*5^2 + O(5^3)) 1]

[(1 + O(5^3))*x + (3 + 3*5 + 2*5^2 + O(5^3)) 1]
@eprog\noindent
The factors are normalized so that their leading coefficient is a power of
$p$. The method used is a modified version of the \idx{round 4} algorithm of
\idx{Zassenhaus}.

If \var{pol} has inexact \typ{PADIC} coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the $p$-adic content,  then lifted to $\Z$ using \tet{truncate}
coefficientwise.
Hence we actually factor exactly a polynomial which is only $p$-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with exact rational coefficients.

\synt{factorpadic}{GEN f,GEN p, long r} . The function \kbd{factorpadic0} is
deprecated, provided for backward compatibility.

\subsec{intformal$(x,\{v\})$}\kbdsidx{intformal}\label{se:intformal}
\idx{formal integration} of $x$ with respect to the variable $v$ (wrt.
the main variable if $v$ is omitted). Since PARI cannot represent
logarithmic or arctangent terms, any such term in the result will yield an
error:
\bprog
 ? intformal(x^2)
 %1 = 1/3*x^3
 ? intformal(x^2, y)
 %2 = y*x^2
 ? intformal(1/x)
   ***   at top-level: intformal(1/x)
   ***                 ^--------------
   *** intformal: domain error in intformal: residue(series, pole) != 0
@eprog
The argument $x$ can be of any type. When $x$ is a rational function, we
assume that the base ring is an integral domain of characteristic zero.

  By  definition,   the main variable of a \typ{POLMOD} is the main variable
among the  coefficients  from  its  two  polynomial  components
(representative and modulus); in other words, assuming a polmod represents an
element of $R[X]/(T(X))$, the variable $X$ is a mute variable and the
integral is taken with respect to the main variable used in the base ring $R$.
In particular, it is meaningless to integrate with respect to the main
variable of \kbd{x.mod}:
\bprog
? intformal(Mod(1,x^2+1), 'x)
*** intformal: incorrect priority in intformal: variable x = x
@eprog

The library syntax is \fun{GEN}{integ}{GEN x, long v = -1}, where \kbd{v} is a variable number.

\subsec{padicappr$(\var{pol},a)$}\kbdsidx{padicappr}\label{se:padicappr}
Vector of $p$-adic roots of the
polynomial $pol$ congruent to the $p$-adic number $a$ modulo $p$, and with
the same $p$-adic precision as $a$. The number $a$ can be an ordinary
$p$-adic number (type \typ{PADIC}, i.e.~an element of $\Z_p$) or can be an
integral element of a finite extension of $\Q_p$, given as a \typ{POLMOD}
at least one of whose coefficients is a \typ{PADIC}. In this case, the result
is the vector of roots belonging to the same extension of $\Q_p$ as $a$.

The library syntax is \fun{GEN}{padicappr}{GEN pol, GEN a}.
Also available is \fun{GEN}{Zp_appr}{GEN f, GEN a} when $a$ is a
\typ{PADIC}.

\subsec{padicfields$(p, N, \{\fl=0\})$}\kbdsidx{padicfields}\label{se:padicfields}
Returns a vector of polynomials generating all the extensions of degree
$N$ of the field $\Q_p$ of $p$-adic rational numbers; $N$ is
allowed to be a 2-component vector $[n,d]$, in which case we return the
extensions of degree $n$ and discriminant $p^d$.

The list is minimal in the sense that two different polynomials generate
non-isomorphic extensions; in particular, the number of polynomials is the
number of classes of non-isomorphic extensions. If $P$ is a polynomial in this
list, $\alpha$ is any root of $P$ and $K = \Q_p(\alpha)$, then $\alpha$
is the sum of a uniformizer and a (lift of a) generator of the residue field
of $K$; in particular, the powers of $\alpha$ generate the ring of $p$-adic
integers of $K$.

If $\fl = 1$, replace each polynomial $P$ by a vector $[P, e, f, d, c]$
where $e$ is the ramification index, $f$ the residual degree, $d$ the
valuation of the discriminant, and $c$ the number of conjugate fields.
If $\fl = 2$, only return the \emph{number} of extensions in a fixed
algebraic closure (Krasner's formula), which is much faster.

The library syntax is \fun{GEN}{padicfields0}{GEN p, GEN N, long flag}.
Also available is
\fun{GEN}{padicfields}{GEN p, long n, long d, long flag}, which computes
extensions of $\Q_p$ of degree $n$ and discriminant $p^d$.

\subsec{polchebyshev$(n,\{\fl=1\},\{a='x\})$}\kbdsidx{polchebyshev}\label{se:polchebyshev}
Returns the $n^{\text{th}}$
\idx{Chebyshev} polynomial of the first kind $T_n$ ($\fl=1$) or the second
kind $U_n$ ($\fl=2$), evaluated at $a$ (\kbd{'x} by default). Both series of
polynomials satisfy the 3-term relation
$$ P_{n+1} = 2xP_n - P_{n-1}, $$
and are determined by the initial conditions $U_0 = T_0 = 1$, $T_1 = x$,
$U_1 = 2x$. In fact $T_n' = n U_{n-1}$ and, for all complex numbers $z$, we
have $T_n(\cos z) = \cos (nz)$ and $U_{n-1}(\cos z) = \sin(nz)/\sin z$.
If $n \geq 0$, then these polynomials have degree $n$.  For $n < 0$,
$T_n$ is equal to $T_{-n}$ and $U_n$ is equal to $-U_{-2-n}$.
In particular, $U_{-1} = 0$.

The library syntax is \fun{GEN}{polchebyshev_eval}{long n, long flag, GEN a = NULL}.
Also available are
\fun{GEN}{polchebyshev}{long n, long \fl, long v},
\fun{GEN}{polchebyshev1}{long n, long v} and
\fun{GEN}{polchebyshev2}{long n, long v} for $T_n$ and $U_n$ respectively.

\subsec{polcoeff$(x,n,\{v\})$}\kbdsidx{polcoeff}\label{se:polcoeff}
Coefficient of degree $n$ of the polynomial $x$, with respect to the
main variable if $v$ is omitted, with respect to $v$ otherwise.  If $n$
is greater than the degree, the result is zero.

Naturally applies to scalars (polynomial of degree $0$), as well as to
rational functions whose denominator is a monomial.
It also applies to power series: if $n$ is less than the valuation, the result
is zero. If it is greater than the largest significant degree, then an error
message is issued.

 For greater flexibility, $x$ can be a vector or matrix type and the
 function then returns \kbd{component(x,n)}.

The library syntax is \fun{GEN}{polcoeff0}{GEN x, long n, long v = -1}, where \kbd{v} is a variable number.

\subsec{polcyclo$(n,\{a = 'x\})$}\kbdsidx{polcyclo}\label{se:polcyclo}
$n$-th cyclotomic polynomial, evaluated at $a$ (\kbd{'x} by default). The
integer $n$ must be positive.

Algorithm used: reduce to the case where $n$ is squarefree; to compute the
cyclotomic polynomial, use $\Phi_{np}(x)=\Phi_n(x^p)/\Phi(x)$; to compute
it evaluated, use $\Phi_n(x) = \prod_{d\mid n} (x^d-1)^{\mu(n/d)}$. In the
evaluated case, the algorithm assumes that $a^d - 1$ is either $0$ or
invertible, for all $d\mid n$. If this is not the case (the base ring has
zero divisors), use \kbd{subst(polcyclo(n),x,a)}.

The library syntax is \fun{GEN}{polcyclo_eval}{long n, GEN a  = NULL}.
The variant \fun{GEN}{polcyclo}{long n, long v} returns the $n$-th
cyclotomic polynomial in variable $v$.

\subsec{polcyclofactors$(f)$}\kbdsidx{polcyclofactors}\label{se:polcyclofactors}
Returns a vector of polynomials, whose product is the product of
distinct cyclotomic polynomials dividing $f$.
\bprog
? f = x^10+5*x^8-x^7+8*x^6-4*x^5+8*x^4-3*x^3+7*x^2+3;
? v = polcyclofactors(f)
%2 = [x^2 + 1, x^2 + x + 1, x^4 - x^3 + x^2 - x + 1]
? apply(poliscycloprod, v)
%3 = [1, 1, 1]
? apply(poliscyclo, v)
%4 = [4, 3, 10]
@eprog\noindent In general, the polynomials are products of cyclotomic
polynomials and not themselves irreducible:
\bprog
? g = x^8+2*x^7+6*x^6+9*x^5+12*x^4+11*x^3+10*x^2+6*x+3;
? polcyclofactors(g)
%2 = [x^6 + 2*x^5 + 3*x^4 + 3*x^3 + 3*x^2 + 2*x + 1]
? factor(%[1])
%3 =
[            x^2 + x + 1 1]

[x^4 + x^3 + x^2 + x + 1 1]
@eprog

The library syntax is \fun{GEN}{polcyclofactors}{GEN f}.

\subsec{poldegree$(x,\{v\})$}\kbdsidx{poldegree}\label{se:poldegree}
Degree of the polynomial $x$ in the main variable if $v$ is omitted, in
the variable $v$ otherwise.

The degree of $0$ is a fixed negative number, whose exact value should not
be used. The degree of a non-zero scalar is $0$. Finally, when $x$ is a
non-zero polynomial or rational function, returns the ordinary degree of
$x$. Raise an error otherwise.

The library syntax is \fun{long}{poldegree}{GEN x, long v = -1}, where \kbd{v} is a variable number.

\subsec{poldisc$(\var{pol},\{v\})$}\kbdsidx{poldisc}\label{se:poldisc}
Discriminant of the polynomial
\var{pol} in the main variable if $v$ is omitted, in $v$ otherwise. The
algorithm used is the \idx{subresultant algorithm}.

The library syntax is \fun{GEN}{poldisc0}{GEN pol, long v = -1}, where \kbd{v} is a variable number.

\subsec{poldiscreduced$(f)$}\kbdsidx{poldiscreduced}\label{se:poldiscreduced}
Reduced discriminant vector of the
(integral, monic) polynomial $f$. This is the vector of elementary divisors
of $\Z[\alpha]/f'(\alpha)\Z[\alpha]$, where $\alpha$ is a root of the
polynomial $f$. The components of the result are all positive, and their
product is equal to the absolute value of the discriminant of~$f$.

The library syntax is \fun{GEN}{reduceddiscsmith}{GEN f}.

\subsec{polgraeffe$(f)$}\kbdsidx{polgraeffe}\label{se:polgraeffe}
Returns the \idx{Graeffe} transform $g$ of $f$, such that $g(x^2) = f(x)
f(-x)$.

The library syntax is \fun{GEN}{polgraeffe}{GEN f}.

\subsec{polhensellift$(A, B, p, e)$}\kbdsidx{polhensellift}\label{se:polhensellift}
Given a prime $p$, an integral polynomial $A$ whose leading coefficient
is a $p$-unit, a vector $B$ of integral polynomials that are monic and
pairwise relatively prime modulo $p$, and whose product is congruent to
$A/\text{lc}(A)$ modulo $p$, lift the elements of $B$ to polynomials whose
product is congruent to $A$ modulo $p^e$.

More generally, if $T$ is an integral polynomial irreducible mod $p$, and
$B$ is a factorization of $A$ over the finite field $\F_p[t]/(T)$, you can
lift it to $\Z_p[t]/(T, p^e)$ by replacing the $p$ argument with $[p,T]$:
\bprog
? { T = t^3 - 2; p = 7; A = x^2 + t + 1;
    B = [x + (3*t^2 + t + 1), x + (4*t^2 + 6*t + 6)];
    r = polhensellift(A, B, [p, T], 6) }
%1 = [x + (20191*t^2 + 50604*t + 75783), x + (97458*t^2 + 67045*t + 41866)]
? liftall( r[1] * r[2] * Mod(Mod(1,p^6),T) )
%2 = x^2 + (t + 1)
@eprog

The library syntax is \fun{GEN}{polhensellift}{GEN A, GEN B, GEN p, long e}.

\subsec{polhermite$(n,\{a='x\})$}\kbdsidx{polhermite}\label{se:polhermite}
$n^{\text{th}}$ \idx{Hermite} polynomial $H_n$ evaluated at $a$
(\kbd{'x} by default), i.e.
$$ H_n(x) = (-1)^n\*e^{x^2} \dfrac{d^n}{dx^n}e^{-x^2}.$$

The library syntax is \fun{GEN}{polhermite_eval}{long n, GEN a = NULL}.
The variant \fun{GEN}{polhermite}{long n, long v} returns the $n$-th
Hermite polynomial in variable $v$.

\subsec{polinterpolate$(X,\{Y\},\{x\},\{\&e\})$}\kbdsidx{polinterpolate}\label{se:polinterpolate}
Given the data vectors
$X$ and $Y$ of the same length $n$ ($X$ containing the $x$-coordinates,
and $Y$ the corresponding $y$-coordinates), this function finds the
\idx{interpolating polynomial} passing through these points and evaluates it
at~$x$. If $Y$ is omitted, return the polynomial interpolating the
$(i,X[i])$. If present, $e$ will contain an error estimate on the returned
value.

The library syntax is \fun{GEN}{polint}{GEN X, GEN Y = NULL, GEN x = NULL, GEN *e = NULL}.

\subsec{poliscyclo$(f)$}\kbdsidx{poliscyclo}\label{se:poliscyclo}
Returns 0 if $f$ is not a cyclotomic polynomial, and $n > 0$ if $f =
\Phi_n$, the $n$-th cyclotomic polynomial.
\bprog
? poliscyclo(x^4-x^2+1)
%1 = 12
? polcyclo(12)
%2 = x^4 - x^2 + 1
? poliscyclo(x^4-x^2-1)
%3 = 0
@eprog

The library syntax is \fun{long}{poliscyclo}{GEN f}.

\subsec{poliscycloprod$(f)$}\kbdsidx{poliscycloprod}\label{se:poliscycloprod}
Returns 1 if $f$ is a product of cyclotomic polynomial, and $0$
otherwise.
\bprog
? f = x^6+x^5-x^3+x+1;
? poliscycloprod(f)
%2 = 1
? factor(f)
%3 =
[  x^2 + x + 1 1]

[x^4 - x^2 + 1 1]
? [ poliscyclo(T) | T <- %[,1] ]
%4 = [3, 12]
? polcyclo(3) * polcyclo(12)
%5 = x^6 + x^5 - x^3 + x + 1
@eprog

The library syntax is \fun{long}{poliscycloprod}{GEN f}.

\subsec{polisirreducible$(\var{pol})$}\kbdsidx{polisirreducible}\label{se:polisirreducible}
\var{pol} being a polynomial (univariate in the present version \vers),
returns 1 if \var{pol} is non-constant and irreducible, 0 otherwise.
Irreducibility is checked over the smallest base field over which \var{pol}
seems to be defined.

The library syntax is \fun{long}{isirreducible}{GEN pol}.

\subsec{pollead$(x,\{v\})$}\kbdsidx{pollead}\label{se:pollead}
Leading coefficient of the polynomial or power series $x$. This is
 computed with respect to the main variable of $x$ if $v$ is omitted, with
 respect to the variable $v$ otherwise.

The library syntax is \fun{GEN}{pollead}{GEN x, long v = -1}, where \kbd{v} is a variable number.

\subsec{pollegendre$(n,\{a='x\})$}\kbdsidx{pollegendre}\label{se:pollegendre}
$n^{\text{th}}$ \idx{Legendre polynomial} evaluated at $a$ (\kbd{'x} by
default).

The library syntax is \fun{GEN}{pollegendre_eval}{long n, GEN a = NULL}.
To obtain the $n$-th Legendre polynomial in variable $v$,
use \fun{GEN}{pollegendre}{long n, long v}.

\subsec{polrecip$(\var{pol})$}\kbdsidx{polrecip}\label{se:polrecip}
Reciprocal polynomial of \var{pol}, i.e.~the coefficients are in
reverse order. \var{pol} must be a polynomial.

The library syntax is \fun{GEN}{polrecip}{GEN pol}.

\subsec{polresultant$(x,y,\{v\},\{\fl=0\})$}\kbdsidx{polresultant}\label{se:polresultant}
Resultant of the two
polynomials $x$ and $y$ with exact entries, with respect to the main
variables of $x$ and $y$ if $v$ is omitted, with respect to the variable $v$
otherwise. The algorithm assumes the base ring is a domain. If you also need
the $u$ and $v$ such that $x*u + y*v = \text{Res}(x,y)$, use the
\tet{polresultantext} function.

If $\fl=0$ (default), uses the the algorithm best suited to the inputs,
either the \idx{subresultant algorithm} (Lazard/Ducos variant, generic case),
a modular algorithm (inputs in $\Q[X]$) or Sylvester's matrix (inexact
inputs).

If $\fl=1$, uses the determinant of Sylvester's matrix instead; this should
always be slower than the default.

The library syntax is \fun{GEN}{polresultant0}{GEN x, GEN y, long v = -1, long flag}, where \kbd{v} is a variable number.

\subsec{polresultantext$(A,B,\{v\})$}\kbdsidx{polresultantext}\label{se:polresultantext}
Finds polynomials $U$ and $V$ such that $A*U + B*V = R$, where $R$ is
the resultant of $U$ and $V$ with respect to the main variables of $A$ and
$B$ if $v$ is omitted, and with respect to $v$ otherwise. Returns the row
vector $[U,V,R]$. The algorithm used (subresultant) assumes that the base
ring is a domain.
\bprog
? A = x*y; B = (x+y)^2;
? [U,V,R] = polresultantext(A, B)
%2 = [-y*x - 2*y^2, y^2, y^4]
? A*U + B*V
%3 = y^4
? [U,V,R] = polresultantext(A, B, y)
%4 = [-2*x^2 - y*x, x^2, x^4]
? A*U+B*V
%5 = x^4
@eprog

The library syntax is \fun{GEN}{polresultantext0}{GEN A, GEN B, long v = -1}, where \kbd{v} is a variable number.
Also available is
\fun{GEN}{polresultantext}{GEN x, GEN y}.

\subsec{polroots$(x)$}\kbdsidx{polroots}\label{se:polroots}
Complex roots of the polynomial
\var{x}, given as a column vector where each root is repeated according to
its multiplicity. The precision is given as for transcendental functions: in
GP it is kept in the variable \kbd{realprecision} and is transparent to the
user, but it must be explicitly given as a second argument in library mode.

The algorithm used is a modification of A.~Sch\"onhage\sidx{Sch\"onage}'s
root-finding algorithm, due to and originally implemented by X.~Gourdon.
Barring bugs, it is guaranteed to converge and to give the roots to the
required accuracy.

The library syntax is \fun{GEN}{roots}{GEN x, long prec}.

\subsec{polrootsmod$(\var{pol},p,\{\fl=0\})$}\kbdsidx{polrootsmod}\label{se:polrootsmod}
Row vector of roots modulo $p$ of the polynomial \var{pol}.
Multiple roots are \emph{not} repeated.
\bprog
? polrootsmod(x^2-1,2)
%1 = [Mod(1, 2)]~
@eprog\noindent
If $p$ is very small, you may set $\fl=1$, which uses a naive search.

The library syntax is \fun{GEN}{rootmod0}{GEN pol, GEN p, long flag}.

\subsec{polrootspadic$(x,p,r)$}\kbdsidx{polrootspadic}\label{se:polrootspadic}
Vector of $p$-adic roots of the polynomial \var{pol}, given to
$p$-adic precision $r$ $p$ is assumed to be a prime. Multiple roots are
\emph{not} repeated. Note that this is not the same as the roots in
$\Z/p^r\Z$, rather it gives approximations in $\Z/p^r\Z$ of the true roots
living in $\Q_p$.
\bprog
? polrootspadic(x^3 - x^2 + 64, 2, 5)
%1 = [2^3 + O(2^5), 2^3 + 2^4 + O(2^5), 1 + O(2^5)]~
@eprog
If \var{pol} has inexact \typ{PADIC} coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the $p$-adic content, then lifted
to $\Z$ using \tet{truncate} coefficientwise. Hence the roots given are
approximations of the roots of an exact polynomial which is $p$-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with eact rational coefficients.

The library syntax is \fun{GEN}{rootpadic}{GEN x, GEN p, long r}.

\subsec{polsturm$(\var{pol},\{a\},\{b\})$}\kbdsidx{polsturm}\label{se:polsturm}
Number of real roots of the real squarefree polynomial \var{pol} in the
interval $]a,b]$, using Sturm's algorithm. $a$ (resp.~$b$) is taken to be
$-\infty$ (resp.~$+\infty$) if omitted.

The library syntax is \fun{long}{sturmpart}{GEN pol, GEN a = NULL, GEN b = NULL}.
Also available is \fun{long}{sturm}{GEN pol} (total number of real
roots).

\subsec{polsubcyclo$(n,d,\{v='x\})$}\kbdsidx{polsubcyclo}\label{se:polsubcyclo}
Gives polynomials (in variable $v$) defining the sub-Abelian extensions
of degree $d$ of the cyclotomic field $\Q(\zeta_n)$, where $d\mid \phi(n)$.

If there is exactly one such extension the output is a polynomial, else it is
a vector of polynomials, possibly empty. To get a vector in all cases,
use \kbd{concat([], polsubcyclo(n,d))}.

The function \tet{galoissubcyclo} allows to specify exactly which
sub-Abelian extension should be computed.

The library syntax is \fun{GEN}{polsubcyclo}{long n, long d, long v = -1}, where \kbd{v} is a variable number.

\subsec{polsylvestermatrix$(x,y)$}\kbdsidx{polsylvestermatrix}\label{se:polsylvestermatrix}
Forms the Sylvester matrix
corresponding to the two polynomials $x$ and $y$, where the coefficients of
the polynomials are put in the columns of the matrix (which is the natural
direction for solving equations afterwards). The use of this matrix can be
essential when dealing with polynomials with inexact entries, since
polynomial Euclidean division doesn't make much sense in this case.

The library syntax is \fun{GEN}{sylvestermatrix}{GEN x, GEN y}.

\subsec{polsym$(x,n)$}\kbdsidx{polsym}\label{se:polsym}
Creates the column vector of the \idx{symmetric powers} of the roots of the
polynomial $x$ up to power $n$, using Newton's formula.

The library syntax is \fun{GEN}{polsym}{GEN x, long n}.

\subsec{poltchebi$(n,\{v='x\})$}\kbdsidx{poltchebi}\label{se:poltchebi}
Deprecated alias for \kbd{polchebyshev}

The library syntax is \fun{GEN}{polchebyshev1}{long n, long v = -1}, where \kbd{v} is a variable number.

\subsec{polzagier$(n,m)$}\kbdsidx{polzagier}\label{se:polzagier}
Creates Zagier's polynomial $P_n^{(m)}$ used in
the functions \kbd{sumalt} and \kbd{sumpos} (with $\fl=1$). One must have $m\le
n$. The exact definition can be found in ``Convergence acceleration of
alternating series'', Cohen et al., Experiment.~Math., vol.~9, 2000, pp.~3--12.

%@article {MR2001m:11222,
%    AUTHOR = {Cohen, Henri and Rodriguez Villegas, Fernando and Zagier, Don},
%     TITLE = {Convergence acceleration of alternating series},
%   JOURNAL = {Experiment. Math.},
%    VOLUME = {9},
%      YEAR = {2000},
%    NUMBER = {1},
%     PAGES = {3--12},
%}

The library syntax is \fun{GEN}{polzag}{long n, long m}.

\subsec{serconvol$(x,y)$}\kbdsidx{serconvol}\label{se:serconvol}
Convolution (or \idx{Hadamard product}) of the
two power series $x$ and $y$; in other words if $x=\sum a_k*X^k$ and $y=\sum
b_k*X^k$ then $\kbd{serconvol}(x,y)=\sum a_k*b_k*X^k$.

The library syntax is \fun{GEN}{convol}{GEN x, GEN y}.

\subsec{serlaplace$(x)$}\kbdsidx{serlaplace}\label{se:serlaplace}
$x$ must be a power series with non-negative
exponents. If $x=\sum (a_k/k!)*X^k$ then the result is $\sum a_k*X^k$.

The library syntax is \fun{GEN}{laplace}{GEN x}.

\subsec{serreverse$(s)$}\kbdsidx{serreverse}\label{se:serreverse}
Reverse power series of $s$, i.e. the series $t$ such that $t(s) = x$;
$s$ must be a power series whose valuation is exactly equal to one.
\bprog
? \ps 8
? t = serreverse(tan(x))
%2 = x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + O(x^8)
? tan(t)
%3 = x + O(x^8)
@eprog

The library syntax is \fun{GEN}{serreverse}{GEN s}.

\subsec{subst$(x,y,z)$}\kbdsidx{subst}\label{se:subst}
Replace the simple variable $y$ by the argument $z$ in the ``polynomial''
expression $x$. Every type is allowed for $x$, but if it is not a genuine
polynomial (or power series, or rational function), the substitution will be
done as if the scalar components were polynomials of degree zero. In
particular, beware that:

\bprog
? subst(1, x, [1,2; 3,4])
%1 =
[1 0]

[0 1]

? subst(1, x, Mat([0,1]))
  ***   at top-level: subst(1,x,Mat([0,1])
  ***                 ^--------------------
  *** subst: forbidden substitution by a non square matrix.
@eprog\noindent
If $x$ is a power series, $z$ must be either a polynomial, a power
series, or a rational function. Finally, if $x$ is a vector,
matrix or list, the substitution is applied to each individual entry.

Use the function \kbd{substvec} to replace several variables at once,
or the function \kbd{substpol} to replace a polynomial expression.

The library syntax is \fun{GEN}{gsubst}{GEN x, long y, GEN z}, where \kbd{y} is a variable number.

\subsec{substpol$(x,y,z)$}\kbdsidx{substpol}\label{se:substpol}
Replace the ``variable'' $y$ by the argument $z$ in the ``polynomial''
expression $x$. Every type is allowed for $x$, but the same behavior
as \kbd{subst} above apply.

The difference with \kbd{subst} is that $y$ is allowed to be any polynomial
here. The substitution is done moding out all components of $x$
(recursively) by $y - t$, where $t$ is a new free variable of lowest
priority. Then substituting $t$ by $z$ in the resulting expression. For
instance
\bprog
? substpol(x^4 + x^2 + 1, x^2, y)
%1 = y^2 + y + 1
? substpol(x^4 + x^2 + 1, x^3, y)
%2 = x^2 + y*x + 1
? substpol(x^4 + x^2 + 1, (x+1)^2, y)
%3 = (-4*y - 6)*x + (y^2 + 3*y - 3)
@eprog

The library syntax is \fun{GEN}{gsubstpol}{GEN x, GEN y, GEN z}.
Further, \fun{GEN}{gdeflate}{GEN T, long v, long d} attempts to
write $T(x)$ in the form $t(x^d)$, where $x=$\kbd{pol\_x}$(v)$, and returns
\kbd{NULL} if the substitution fails (for instance in the example \kbd{\%2}
above).

\subsec{substvec$(x,v,w)$}\kbdsidx{substvec}\label{se:substvec}
$v$ being a vector of monomials of degree 1 (variables),
$w$ a vector of expressions of the same length, replace in the expression
$x$ all occurrences of $v_i$ by $w_i$. The substitutions are done
simultaneously; more precisely, the $v_i$ are first replaced by new
variables in $x$, then these are replaced by the $w_i$:

\bprog
? substvec([x,y], [x,y], [y,x])
%1 = [y, x]
? substvec([x,y], [x,y], [y,x+y])
%2 = [y, x + y]     \\ not [y, 2*y]
@eprog

The library syntax is \fun{GEN}{gsubstvec}{GEN x, GEN v, GEN w}.

\subsec{sumformal$(f,\{v\})$}\kbdsidx{sumformal}\label{se:sumformal}
\idx{formal sum} of the polynomial expression $f$ with respect to the
main variable if $v$ is omitted, with respect to the variable $v$ otherwise;
it is assumed that the base ring has characteristic zero. In other words,
considering $f$ as a polynomial function in the variable $v$,
returns $F$, a polynomial in $v$ vanishing at $0$, such that $F(b) - F(a)
= sum_{v = a+1}^b f(v)$:
\bprog
? sumformal(n)  \\ 1 + ... + n
%1 = 1/2*n^2 + 1/2*n
? f(n) = n^3+n^2+1;
? F = sumformal(f(n))  \\ f(1) + ... + f(n)
%3 = 1/4*n^4 + 5/6*n^3 + 3/4*n^2 + 7/6*n
? sum(n = 1, 2000, f(n)) == subst(F, n, 2000)
%4 = 1
? sum(n = 1001, 2000, f(n)) == subst(F, n, 2000) - subst(F, n, 1000)
%5 = 1
? sumformal(x^2 + x*y + y^2, y)
%6 = y*x^2 + (1/2*y^2 + 1/2*y)*x + (1/3*y^3 + 1/2*y^2 + 1/6*y)
? x^2 * y + x * sumformal(y) + sumformal(y^2) == %
%7 = 1
@eprog

The library syntax is \fun{GEN}{sumformal}{GEN f, long v = -1}, where \kbd{v} is a variable number.

\subsec{taylor$(x,t,\{d=\var{seriesprecision}\})$}\kbdsidx{taylor}\label{se:taylor}
Taylor expansion around $0$ of $x$ with respect to
the simple variable $t$. $x$ can be of any reasonable type, for example a
rational function. Contrary to \tet{Ser}, which takes the valuation into
account, this function adds $O(t^d)$ to all components of $x$.
\bprog
? taylor(x/(1+y), y, 5)
%1 = (y^4 - y^3 + y^2 - y + 1)*x + O(y^5)
? Ser(x/(1+y), y, 5)
 ***   at top-level: Ser(x/(1+y),y,5)
 ***                 ^----------------
 *** Ser: main variable must have higher priority in gtoser.
@eprog

The library syntax is \fun{GEN}{tayl}{GEN x, long t, long precdl}, where \kbd{t} is a variable number.

\subsec{thue$(\var{tnf},a,\{\var{sol}\})$}\kbdsidx{thue}\label{se:thue}
Returns all solutions of the equation
$P(x,y)=a$ in integers $x$ and $y$, where \var{tnf} was created with
$\kbd{thueinit}(P)$. If present, \var{sol} must contain the solutions of
$\Norm(x)=a$ modulo units of positive norm in the number field
defined by $P$ (as computed by \kbd{bnfisintnorm}). If there are infinitely
many solutions, an error will be issued.

It is allowed to input directly the polynomial $P$ instead of a \var{tnf},
in which case, the function first performs \kbd{thueinit(P,0)}. This is
very wasteful if more than one value of $a$ is required.

If \var{tnf} was computed without assuming GRH (flag $1$ in \tet{thueinit}),
then the result is unconditional. Otherwise, it depends in principle of the
truth of the GRH, but may still be unconditionally correct in some
favorable cases. The result is conditional on the GRH if
$a\neq \pm 1$ and, $P$ has a single irreducible rational factor, whose
associated tentative class number $h$ and regulator $R$ (as computed
assuming the GRH) satisfy

\item $h > 1$,

\item $R/0.2 > 1.5$.

Here's how to solve the Thue equation $x^{13} - 5y^{13} = - 4$:
\bprog
? tnf = thueinit(x^13 - 5);
? thue(tnf, -4)
%1 = [[1, 1]]
@eprog\noindent In this case, one checks that \kbd{bnfinit(x\pow13 -5).no}
is $1$. Hence, the only solution is $(x,y) = (1,1)$, and the result is
unconditional. On the other hand:
\bprog
? P = x^3-2*x^2+3*x-17; tnf = thueinit(P);
? thue(tnf, -15)
%2 = [[1, 1]]  \\ a priori conditional on the GRH.
? K = bnfinit(P); K.no
%3 = 3
? K.reg
%4 = 2.8682185139262873674706034475498755834
@eprog
This time the result is conditional. All results computed using this
particular \var{tnf} are likewise conditional, \emph{except} for a right-hand
side of $\pm 1$.
The above result is in fact correct, so we did not just disprove the GRH:
\bprog
? tnf = thueinit(x^3-2*x^2+3*x-17, 1 /*unconditional*/);
? thue(tnf, -15)
%4 = [[1, 1]]
@eprog
Note that reducible or non-monic polynomials are allowed:
\bprog
? tnf = thueinit((2*x+1)^5 * (4*x^3-2*x^2+3*x-17), 1);
? thue(tnf, 128)
%2 = [[-1, 0], [1, 0]]
@eprog\noindent Reducible polynomials are in fact much easier to handle.

The library syntax is \fun{GEN}{thue}{GEN tnf, GEN a, GEN sol = NULL}.

\subsec{thueinit$(P,\{\fl=0\})$}\kbdsidx{thueinit}\label{se:thueinit}
Initializes the \var{tnf} corresponding to $P$, a univariate polynomial
with integer coefficients. The result is meant to be used in conjunction with
\tet{thue} to solve Thue equations $P(X / Y)Y^{\deg P} = a$, where $a$ is an
integer.

If $\fl$ is non-zero, certify results unconditionally. Otherwise, assume
\idx{GRH}, this being much faster of course. In the latter case, the result
may still be unconditionally correct, see \tet{thue}. For instance in most
cases where $P$ is reducible (not a pure power of an irreducible), \emph{or}
conditional computed class groups are trivial \emph{or} the right hand side
is $\pm1$, then results are always unconditional.

The library syntax is \fun{GEN}{thueinit}{GEN P, long flag, long prec}.
%SECTION: polynomials

\section{Vectors, matrices, linear algebra and sets}
\label{se:linear_algebra}

Note that most linear algebra functions operating on subspaces defined by
generating sets (such as \tet{mathnf}, \tet{qflll}, etc.) take matrices as
arguments. As usual, the generating vectors are taken to be the
\emph{columns} of the given matrix.

Since PARI does not have a strong typing system, scalars live in
unspecified commutative base rings. It is very difficult to write
robust linear algebra routines in such a general setting. We thus
assume that the base ring is a domain and work over its field of
fractions. If the base ring is \emph{not} a domain, one gets an error as soon
as a non-zero pivot turns out to be non-invertible. Some functions,
e.g.~\kbd{mathnf} or \kbd{mathnfmod}, specifically assume that the base ring is
$\Z$.


\subsec{algdep$(x,k,\{\fl=0\})$}\kbdsidx{algdep}\label{se:algdep}
\sidx{algebraic dependence}
$x$ being real/complex, or $p$-adic, finds a polynomial of degree at most
$k$ with integer coefficients having $x$ as approximate root. Note that the
polynomial which is obtained is not necessarily the ``correct'' one. In fact
it is not even guaranteed to be irreducible. One can check the closeness
either by a polynomial evaluation (use \tet{subst}), or by computing the
roots of the polynomial given by \kbd{algdep} (use \tet{polroots}).

Internally, \tet{lindep}$([1,x,\ldots,x^k], \fl)$ is used.
A non-zero value of $\fl$ may improve on the default behavior
if the input number is known to a \emph{huge} accuracy, and you suspect the
last bits are incorrect  (this truncates the number, throwing away the least
significant bits), but default values are usually sufficient:
\bprog
? \p200
? algdep(2^(1/6)+3^(1/5), 30);      \\ wrong in 0.8s
? algdep(2^(1/6)+3^(1/5), 30, 100); \\ wrong in 0.4s
? algdep(2^(1/6)+3^(1/5), 30, 170); \\ right in 0.8s
? algdep(2^(1/6)+3^(1/5), 30, 200); \\ wrong in 1.0s
? \p250
? algdep(2^(1/6)+3^(1/5), 30);      \\ right in 1.0s
? algdep(2^(1/6)+3^(1/5), 30, 200); \\ right in 1.0s
? \p500
? algdep(2^(1/6)+3^(1/5), 30);      \\ right in 2.9s
? \p1000
? algdep(2^(1/6)+3^(1/5), 30);      \\ right in 10.6s
@eprog\noindent
The changes in \kbd{defaultprecision} only affect the quality of the
initial approximation to $2^{1/6} + 3^{1/5}$, \kbd{algdep} itself uses
exact operations (the size of its operands depend on the accuracy of the
input of course: more accurate input means slower operations).

Proceeding by increments of 5 digits of accuracy, \kbd{algdep} with default
flag produces its first correct result at 205 digits, and from then on a
steady stream of correct results.

The above example is the test case studied in a 2000 paper by Borwein and
Lisonek: Applications of integer relation algorithms, \emph{Discrete Math.},
{\bf 217}, p.~65--82. The version of PARI tested there was 1.39, which
succeeded reliably from precision 265 on, in about 200 as much time as the
current version.

The library syntax is \fun{GEN}{algdep0}{GEN x, long k, long flag}.
Also available is \fun{GEN}{algdep}{GEN x, long k} ($\fl=0$).

\subsec{charpoly$(A,\{v='x\},\{\fl=5\})$}\kbdsidx{charpoly}\label{se:charpoly}
\idx{characteristic polynomial}
of $A$ with respect to the variable $v$, i.e.~determinant of $v*I-A$ if $A$
is a square matrix.
\bprog
? charpoly([1,2;3,4]);
%1 = x^2 - 5*x - 2
? charpoly([1,2;3,4],, 't)
%2 = t^2 - 5*t - 2
@eprog\noindent
If $A$ is not a square matrix, the function returns the characteristic
polynomial of the map ``multiplication by $A$'' if $A$ is a scalar:
\bprog
? charpoly(Mod(x+2, x^3-2))
%1 = x^3 - 6*x^2 + 12*x - 10
? charpoly(I)
%2 = x^2 + 1
? charpoly(quadgen(5))
%3 = x^2 - x - 1
? charpoly(ffgen(ffinit(2,4)))
%4 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
@eprog

The value of $\fl$ is only significant for matrices, and we advise to stick
to the default value. Let $n$ be the dimension of $A$.

If $\fl=0$, same method (Le Verrier's) as for computing the adjoint matrix,
i.e.~using the traces of the powers of $A$. Assumes that $n!$ is
invertible; uses $O(n^4)$ scalar operations.

If $\fl=1$, uses Lagrange interpolation which is usually the slowest method.
Assumes that $n!$ is invertible; uses $O(n^4)$ scalar operations.

If $\fl=2$, uses the Hessenberg form. Assumes that the base ring is a field.
Uses $O(n^3)$ scalar operations, but suffers from coefficient explosion
unless the base field is finite or $\R$.

If $\fl=3$, uses Berkowitz's division free algorithm, valid over any
ring (commutative, with unit). Uses $O(n^4)$ scalar operations.

If $\fl=4$, $x$ must be integral. Uses a modular algorithm: Hessenberg form
for various small primes, then Chinese remainders.

If $\fl=5$ (default), uses the ``best'' method given $x$.
This means we use Berkowitz unless the base ring is $\Z$ (use $\fl=4$)
or a field where coefficient explosion does not occur,
e.g.~a finite field or the reals (use $\fl=2$).

The library syntax is \fun{GEN}{charpoly0}{GEN A, long v = -1, long flag}, where \kbd{v} is a variable number.
Also available are
\fun{GEN}{charpoly}{GEN x, long v} ($\fl=5$),
\fun{GEN}{caract}{GEN A, long v} ($\fl=1$),
\fun{GEN}{carhess}{GEN A, long v} ($\fl=2$),
\fun{GEN}{carberkowitz}{GEN A, long v} ($\fl=3$) and
\fun{GEN}{caradj}{GEN A, long v, GEN *pt}. In this
last case, if \var{pt} is not \kbd{NULL}, \kbd{*pt} receives the address of
the adjoint matrix of $A$ (see \tet{matadjoint}), so both can be obtained at
once.

\subsec{concat$(x,\{y\})$}\kbdsidx{concat}\label{se:concat}
Concatenation of $x$ and $y$. If $x$ or $y$ is
not a vector or matrix, it is considered as a one-dimensional vector. All
types are allowed for $x$ and $y$, but the sizes must be compatible. Note
that matrices are concatenated horizontally, i.e.~the number of rows stays
the same. Using transpositions, one can concatenate them vertically,
but it is often simpler to use \tet{matconcat}.
\bprog
? x = matid(2); y = 2*matid(2);
? concat(x,y)
%2 =
[1 0 2 0]

[0 1 0 2]
? concat(x~,y~)~
%3 =
[1 0]

[0 1]

[2 0]

[0 2]
? matconcat([x;y])
%4 =
[1 0]

[0 1]

[2 0]

[0 2]
@eprog\noindent
To concatenate vectors sideways (i.e.~to obtain a two-row or two-column
matrix), use \tet{Mat} instead, or \tet{matconcat}:
\bprog
? x = [1,2];
? y = [3,4];
? concat(x,y)
%3 = [1, 2, 3, 4]

? Mat([x,y]~)
%4 =
[1 2]

[3 4]
? matconcat([x;y])
%5 =
[1 2]

[3 4]
@eprog
Concatenating a row vector to a matrix having the same number of columns will
add the row to the matrix (top row if the vector is $x$, i.e.~comes first, and
bottom row otherwise).

The empty matrix \kbd{[;]} is considered to have a number of rows compatible
with any operation, in particular concatenation. (Note that this is
\emph{not} the case for empty vectors \kbd{[~]} or \kbd{[~]\til}.)

If $y$ is omitted, $x$ has to be a row vector or a list, in which case its
elements are concatenated, from left to right, using the above rules.
\bprog
? concat([1,2], [3,4])
%1 = [1, 2, 3, 4]
? a = [[1,2]~, [3,4]~]; concat(a)
%2 =
[1 3]

[2 4]

? concat([1,2; 3,4], [5,6]~)
%3 =
[1 2 5]

[3 4 6]
? concat([%, [7,8]~, [1,2,3,4]])
%5 =
[1 2 5 7]

[3 4 6 8]

[1 2 3 4]
@eprog

The library syntax is \fun{GEN}{concat}{GEN x, GEN y = NULL}.
\fun{GEN}{concat1}{GEN x} is a shortcut for \kbd{concat(x,NULL)}.

\subsec{forqfvec$(v,q,b,\var{expr})$}\kbdsidx{forqfvec}\label{se:forqfvec}
$q$ being a square and symmetric matrix representing a positive definite
quadratic form, evaluate \kbd{expr} for all vector $v$ such that $q(v)\leq b$.
The formal variable $v$ runs through all such vectors in turn.
\bprog
? forqfvec(v, [3,2;2,3], 3, print(v))
[0, 1]~
[1, 0]~
[-1, 1]~
@eprog

The library syntax is \fun{void}{forqfvec0}{GEN v, GEN q = NULL, GEN b}.
The following function is also available:
\fun{void}{forqfvec}{void *E, long (*fun)(void *, GEN, double), GEN q, GEN b}:
Evaluate \kbd{fun(E,v,m)} on all $v$ such that $q(v)<b$, where $v$ is a
\typ{VECSMALL} and $m=q(v)$ is a C double. The function \kbd{fun} must
return $0$, unless \kbd{forqfvec} should stop, in which case, it should
return $1$.

\subsec{lindep$(v,\{\fl=0\})$}\kbdsidx{lindep}\label{se:lindep}
\sidx{linear dependence} finds a small non-trivial integral linear
combination between components of $v$. If none can be found return an empty
vector.

If $v$ is a vector with real/complex entries we use a floating point
(variable precision) LLL algorithm. If $\fl = 0$ the accuracy is chosen
internally using a crude heuristic. If $\fl > 0$ the computation is done with
an accuracy of $\fl$ decimal digits. To get meaningful results in the latter
case, the parameter $\fl$ should be smaller than the number of correct
decimal digits in the input.

\bprog
? lindep([sqrt(2), sqrt(3), sqrt(2)+sqrt(3)])
%1 = [-1, -1, 1]~
@eprog

If $v$ is $p$-adic, $\fl$ is ignored and the algorithm LLL-reduces a
suitable (dual) lattice.
\bprog
? lindep([1, 2 + 3 + 3^2 + 3^3 + 3^4 + O(3^5)])
%2 = [1, -2]~
@eprog

If $v$ is a matrix, $\fl$ is ignored and the function returns a non trivial
kernel vector (combination of the columns).
\bprog
? lindep([1,2,3;4,5,6;7,8,9])
%3 = [1, -2, 1]~
@eprog

If $v$ contains polynomials or power series over some base field, finds a
linear relation with coefficients in the field.
\bprog
? lindep([x*y, x^2 + y, x^2*y + x*y^2, 1])
%4 = [y, y, -1, -y^2]~
@eprog\noindent For better control, it is preferable to use \typ{POL} rather
than \typ{SER} in the input, otherwise one gets a linear combination which is
$t$-adically small, but not necessarily $0$. Indeed, power series are first
converted to the minimal absolute accuracy occurring among the entries of $v$
(which can cause some coefficients to be ignored), then truncated to
polynomials:
\bprog
? v = [t^2+O(t^4), 1+O(t^2)]; L=lindep(v)
%1 = [1, 0]~
? v*L
%2 = t^2+O(t^4)  \\ small but not 0
@eprog

The library syntax is \fun{GEN}{lindep0}{GEN v, long flag}.
Also available are \fun{GEN}{lindep}{GEN v} (real/complex entries,
$\fl=0$), \fun{GEN}{lindep2}{GEN v, long flag} (real/complex entries)
\fun{GEN}{padic_lindep}{GEN v} ($p$-adic entries) and
\fun{GEN}{Xadic_lindep}{GEN v} (polynomial entries).
Finally \fun{GEN}{deplin}{GEN v} returns a non-zero kernel vector for a
\typ{MAT} input.

\subsec{listcreate$()$}\kbdsidx{listcreate}\label{se:listcreate}
Creates an empty list. This routine used to have a mandatory argument,
which is now ignored (for backward compatibility). In fact, this function
has become redundant and obsolete; it will disappear in future versions of
PARI: just use \kbd{List()}
% \syn{NO}

\subsec{listinsert$(L,x,n)$}\kbdsidx{listinsert}\label{se:listinsert}
Inserts the object $x$ at
position $n$ in $L$ (which must be of type \typ{LIST}). This has
complexity $O(\#L - n + 1)$: all the
remaining elements of \var{list} (from position $n+1$ onwards) are shifted
to the right.

The library syntax is \fun{GEN}{listinsert}{GEN L, GEN x, long n}.

\subsec{listkill$(L)$}\kbdsidx{listkill}\label{se:listkill}
Obsolete, retained for backward compatibility. Just use \kbd{L = List()}
instead of \kbd{listkill(L)}. In most cases, you won't even need that, e.g.
local variables are automatically cleared when a user function returns.

The library syntax is \fun{void}{listkill}{GEN L}.

\subsec{listpop$(\var{list},\{n\})$}\kbdsidx{listpop}\label{se:listpop}
Removes the $n$-th element of the list
\var{list} (which must be of type \typ{LIST}). If $n$ is omitted,
or greater than the list current length, removes the last element.
If the list is already empty, do nothing. This runs in time $O(\#L - n + 1)$.

The library syntax is \fun{void}{listpop}{GEN list, long n}.

\subsec{listput$(\var{list},x,\{n\})$}\kbdsidx{listput}\label{se:listput}
Sets the $n$-th element of the list
\var{list} (which must be of type \typ{LIST}) equal to $x$. If $n$ is omitted,
or greater than the list length, appends $x$.
You may put an element into an occupied cell (not changing the
list length), but it is easier to use the standard \kbd{list[n] = x}
construct. This runs in time $O(\#L)$ in the worst case (when the list must
be reallocated), but in time $O(1)$ on average: any number of successive
\kbd{listput}s run in time $O(\#L)$, where $\#L$ denotes the list
\emph{final} length.

The library syntax is \fun{GEN}{listput}{GEN list, GEN x, long n}.

\subsec{listsort$(L,\{\fl=0\})$}\kbdsidx{listsort}\label{se:listsort}
Sorts the \typ{LIST} \var{list} in place, with respect to the (somewhat
arbitrary) universal comparison function \tet{cmp}. In particular, the
ordering is the same as for sets and \tet{setsearch} can be used on a sorted
list.
\bprog
? L = List([1,2,4,1,3,-1]); listsort(L); L
%1 = List([-1, 1, 1, 2, 3, 4])
? setsearch(L, 4)
%2 = 6
? setsearch(L, -2)
%3 = 0
@eprog\noindent This is faster than the \kbd{vecsort} command since the list
is sorted in place: no copy is made. No value returned.

If $\fl$ is non-zero, suppresses all repeated coefficients.

The library syntax is \fun{void}{listsort}{GEN L, long flag}.

\subsec{matadjoint$(M,\{\fl=0\})$}\kbdsidx{matadjoint}\label{se:matadjoint}
\idx{adjoint matrix} of $M$, i.e.~a matrix $N$
of cofactors of $M$, satisfying $M*N=\det(M)*\Id$. $M$ must be a
(non-necessarily invertible) square matrix of dimension $n$.
If $\fl$ is 0 or omitted, we try to use Leverrier-Faddeev's algorithm,
which assumes that $n!$ invertible. If it fails or $\fl = 1$,
compute $T = \kbd{charpoly}(M)$ independently first and return
$(-1)^{n-1} (T(x)-T(0))/x$ evaluated at $M$.
\bprog
? a = [1,2,3;3,4,5;6,7,8] * Mod(1,4);
%2 =
[Mod(1, 4) Mod(2, 4) Mod(3, 4)]

[Mod(3, 4) Mod(0, 4) Mod(1, 4)]

[Mod(2, 4) Mod(3, 4) Mod(0, 4)]
@eprog\noindent
Both algorithms use $O(n^4)$ operations in the base ring, and are usually
slower than computing the characteristic polynomial or the inverse of $M$
directly.

The library syntax is \fun{GEN}{matadjoint0}{GEN M, long flag}.
Also available are
\fun{GEN}{adj}{GEN x} (\fl=0) and
\fun{GEN}{adjsafe}{GEN x} (\fl=1).

\subsec{matcompanion$(x)$}\kbdsidx{matcompanion}\label{se:matcompanion}
The left companion matrix to the non-zero polynomial $x$.

The library syntax is \fun{GEN}{matcompanion}{GEN x}.

\subsec{matconcat$(v)$}\kbdsidx{matconcat}\label{se:matconcat}
Returns a \typ{MAT} built from the entries of $v$, which may
be a \typ{VEC} (concatenate horizontally), a \typ{COL} (concatenate
vertically), or a \typ{MAT} (concatenate vertically each column, and
concatenate vertically the resulting matrices). The entries of $v$ are always
considered as matrices: they can themselves be \typ{VEC} (seen as a row
matrix), a \typ{COL} seen as a column matrix), a \typ{MAT}, or a scalar (seen
as an $1 \times 1$ matrix).
\bprog
? A=[1,2;3,4]; B=[5,6]~; C=[7,8]; D=9;
? matconcat([A, B]) \\ horizontal
%1 =
[1 2 5]

[3 4 6]
? matconcat([A, C]~) \\ vertical
%2 =
[1 2]

[3 4]

[7 8]
? matconcat([A, B; C, D]) \\ block matrix
%3 =
[1 2 5]

[3 4 6]

[7 8 9]
@eprog\noindent
If the dimensions of the entries to concatenate do not match up, the above
rules are extended as follows:

\item each entry $v_{i,j}$ of $v$ has a natural length and height: $1 \times
1$ for a scalar, $1 \times n$ for a \typ{VEC} of length $n$, $n \times 1$
for a \typ{COL}, $m \times n$ for an $m\times n$ \typ{MAT}

\item let $H_i$ be the maximum over $j$ of the lengths of the $v_{i,j}$,
let $L_j$ be the maximum over $i$ of the heights of the $v_{i,j}$.
The dimensions of the $(i,j)$-th block in the concatenated matrix are
$H_i \times L_j$.

\item a scalar $s = v_{i,j}$ is considered as $s$ times an identity matrix
of the block dimension $\min (H_i,L_j)$

\item blocks are extended by 0 columns on the right and 0 rows at the
bottom, as needed.

\bprog
? matconcat([1, [2,3]~, [4,5,6]~]) \\ horizontal
%4 =
[1 2 4]

[0 3 5]

[0 0 6]
? matconcat([1, [2,3], [4,5,6]]~) \\ vertical
%5 =
[1 0 0]

[2 3 0]

[4 5 6]
? matconcat([B, C; A, D]) \\ block matrix
%6 =
[5 0 7 8]

[6 0 0 0]

[1 2 9 0]

[3 4 0 9]
? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V])) \\ block diagonal
%7 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
@eprog

The library syntax is \fun{GEN}{matconcat}{GEN v}.

\subsec{matdet$(x,\{\fl=0\})$}\kbdsidx{matdet}\label{se:matdet}
Determinant of the square matrix $x$.

If $\fl=0$, uses an appropriate algorithm depending on the coefficients:

\item integer entries: modular method due to Dixon, Pernet and Stein.

\item real or $p$-adic entries: classical Gaussian elimination using maximal
pivot.

\item intmod entries: classical Gaussian elimination using first non-zero
pivot.

\item other cases: Gauss-Bareiss.

If $\fl=1$, uses classical Gaussian elimination with appropriate pivoting
strategy (maximal pivot for real or $p$-adic coefficients). This is usually
worse than the default.

The library syntax is \fun{GEN}{det0}{GEN x, long flag}.
Also available are \fun{GEN}{det}{GEN x} ($\fl=0$),
\fun{GEN}{det2}{GEN x} ($\fl=1$) and \fun{GEN}{ZM_det}{GEN x} for integer
entries.

\subsec{matdetint$(B)$}\kbdsidx{matdetint}\label{se:matdetint}
Let $B$ be an $m\times n$ matrix with integer coefficients. The
\emph{determinant} $D$ of the lattice generated by the columns of $B$ is
the square root of $\det(B^T B)$ if $B$ has maximal rank $m$, and $0$
otherwise.

This function uses the Gauss-Bareiss algorithm to compute a positive
\emph{multiple} of $D$. When $B$ is square, the function actually returns
$D = |\det B|$.

This function is useful in conjunction with \kbd{mathnfmod}, which needs to
know such a multiple. If the rank is maximal and the matrix non-square,
you can obtain $D$ exactly using
\bprog
  matdet( mathnfmod(B, matdetint(B)) )
@eprog\noindent
Note that as soon as one of the dimensions gets large ($m$ or $n$ is larger
than 20, say), it will often be much faster to use \kbd{mathnf(B, 1)} or
\kbd{mathnf(B, 4)} directly.

The library syntax is \fun{GEN}{detint}{GEN B}.

\subsec{matdiagonal$(x)$}\kbdsidx{matdiagonal}\label{se:matdiagonal}
$x$ being a vector, creates the diagonal matrix
whose diagonal entries are those of $x$.
\bprog
? matdiagonal([1,2,3]);
%1 =
[1 0 0]

[0 2 0]

[0 0 3]
@eprog\noindent Block diagonal matrices are easily created using
\tet{matconcat}:
\bprog
? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V]))
%1 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
@eprog

The library syntax is \fun{GEN}{diagonal}{GEN x}.

\subsec{mateigen$(x,\{\fl=0\})$}\kbdsidx{mateigen}\label{se:mateigen}
Returns the (complex) eigenvectors of $x$ as columns of a matrix.
If $\fl=1$, return $[L,H]$, where $L$ contains the
eigenvalues and $H$ the corresponding eigenvectors; multiple eigenvalues are
repeated according to the eigenspace dimension (which may be less
than the eigenvalue multiplicity in the characteristic polynomial).

This function first computes the characteristic polynomial of $x$ and
approximates its complex roots $(\lambda_i)$, then tries to compute the
eigenspaces as kernels of the $x - \lambda_i$. This algorithm is
ill-conditioned and is likely to miss kernel vectors if some roots of the
characteristic polynomial are close, in particular if it has multiple roots.
\bprog
? A = [13,2; 10,14]; mateigen(A)
%1 =
[-1/2 2/5]

[   1   1]
? [L,H] = mateigen(A, 1);
? L
%3 = [9, 18]
? H
%4 =
[-1/2 2/5]

[   1   1]
@eprog\noindent
For symmetric matrices, use \tet{qfjacobi} instead; for Hermitian matrices,
compute
\bprog
 A = real(x);
 B = imag(x);
 y = matconcat([A, -B; B, A]);
@eprog\noindent and apply \kbd{qfjacobi} to $y$.

The library syntax is \fun{GEN}{mateigen}{GEN x, long flag, long prec}.
Also available is \fun{GEN}{eigen}{GEN x, long prec} ($\fl = 0$)

\subsec{matfrobenius$(M,\{\fl\},\{v='x\})$}\kbdsidx{matfrobenius}\label{se:matfrobenius}
Returns the Frobenius form of
the square matrix \kbd{M}. If $\fl=1$, returns only the elementary divisors as
a vector of polynomials in the variable \kbd{v}.  If $\fl=2$, returns a
two-components vector [F,B] where \kbd{F} is the Frobenius form and \kbd{B} is
the basis change so that $M=B^{-1}FB$.

The library syntax is \fun{GEN}{matfrobenius}{GEN M, long flag, long v = -1}, where \kbd{v} is a variable number.

\subsec{mathess$(x)$}\kbdsidx{mathess}\label{se:mathess}
Returns a matrix similar to the square matrix $x$, which is in upper Hessenberg
form (zero entries below the first subdiagonal).

The library syntax is \fun{GEN}{hess}{GEN x}.

\subsec{mathilbert$(n)$}\kbdsidx{mathilbert}\label{se:mathilbert}
$x$ being a \kbd{long}, creates the
\idx{Hilbert matrix}of order $x$, i.e.~the matrix whose coefficient
($i$,$j$) is $1/ (i+j-1)$.

The library syntax is \fun{GEN}{mathilbert}{long n}.

\subsec{mathnf$(M,\{\fl=0\})$}\kbdsidx{mathnf}\label{se:mathnf}
Let $R$ be a Euclidean ring, equal to $\Z$ or to $K[X]$ for some field
$K$. If $M$ is a (not necessarily square) matrix with entries in $R$, this
routine finds the \emph{upper triangular} \idx{Hermite normal form} of $M$.
If the rank of $M$ is equal to its number of rows, this is a square
matrix. In general, the columns of the result form a basis of the $R$-module
spanned by the columns of $M$.

The values $0,1,2,3$ of $\fl$ have a binary meaning, analogous to the one
in \tet{matsnf}; in this case, binary digits of $\fl$ mean:

\item 1 (complete output): if set, outputs $[H,U]$, where $H$ is the Hermite
normal form of $M$, and $U$ is a transformation matrix such that $MU=[0|H]$.
The matrix $U$ belongs to $\text{GL}(R)$. When $M$ has a large kernel, the
entries of $U$ are in general huge.

\item 2 (generic input): \emph{Deprecated}. If set, assume that $R = K[X]$ is
a polynomial ring; otherwise, assume that $R = \Z$. This flag is now useless
since the routine always checks whether the matrix has integral entries.

\noindent For these 4 values, we use a naive algorithm, which behaves well
in small dimension only. Larger values correspond to different algorithms,
are restricted to \emph{integer} matrices, and all output the unimodular
matrix $U$. From now on all matrices have integral entries.

\item $\fl=4$, returns $[H,U]$ as in ``complete output'' above, using a
variant of \idx{LLL} reduction along the way. The matrix $U$ is provably
small in the $L_2$ sense, and in general close to optimal; but the
reduction is in general slow, although provably polynomial-time.

If $\fl=5$, uses Batut's algorithm and output $[H,U,P]$, such that $H$ and
$U$ are as before and $P$ is a permutation of the rows such that $P$ applied
to $MU$ gives $H$. This is in general faster than $\fl=4$ but the matrix $U$
is usually worse; it is heuristically smaller than with the default algorithm.

When the matrix is dense and the dimension is large (bigger than 100, say),
$\fl = 4$ will be fastest. When $M$ has maximal rank, then
\bprog
  H = mathnfmod(M, matdetint(M))
@eprog\noindent will be even faster. You can then recover $U$ as $M^{-1}H$.

\bprog
? M = matrix(3,4,i,j,random([-5,5]))
%1 =
[ 0 2  3  0]

[-5 3 -5 -5]

[ 4 3 -5  4]

? [H,U] = mathnf(M, 1);
? U
%3 =
[-1 0 -1 0]

[ 0 5  3 2]

[ 0 3  1 1]

[ 1 0  0 0]

? H
%5 =
[19 9 7]

[ 0 9 1]

[ 0 0 1]

? M*U
%6 =
[0 19 9 7]

[0  0 9 1]

[0  0 0 1]
@eprog

For convenience, $M$ is allowed to be a \typ{VEC}, which is then
automatically converted to a \typ{MAT}, as per the \tet{Mat} function.
For instance to solve the generalized extended gcd problem, one may use
\bprog
? v = [116085838, 181081878, 314252913,10346840];
? [H,U] = mathnf(v, 1);
? U
%2 =
[ 103 -603    15  -88]

[-146   13 -1208  352]

[  58  220   678 -167]

[-362 -144   381 -101]
? v*U
%3 = [0, 0, 0, 1]
@eprog\noindent This also allows to input a matrix as a \typ{VEC} of
\typ{COL}s of the same length (which \kbd{Mat} would concatenate to
the \typ{MAT} having those columns):
\bprog
? v = [[1,0,4]~, [3,3,4]~, [0,-4,-5]~]; mathnf(v)
%1 =
[47 32 12]

[ 0  1  0]

[ 0  0  1]
@eprog

The library syntax is \fun{GEN}{mathnf0}{GEN M, long flag}.
Also available are \fun{GEN}{hnf}{GEN M} ($\fl=0$) and
\fun{GEN}{hnfall}{GEN M} ($\fl=1$). To reduce \emph{huge} relation matrices
(sparse with small entries, say dimension $400$ or more), you can use the
pair \kbd{hnfspec} / \kbd{hnfadd}. Since this is quite technical and the
calling interface may change, they are not documented yet. Look at the code
in \kbd{basemath/hnf\_snf.c}.

\subsec{mathnfmod$(x,d)$}\kbdsidx{mathnfmod}\label{se:mathnfmod}
If $x$ is a (not necessarily square) matrix of
maximal rank with integer entries, and $d$ is a multiple of the (non-zero)
determinant of the lattice spanned by the columns of $x$, finds the
\emph{upper triangular} \idx{Hermite normal form} of $x$.

If the rank of $x$ is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of $x$. Even when $d$ is known, this is in general
slower than \kbd{mathnf} but uses much less memory.

The library syntax is \fun{GEN}{hnfmod}{GEN x, GEN d}.

\subsec{mathnfmodid$(x,d)$}\kbdsidx{mathnfmodid}\label{se:mathnfmodid}
Outputs the (upper triangular)
\idx{Hermite normal form} of $x$ concatenated with the diagonal
matrix with diagonal $d$. Assumes that $x$ has integer entries.
Variant: if $d$ is an integer instead of a vector, concatenate $d$ times the
identity matrix.
\bprog
? m=[0,7;-1,0;-1,-1]
%1 =
[ 0  7]

[-1  0]

[-1 -1]
? mathnfmodid(m, [6,2,2])
%2 =
[2 1 1]

[0 1 0]

[0 0 1]
? mathnfmodid(m, 10)
%3 =
[10 7 3]

[ 0 1 0]

[ 0 0 1]
@eprog

The library syntax is \fun{GEN}{hnfmodid}{GEN x, GEN d}.

\subsec{mathouseholder$(Q,v)$}\kbdsidx{mathouseholder}\label{se:mathouseholder}
\sidx{Householder transform}applies a sequence $Q$ of Householder
transforms, as returned by \kbd{matqr}$(M,1)$ to the vector or matrix $v$.

The library syntax is \fun{GEN}{mathouseholder}{GEN Q, GEN v}.

\subsec{matid$(n)$}\kbdsidx{matid}\label{se:matid}
Creates the $n\times n$ identity matrix.

The library syntax is \fun{GEN}{matid}{long n}.

\subsec{matimage$(x,\{\fl=0\})$}\kbdsidx{matimage}\label{se:matimage}
Gives a basis for the image of the
matrix $x$ as columns of a matrix. A priori the matrix can have entries of
any type. If $\fl=0$, use standard Gauss pivot. If $\fl=1$, use
\kbd{matsupplement} (much slower: keep the default flag!).

The library syntax is \fun{GEN}{matimage0}{GEN x, long flag}.
Also available is \fun{GEN}{image}{GEN x} ($\fl=0$).

\subsec{matimagecompl$(x)$}\kbdsidx{matimagecompl}\label{se:matimagecompl}
Gives the vector of the column indices which
are not extracted by the function \kbd{matimage}, as a permutation
(\typ{VECSMALL}). Hence the number of
components of \kbd{matimagecompl(x)} plus the number of columns of
\kbd{matimage(x)} is equal to the number of columns of the matrix $x$.

The library syntax is \fun{GEN}{imagecompl}{GEN x}.

\subsec{matindexrank$(x)$}\kbdsidx{matindexrank}\label{se:matindexrank}
$x$ being a matrix of rank $r$, returns a vector with two
\typ{VECSMALL} components $y$ and $z$ of length $r$ giving a list of rows
and columns respectively (starting from 1) such that the extracted matrix
obtained from these two vectors using $\tet{vecextract}(x,y,z)$ is
invertible.

The library syntax is \fun{GEN}{indexrank}{GEN x}.

\subsec{matintersect$(x,y)$}\kbdsidx{matintersect}\label{se:matintersect}
$x$ and $y$ being two matrices with the same
number of rows each of whose columns are independent, finds a basis of the
$\Q$-vector space equal to the intersection of the spaces spanned by the
columns of $x$ and $y$ respectively. The faster function
\tet{idealintersect} can be used to intersect fractional ideals (projective
$\Z_K$ modules of rank $1$); the slower but much more general function
\tet{nfhnf} can be used to intersect general $\Z_K$-modules.

The library syntax is \fun{GEN}{intersect}{GEN x, GEN y}.

\subsec{matinverseimage$(x,y)$}\kbdsidx{matinverseimage}\label{se:matinverseimage}
Given a matrix $x$ and
a column vector or matrix $y$, returns a preimage $z$ of $y$ by $x$ if one
exists (i.e such that $x z = y$), an empty vector or matrix otherwise. The
complete inverse image is $z + \text{Ker} x$, where a basis of the kernel of
$x$ may be obtained by \kbd{matker}.
\bprog
? M = [1,2;2,4];
? matinverseimage(M, [1,2]~)
%2 = [1, 0]~
? matinverseimage(M, [3,4]~)
%3 = []~    \\@com no solution
? matinverseimage(M, [1,3,6;2,6,12])
%4 =
[1 3 6]

[0 0 0]
? matinverseimage(M, [1,2;3,4])
%5 = [;]    \\@com no solution
? K = matker(M)
%6 =
[-2]

[1]
@eprog

The library syntax is \fun{GEN}{inverseimage}{GEN x, GEN y}.

\subsec{matisdiagonal$(x)$}\kbdsidx{matisdiagonal}\label{se:matisdiagonal}
Returns true (1) if $x$ is a diagonal matrix, false (0) if not.

The library syntax is \fun{GEN}{isdiagonal}{GEN x}.

\subsec{matker$(x,\{\fl=0\})$}\kbdsidx{matker}\label{se:matker}
Gives a basis for the kernel of the matrix $x$ as columns of a matrix.
The matrix can have entries of any type, provided they are compatible with
the generic arithmetic operations ($+$, $\times$ and $/$).

If $x$ is known to have integral entries, set $\fl=1$.

The library syntax is \fun{GEN}{matker0}{GEN x, long flag}.
Also available are \fun{GEN}{ker}{GEN x} ($\fl=0$),
\fun{GEN}{keri}{GEN x} ($\fl=1$).

\subsec{matkerint$(x,\{\fl=0\})$}\kbdsidx{matkerint}\label{se:matkerint}
Gives an \idx{LLL}-reduced $\Z$-basis
for the lattice equal to the kernel of the matrix $x$ as columns of the
matrix $x$ with integer entries (rational entries are not permitted).

If $\fl=0$, uses an integer LLL algorithm.

If $\fl=1$, uses $\kbd{matrixqz}(x,-2)$. Many orders of magnitude slower
than the default: never use this.

The library syntax is \fun{GEN}{matkerint0}{GEN x, long flag}.
See also \fun{GEN}{kerint}{GEN x} ($\fl=0$), which is a trivial
wrapper around
\bprog
ZM_lll(ZM_lll(x, 0.99, LLL_KER), 0.99, LLL_INPLACE);
@eprog\noindent Remove the outermost \kbd{ZM\_lll} if LLL-reduction is not
desired (saves time).

\subsec{matmuldiagonal$(x,d)$}\kbdsidx{matmuldiagonal}\label{se:matmuldiagonal}
Product of the matrix $x$ by the diagonal
matrix whose diagonal entries are those of the vector $d$. Equivalent to,
but much faster than $x*\kbd{matdiagonal}(d)$.

The library syntax is \fun{GEN}{matmuldiagonal}{GEN x, GEN d}.

\subsec{matmultodiagonal$(x,y)$}\kbdsidx{matmultodiagonal}\label{se:matmultodiagonal}
Product of the matrices $x$ and $y$ assuming that the result is a
diagonal matrix. Much faster than $x*y$ in that case. The result is
undefined if $x*y$ is not diagonal.

The library syntax is \fun{GEN}{matmultodiagonal}{GEN x, GEN y}.

\subsec{matpascal$(n,\{q\})$}\kbdsidx{matpascal}\label{se:matpascal}
Creates as a matrix the lower triangular
\idx{Pascal triangle} of order $x+1$ (i.e.~with binomial coefficients
up to $x$). If $q$ is given, compute the $q$-Pascal triangle (i.e.~using
$q$-binomial coefficients).

The library syntax is \fun{GEN}{matqpascal}{long n, GEN q = NULL}.
Also available is \fun{GEN}{matpascal}{GEN x}.

\subsec{matqr$(M,\{\fl=0\})$}\kbdsidx{matqr}\label{se:matqr}
Returns $[Q,R]$, the \idx{QR-decomposition} of the square invertible
matrix $M$ with real entries: $Q$ is orthogonal and $R$ upper triangular. If
$\fl=1$, the orthogonal matrix is returned as a sequence of Householder
transforms: applying such a sequence is stabler and faster than
multiplication by the corresponding $Q$ matrix.\sidx{Householder transform}
More precisely, if
\bprog
  [Q,R] = matqr(M);
  [q,r] = matqr(M, 1);
@eprog\noindent then $r = R$ and \kbd{mathouseholder}$(q, M)$ is $R$;
furthermore
\bprog
  mathouseholder(q, matid(#M)) == Q~
@eprog\noindent the inverse of $Q$. This function raises an error if the
precision is too low or $x$ is singular.

The library syntax is \fun{GEN}{matqr}{GEN M, long flag, long prec}.

\subsec{matrank$(x)$}\kbdsidx{matrank}\label{se:matrank}
Rank of the matrix $x$.

The library syntax is \fun{long}{rank}{GEN x}.

\subsec{matrix$(m,n,\{X\},\{Y\},\{\var{expr}=0\})$}\kbdsidx{matrix}\label{se:matrix}
Creation of the
$m\times n$ matrix whose coefficients are given by the expression
\var{expr}. There are two formal parameters in \var{expr}, the first one
($X$) corresponding to the rows, the second ($Y$) to the columns, and $X$
goes from 1 to $m$, $Y$ goes from 1 to $n$. If one of the last 3 parameters
is omitted, fill the matrix with zeroes.
%\syn{NO}

\subsec{matrixqz$(A,\{p=0\})$}\kbdsidx{matrixqz}\label{se:matrixqz}
$A$ being an $m\times n$ matrix in $M_{m,n}(\Q)$, let
$\text{Im}_\Q A$ (resp.~$\text{Im}_\Z A$) the $\Q$-vector space
(resp.~the $\Z$-module) spanned by the columns of $A$. This function has
varying behavior depending on the sign of $p$:

If $p \geq 0$, $A$ is assumed to have maximal rank $n\leq m$. The function
returns a matrix $B\in M_{m,n}(\Z)$, with $\text{Im}_\Q B = \text{Im}_\Q A$,
such that the GCD of all its $n\times n$ minors is coprime to
$p$; in particular, if $p = 0$ (default), this GCD is $1$.
\bprog
? minors(x) = vector(#x[,1], i, matdet(x[^i,]));
? A = [3,1/7; 5,3/7; 7,5/7]; minors(A)
%1 = [4/7, 8/7, 4/7]   \\ determinants of all 2x2 minors
? B = matrixqz(A)
%2 =
[3 1]

[5 2]

[7 3]
? minors(%)
%3 = [1, 2, 1]   \\ B integral with coprime minors
@eprog

If $p=-1$, returns the HNF basis of the lattice $\Z^n \cap \text{Im}_\Z A$.

If $p=-2$, returns the HNF basis of the lattice $\Z^n \cap \text{Im}_\Q A$.
\bprog
? matrixqz(A,-1)
%4 =
[8 5]

[4 3]

[0 1]

? matrixqz(A,-2)
%5 =
[2 -1]

[1 0]

[0 1]
@eprog

The library syntax is \fun{GEN}{matrixqz0}{GEN A, GEN p = NULL}.

\subsec{matsize$(x)$}\kbdsidx{matsize}\label{se:matsize}
$x$ being a vector or matrix, returns a row vector
with two components, the first being the number of rows (1 for a row vector),
the second the number of columns (1 for a column vector).

The library syntax is \fun{GEN}{matsize}{GEN x}.

\subsec{matsnf$(X,\{\fl=0\})$}\kbdsidx{matsnf}\label{se:matsnf}
If $X$ is a (singular or non-singular) matrix outputs the vector of
\idx{elementary divisors} of $X$, i.e.~the diagonal of the
\idx{Smith normal form} of $X$, normalized so that $d_n \mid d_{n-1} \mid
\ldots \mid d_1$.

The binary digits of \fl\ mean:

1 (complete output): if set, outputs $[U,V,D]$, where $U$ and $V$ are two
unimodular matrices such that $UXV$ is the diagonal matrix $D$. Otherwise
output only the diagonal of $D$. If $X$ is not a square matrix, then $D$
will be a square diagonal matrix padded with zeros on the left or the top.

2 (generic input): if set, allows polynomial entries, in which case the
input matrix must be square. Otherwise, assume that $X$ has integer
coefficients with arbitrary shape.

4 (cleanup): if set, cleans up the output. This means that elementary
divisors equal to $1$ will be deleted, i.e.~outputs a shortened vector $D'$
instead of $D$. If complete output was required, returns $[U',V',D']$ so
that $U'XV' = D'$ holds. If this flag is set, $X$ is allowed to be of the
form `vector of elementary divisors' or $[U,V,D]$ as would normally be output with the cleanup flag
unset.

The library syntax is \fun{GEN}{matsnf0}{GEN X, long flag}.

\subsec{matsolve$(M,B)$}\kbdsidx{matsolve}\label{se:matsolve}
$M$ being an invertible matrix and $B$ a column
vector, finds the solution $X$ of $MX=B$, using Dixon $p$-adic lifting method
if $M$ and $B$ are integral and Gaussian elimination otherwise. This
has the same effect as, but is faster, than $M^{-1}*B$.

The library syntax is \fun{GEN}{gauss}{GEN M, GEN B}.
For integral input, the function
\fun{GEN}{ZM_gauss}{GEN M,GEN B} is also available.

\subsec{matsolvemod$(M,D,B,\{\fl=0\})$}\kbdsidx{matsolvemod}\label{se:matsolvemod}
$M$ being any integral matrix,
$D$ a column vector of non-negative integer moduli, and $B$ an integral
column vector, gives a small integer solution to the system of congruences
$\sum_i m_{i,j}x_j\equiv b_i\pmod{d_i}$ if one exists, otherwise returns
zero. Shorthand notation: $B$ (resp.~$D$) can be given as a single integer,
in which case all the $b_i$ (resp.~$d_i$) above are taken to be equal to $B$
(resp.~$D$).
\bprog
? M = [1,2;3,4];
? matsolvemod(M, [3,4]~, [1,2]~)
%2 = [-2, 0]~
? matsolvemod(M, 3, 1) \\ M X = [1,1]~ over F_3
%3 = [-1, 1]~
? matsolvemod(M, [3,0]~, [1,2]~) \\ x + 2y = 1 (mod 3), 3x + 4y = 2 (in Z)
%4 = [6, -4]~
@eprog
If $\fl=1$, all solutions are returned in the form of a two-component row
vector $[x,u]$, where $x$ is a small integer solution to the system of
congruences and $u$ is a matrix whose columns give a basis of the homogeneous
system (so that all solutions can be obtained by adding $x$ to any linear
combination of columns of $u$). If no solution exists, returns zero.

The library syntax is \fun{GEN}{matsolvemod0}{GEN M, GEN D, GEN B, long flag}.
Also available are \fun{GEN}{gaussmodulo}{GEN M, GEN D, GEN B}
($\fl=0$) and \fun{GEN}{gaussmodulo2}{GEN M, GEN D, GEN B} ($\fl=1$).

\subsec{matsupplement$(x)$}\kbdsidx{matsupplement}\label{se:matsupplement}
Assuming that the columns of the matrix $x$
are linearly independent (if they are not, an error message is issued), finds
a square invertible matrix whose first columns are the columns of $x$,
i.e.~supplement the columns of $x$ to a basis of the whole space.
\bprog
? matsupplement([1;2])
%1 =
[1 0]

[2 1]
@eprog
Raises an error if $x$ has 0 columns, since (due to a long standing design
bug), the dimension of the ambient space (the number of rows) is unknown in
this case:
\bprog
? matsupplement(matrix(2,0))
  ***   at top-level: matsupplement(matrix
  ***                 ^--------------------
  *** matsupplement: sorry, suppl [empty matrix] is not yet implemented.
@eprog

The library syntax is \fun{GEN}{suppl}{GEN x}.

\subsec{mattranspose$(x)$}\kbdsidx{mattranspose}\label{se:mattranspose}
Transpose of $x$ (also $x\til$).
This has an effect only on vectors and matrices.

The library syntax is \fun{GEN}{gtrans}{GEN x}.

\subsec{minpoly$(A,\{v='x\})$}\kbdsidx{minpoly}\label{se:minpoly}
\idx{minimal polynomial}
of $A$ with respect to the variable $v$., i.e. the monic polynomial $P$
of minimal degree (in the variable $v$) such that $P(A) = 0$.

The library syntax is \fun{GEN}{minpoly}{GEN A, long v = -1}, where \kbd{v} is a variable number.

\subsec{norml2$(x)$}\kbdsidx{norml2}\label{se:norml2}
Square of the $L^2$-norm of $x$. More precisely,
if $x$ is a scalar, $\kbd{norml2}(x)$ is defined to be the square
of the complex modulus of $x$ (real \typ{QUAD}s are not supported).
If $x$ is a polynomial, a (row or column) vector or a matrix, \kbd{norml2($x$)} is
defined recursively as $\sum_i \kbd{norml2}(x_i)$, where $(x_i)$ run through
the components of $x$. In particular, this yields the usual $\sum |x_i|^2$
(resp.~$\sum |x_{i,j}|^2$) if $x$ is a polynomial or vector (resp.~matrix) with
complex components.

\bprog
? norml2( [ 1, 2, 3 ] )      \\ vector
%1 = 14
? norml2( [ 1, 2; 3, 4] )   \\ matrix
%2 = 30
? norml2( 2*I + x )
%3 = 5
? norml2( [ [1,2], [3,4], 5, 6 ] )   \\ recursively defined
%4 = 91
@eprog

The library syntax is \fun{GEN}{gnorml2}{GEN x}.

\subsec{normlp$(x,\{p\})$}\kbdsidx{normlp}\label{se:normlp}
$L^p$-norm of $x$; sup norm if $p$ is omitted. More precisely,
if $x$ is a scalar, \kbd{normlp}$(x, p)$ is defined to be \kbd{abs}$(x)$.
If $x$ is a polynomial, a (row or column) vector or a matrix:

\item  if $p$ is omitted, \kbd{normlp($x$)} is defined recursively as
$\max_i \kbd{normlp}(x_i))$, where $(x_i)$ run through the components of~$x$.
In particular, this yields the usual sup norm if $x$ is a polynomial or
vector with complex components.

\item otherwise, \kbd{normlp($x$, $p$)} is defined recursively as $(\sum_i
\kbd{normlp}^p(x_i,p))^{1/p}$. In particular, this yields the usual $(\sum
|x_i|^p)^{1/p}$ if $x$ is a polynomial or vector with complex components.

\bprog
? v = [1,-2,3]; normlp(v)      \\ vector
%1 = 3
? M = [1,-2;-3,4]; normlp(M)   \\ matrix
%2 = 4
? T = (1+I) + I*x^2; normlp(T)
%3 = 1.4142135623730950488016887242096980786
? normlp([[1,2], [3,4], 5, 6])   \\ recursively defined
%4 = 6

? normlp(v, 1)
%5 = 6
? normlp(M, 1)
%6 = 10
? normlp(T, 1)
%7 = 2.4142135623730950488016887242096980786
@eprog

The library syntax is \fun{GEN}{gnormlp}{GEN x, GEN p = NULL, long prec}.

\subsec{qfauto$(G,\{\var{fl}\})$}\kbdsidx{qfauto}\label{se:qfauto}
$G$ being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, outputs the automorphism group of the
associate lattice.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows. $G$ can also be given by an
\kbd{qfisominit} structure.
See \kbd{qfisominit} for the meaning of \var{fl}.

The output is a two-components vector $[o,g]$ where $o$ is the group order
and $g$ is the list of generators (as a vector). For each generator $H$,
the equality $G={^t}H\*G\*H$ holds.

The interface of this function is experimental and will likely change in the
future.

This function implements an algorithm of Plesken and Souvignier, following
Souvignier's implementation.

The library syntax is \fun{GEN}{qfauto0}{GEN G, GEN fl = NULL}.
Also available is \fun{GEN}{qfauto}{GEN G, GEN fl}
where $G$ is a vector of \kbd{zm}.

\subsec{qfautoexport$(\var{qfa},\{\fl\})$}\kbdsidx{qfautoexport}\label{se:qfautoexport}
\var{qfa} being an automorphism group as output by
\tet{qfauto}, export the underlying matrix group as a string suitable
for (no flags or $\fl=0$) GAP or ($\fl=1$) Magma. The following example
computes the size of the matrix group using GAP:
\bprog
? G = qfauto([2,1;1,2])
%1 = [12, [[-1, 0; 0, -1], [0, -1; 1, 1], [1, 1; 0, -1]]]
? s = qfautoexport(G)
%2 = "Group([[-1, 0], [0, -1]], [[0, -1], [1, 1]], [[1, 1], [0, -1]])"
? extern("echo \"Order("s");\" | gap -q")
%3 = 12
@eprog

The library syntax is \fun{GEN}{qfautoexport}{GEN qfa, long flag}.

\subsec{qfbil$(x,y,\{q\})$}\kbdsidx{qfbil}\label{se:qfbil}
Evaluate the bilinear form $q$ (symmetric matrix)
at the vectors $(x,y)$; if $q$ omitted, use the standard Euclidean scalar
product, corresponding to the identity matrix.

Roughly equivalent to \kbd{x\til * q * y}, but a little faster and
more convenient (does not distinguish between column and row vectors):
\bprog
? x = [1,2,3]~; y = [-1,0,1]~; qfbil(x,y)
%1 = 2
? q = [1,2,3;2,2,-1;3,-1,0]; qfbil(x,y, q)
%2 = -13
? for(i=1,10^6, qfbil(x,y,q))
%3 = 568ms
? for(i=1,10^6, x~*q*y)
%4 = 717ms
@eprog\noindent The associated quadratic form is also available, as
\tet{qfnorm}, slightly faster:
\bprog
? for(i=1,10^6, qfnorm(x,q))
time = 444ms
? for(i=1,10^6, qfnorm(x))
time = 176 ms.
? for(i=1,10^6, qfbil(x,y))
time = 208 ms.
@eprog

The library syntax is \fun{GEN}{qfbil}{GEN x, GEN y, GEN q = NULL}.

\subsec{qfgaussred$(q)$}\kbdsidx{qfgaussred}\label{se:qfgaussred}
\idx{decomposition into squares} of the
quadratic form represented by the symmetric matrix $q$. The result is a
matrix whose diagonal entries are the coefficients of the squares, and the
off-diagonal entries on each line represent the bilinear forms. More
precisely, if $(a_{ij})$ denotes the output, one has
$$ q(x) = \sum_i a_{ii} (x_i + \sum_{j \neq i} a_{ij} x_j)^2 $$
\bprog
? qfgaussred([0,1;1,0])
%1 =
[1/2 1]

[-1 -1/2]
@eprog\noindent This means that $2xy = (1/2)(x+y)^2 - (1/2)(x-y)^2$.

The library syntax is \fun{GEN}{qfgaussred}{GEN q}.
\fun{GEN}{qfgaussred_positive}{GEN q} assumes that $q$ is
 positive definite and is a little faster; returns \kbd{NULL} if a vector
 with negative norm occurs (non positive matrix or too many rounding errors).

\subsec{qfisom$(G,H,\{\var{fl}\})$}\kbdsidx{qfisom}\label{se:qfisom}
$G$, $H$ being square and symmetric matrices with integer entries representing
positive definite quadratic forms, return an invertible matrix $S$ such that
$G={^t}S\*H\*S$. This defines a isomorphism between the corresponding lattices.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows.
See \kbd{qfisominit} for the meaning of \var{fl}.

$G$ can also be given by an \kbd{qfisominit} structure which is preferable if
several forms $H$ need to be compared to $G$.

This function implements an algorithm of Plesken and Souvignier, following
Souvignier's implementation.

The library syntax is \fun{GEN}{qfisom0}{GEN G, GEN H, GEN fl = NULL}.
Also available is \fun{GEN}{qfisom}{GEN G, GEN H, GEN fl}
where $G$ is a vector of \kbd{zm}, and $H$ is a \kbd{zm}.

\subsec{qfisominit$(G,\{\var{fl}\})$}\kbdsidx{qfisominit}\label{se:qfisominit}
$G$ being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, return an \kbd{isom} structure allowing to
compute isomorphisms between $G$ and other quadratic forms faster.

The interface of this function is experimental and will likely change in future
release.

If present, the optional parameter \var{fl} must be a \typ{VEC} with two
components. It allows to specify the invariants used, which can make the
computation faster or slower. The components are

\item \kbd{fl[1]} Depth of scalar product combination to use.

\item \kbd{fl[2]} Maximum level of Bacher polynomials to use.

Since this function computes the minimal vectors, it can become very lengthy
as the dimension of $G$ grows.

The library syntax is \fun{GEN}{qfisominit0}{GEN G, GEN fl = NULL}.
Also available is
\fun{GEN}{qfisominit}{GEN F, GEN fl}
where $F$ is a vector of \kbd{zm}.

\subsec{qfjacobi$(A)$}\kbdsidx{qfjacobi}\label{se:qfjacobi}
Apply Jacobi's eigenvalue algorithm to the real symmetric matrix $A$.
This returns $[L, V]$, where

\item $L$ is the vector of (real) eigenvalues of $A$, sorted in increasing
order,

\item $V$ is the corresponding orthogonal matrix of eigenvectors of $A$.

\bprog
? \p19
? A = [1,2;2,1]; mateigen(A)
%1 =
[-1 1]

[ 1 1]
? [L, H] = qfjacobi(A);
? L
%3 = [-1.000000000000000000, 3.000000000000000000]~
? H
%4 =
[ 0.7071067811865475245 0.7071067811865475244]

[-0.7071067811865475244 0.7071067811865475245]
? norml2( (A-L[1])*H[,1] )       \\ approximate eigenvector
%5 = 9.403954806578300064 E-38
? norml2(H*H~ - 1)
%6 = 2.350988701644575016 E-38   \\ close to orthogonal
@eprog

The library syntax is \fun{GEN}{jacobi}{GEN A, long prec}.

\subsec{qflll$(x,\{\fl=0\})$}\kbdsidx{qflll}\label{se:qflll}
\idx{LLL} algorithm applied to the
\emph{columns} of the matrix $x$. The columns of $x$ may be linearly
dependent. The result is a unimodular transformation matrix $T$ such that $x
\cdot T$ is an LLL-reduced basis of the lattice generated by the column
vectors of $x$. Note that if $x$ is not of maximal rank $T$ will not be
square. The LLL parameters are $(0.51,0.99)$, meaning that the Gram-Schmidt
coefficients for the final basis satisfy $\mu_{i,j} \leq |0.51|$, and the
Lov\'{a}sz's constant is $0.99$.

If $\fl=0$ (default), assume that $x$ has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in $\fl = 1$.

If $\fl=1$, assume that $x$ is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer's trick,
as generalized by Schnorr). Adapted from Nguyen and Stehl\'e's algorithm
and Stehl\'e's code (\kbd{fplll-1.3}).

If $\fl=2$, $x$ should be an integer matrix whose columns are linearly
independent. Returns a partially reduced basis for $x$, using an unpublished
algorithm by Peter Montgomery: a basis is said to be \emph{partially reduced}
if $|v_i \pm v_j| \geq |v_i|$ for any two distinct basis vectors $v_i, \,
v_j$.

This is faster than $\fl=1$, esp. when one row is huge compared
to the other rows (knapsack-style), and should quickly produce relatively
short vectors. The resulting basis is \emph{not} LLL-reduced in general.
If LLL reduction is eventually desired, avoid this partial reduction:
applying LLL to the partially reduced matrix is significantly \emph{slower}
than starting from a knapsack-type lattice.

If $\fl=4$, as $\fl=1$, returning a vector $[K, T]$ of matrices: the
columns of $K$ represent a basis of the integer kernel of $x$
(not LLL-reduced in general) and $T$ is the transformation
matrix such that $x\cdot T$ is an LLL-reduced $\Z$-basis of the image
of the matrix $x$.

If $\fl=5$, case as case $4$, but $x$ may have polynomial coefficients.

If $\fl=8$, same as case $0$, but $x$ may have polynomial coefficients.

The library syntax is \fun{GEN}{qflll0}{GEN x, long flag}.
Also available are \fun{GEN}{lll}{GEN x} ($\fl=0$),
\fun{GEN}{lllint}{GEN x} ($\fl=1$), and \fun{GEN}{lllkerim}{GEN x} ($\fl=4$).

\subsec{qflllgram$(G,\{\fl=0\})$}\kbdsidx{qflllgram}\label{se:qflllgram}
Same as \kbd{qflll}, except that the
matrix $G = \kbd{x\til * x}$ is the Gram matrix of some lattice vectors $x$,
and not the coordinates of the vectors themselves. In particular, $G$ must
now be a square symmetric real matrix, corresponding to a positive
quadratic form (not necessarily definite: $x$ needs not have maximal rank).
The result is a unimodular
transformation matrix $T$ such that $x \cdot T$ is an LLL-reduced basis of
the lattice generated by the column vectors of $x$. See \tet{qflll} for
further details about the LLL implementation.

If $\fl=0$ (default), assume that $G$ has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in $\fl = 1$.

If $\fl=1$, assume that $G$ is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer's trick,
as generalized by Schnorr). Adapted from Nguyen and Stehl\'e's algorithm
and Stehl\'e's code (\kbd{fplll-1.3}).

$\fl=4$: $G$ has integer entries, gives the kernel and reduced image of $x$.

$\fl=5$: same as $4$, but $G$ may have polynomial coefficients.

The library syntax is \fun{GEN}{qflllgram0}{GEN G, long flag}.
Also available are \fun{GEN}{lllgram}{GEN G} ($\fl=0$),
\fun{GEN}{lllgramint}{GEN G} ($\fl=1$), and \fun{GEN}{lllgramkerim}{GEN G}
($\fl=4$).

\subsec{qfminim$(x,\{b\},\{m\},\{\fl=0\})$}\kbdsidx{qfminim}\label{se:qfminim}
$x$ being a square and symmetric matrix representing a positive definite
quadratic form, this function deals with the vectors of $x$ whose norm is
less than or equal to $b$, enumerated using the Fincke-Pohst algorithm,
storing at most $m$ vectors (no limit if $m$ is omitted). The function
searches for the minimal non-zero vectors if $b$ is omitted. The behavior is
undefined if $x$ is not positive definite (a ``precision too low'' error is
most likely, although more precise error messages are possible). The precise
behavior depends on $\fl$.

If $\fl=0$ (default), seeks at most $2m$ vectors. The result is a
three-component vector, the first component being the number of vectors
found, the second being the maximum norm found, and the last vector is a
matrix whose columns are the vectors found, only one being given for each
pair $\pm v$ (at most $m$ such pairs, unless $m$ was omitted). The vectors
are returned in no particular order.

If $\fl=1$, ignores $m$ and returns $[N,v]$, where $v$ is a non-zero vector
of length $N \leq b$, or $[]$ if no non-zero vector has length $\leq b$.
If no explicit $b$ is provided, return a vector of smallish norm
(smallest vector in an LLL-reduced basis).

In these two cases, $x$ must have \emph{integral} entries. The
implementation uses low precision floating point computations for maximal
speed, which gives incorrect result when $x$ has large entries. (The
condition is checked in the code and the routine raises an error if
large rounding errors occur.) A more robust, but much slower,
implementation is chosen if the following flag is used:

If $\fl=2$, $x$ can have non integral real entries. In this case, if $b$
is omitted, the ``minimal'' vectors only have approximately the same norm.
If $b$ is omitted, $m$ is an upper bound for the number of vectors that
will be stored and returned, but all minimal vectors are nevertheless
enumerated. If $m$ is omitted, all vectors found are stored and returned;
note that this may be a huge vector!

\bprog
? x = matid(2);
? qfminim(x)  \\@com 4 minimal vectors of norm 1: $\pm[0,1]$, $\pm[1,0]$
%2 = [4, 1, [0, 1; 1, 0]]
? { x =
[4, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 0, 0,-2;
 2, 4,-2,-2, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1, 0, 1,-1,-1;
 0,-2, 4, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 0, 1,-1,-1, 0, 0;
 0,-2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1,-1, 0, 1,-1, 1, 0;
 0, 0,-2, 0, 4, 0, 0, 0, 1,-1, 0, 0, 1, 0, 0, 0,-2, 0, 0,-1, 1, 1, 0, 0;
-2, -2,0, 0, 0, 4,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,-1, 1, 1;
 0, 0, 0, 0, 0,-2, 4,-2, 0, 0, 0, 0, 0, 1, 0, 0, 0,-1, 0, 0, 0, 1,-1, 0;
 0, 0, 0, 0, 0, 0,-2, 4, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 1, 0;
 0, 0, 0, 0, 1,-1, 0, 0, 4, 0,-2, 0, 1, 1, 0,-1, 0, 1, 0, 0, 0, 0, 0, 0;
 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 0, 0, 1, 1,-1, 1, 0, 0, 0, 1, 0, 0, 1, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 4,-2, 0,-1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 4,-1, 1, 0, 0,-1, 1, 0, 1, 1, 1,-1, 0;
 1, 0,-1, 1, 1, 0, 0,-1, 1, 1, 0,-1, 4, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,-1;
-1,-1, 1,-1, 0, 0, 1, 0, 1, 1,-1, 1, 0, 4, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1;
 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 1, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 1, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0;
 0, 0, 1, 0,-2, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 1, 1, 1, 0, 0, 1, 1;
 1, 0, 0, 1, 0, 0,-1, 0, 1, 0,-1, 1, 1, 0, 0, 0, 1, 4, 0, 1, 1, 0, 1, 0;
 0, 0, 0,-1, 0, 1, 0,-1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 4, 0, 1, 1, 0, 1;
-1, -1,1, 0,-1, 1, 0,-1, 0, 1,-1, 1, 0, 1, 0, 0, 1, 1, 0, 4, 0, 0, 1, 1;
 0, 0,-1, 1, 1, 0, 0,-1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 4, 1, 0, 1;
 0, 1,-1,-1, 1,-1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 4, 0, 1;
 0,-1, 0, 1, 0, 1,-1, 1, 0, 1, 0,-1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 4, 1;
-2,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 4]; }
? qfminim(x,,0)  \\ the Leech lattice has 196560 minimal vectors of norm 4
time = 648 ms.
%4 = [196560, 4, [;]]
? qfminim(x,,0,2); \\ safe algorithm. Slower and unnecessary here.
time = 18,161 ms.
%5 = [196560, 4.000061035156250000, [;]]
@eprog\noindent\sidx{Leech lattice}\sidx{minimal vector}
In the last example, we store 0 vectors to limit memory use. All minimal
vectors are nevertheless enumerated. Provided \kbd{parisize} is about 50MB,
\kbd{qfminim(x)} succeeds in 2.5 seconds.

The library syntax is \fun{GEN}{qfminim0}{GEN x, GEN b = NULL, GEN m = NULL, long flag, long prec}.
Also available are
\fun{GEN}{minim}{GEN x, GEN b = NULL, GEN m = NULL} ($\fl=0$),
\fun{GEN}{minim2}{GEN x, GEN b = NULL, GEN m = NULL} ($\fl=1$).
\fun{GEN}{minim_raw}{GEN x, GEN b = NULL, GEN m = NULL} (do not perform LLL
reduction on x).

\subsec{qfnorm$(x,\{q\})$}\kbdsidx{qfnorm}\label{se:qfnorm}
Evaluate the binary quadratic form $q$ (symmetric matrix)
at the vector $x$. If $q$ omitted, use the standard Euclidean form,
corresponding to the identity matrix.

Equivalent to \kbd{x\til * q * x}, but about twice faster and
more convenient (does not distinguish between column and row vectors):
\bprog
? x = [1,2,3]~; qfnorm(x)
%1 = 14
? q = [1,2,3;2,2,-1;3,-1,0]; qfnorm(x, q)
%2 = 23
? for(i=1,10^6, qfnorm(x,q))
time = 384ms.
? for(i=1,10^6, x~*q*x)
time = 729ms.
@eprog\noindent We also allow \typ{MAT}s of compatible dimensions for $x$,
and return \kbd{x\til * q * x} in this case as well:
\bprog
? M = [1,2,3;4,5,6;7,8,9]; qfnorm(M) \\ Gram matrix
%5 =
[66  78  90]

[78  93 108]

[90 108 126]

? for(i=1,10^6, qfnorm(M,q))
time = 2,144 ms.
? for(i=1,10^6, M~*q*M)
time = 2,793 ms.
@eprog
\noindent The polar form is also available, as \tet{qfbil}.

The library syntax is \fun{GEN}{qfnorm}{GEN x, GEN q = NULL}.

\subsec{qfperfection$(G)$}\kbdsidx{qfperfection}\label{se:qfperfection}
$G$ being a square and symmetric matrix with
integer entries representing a positive definite quadratic form, outputs the
perfection rank of the form. That is, gives the rank of the family of the $s$
symmetric matrices $v_iv_i^t$, where $s$ is half the number of minimal
vectors and the $v_i$ ($1\le i\le s$) are the minimal vectors.

Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension of $x$ grows.

The library syntax is \fun{GEN}{perf}{GEN G}.

\subsec{qfrep$(q,B,\{\fl=0\})$}\kbdsidx{qfrep}\label{se:qfrep}
$q$ being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, count the vectors representing successive
integers.

\item If $\fl = 0$, count all vectors. Outputs the vector whose $i$-th
entry, $1 \leq i \leq B$ is half the number of vectors $v$ such that $q(v)=i$.

\item If $\fl = 1$, count vectors of even norm. Outputs the vector
whose $i$-th entry, $1 \leq i \leq B$ is half the number of vectors such
that $q(v) = 2i$.

\bprog
? q = [2, 1; 1, 3];
? qfrep(q, 5)
%2 = Vecsmall([0, 1, 2, 0, 0]) \\ 1 vector of norm 2, 2 of norm 3, etc.
? qfrep(q, 5, 1)
%3 = Vecsmall([1, 0, 0, 1, 0]) \\ 1 vector of norm 2, 0 of norm 4, etc.
@eprog\noindent
This routine uses a naive algorithm based on \tet{qfminim}, and
will fail if any entry becomes larger than $2^{31}$ (or $2^{63}$).

The library syntax is \fun{GEN}{qfrep0}{GEN q, GEN B, long flag}.

\subsec{qfsign$(x)$}\kbdsidx{qfsign}\label{se:qfsign}
Returns $[p,m]$ the signature of the quadratic form represented by the
symmetric matrix $x$. Namely, $p$ (resp.~$m$) is the number of positive
(resp.~negative) eigenvalues of $x$.The result is computed using Gaussian
reduction.

The library syntax is \fun{GEN}{qfsign}{GEN x}.

\subsec{seralgdep$(s,p,r)$}\kbdsidx{seralgdep}\label{se:seralgdep}
\sidx{algebraic dependence} finds a linear relation between powers $(1,s,
\dots, s^p)$ of the series $s$, with polynomial coefficients of degree
$\leq r$. In case no relation is found, return $0$.
\bprog
? s = 1 + 10*y - 46*y^2 + 460*y^3 - 5658*y^4 + 77740*y^5 + O(y^6);
? seralgdep(s, 2, 2)
%2 = -x^2 + (8*y^2 + 20*y + 1)
? subst(%, x, s)
%3 = O(y^6)
? seralgdep(s, 1, 3)
%4 = (-77*y^2 - 20*y - 1)*x + (310*y^3 + 231*y^2 + 30*y + 1)
? seralgdep(s, 1, 2)
%5 = 0
@eprog\noindent The series main variable must not be $x$, so as to be able
to express the result as a polynomial in $x$.

The library syntax is \fun{GEN}{seralgdep}{GEN s, long p, long r}.

\subsec{setbinop$(f,X,\{Y\})$}\kbdsidx{setbinop}\label{se:setbinop}
The set whose elements are the f(x,y), where x,y run through X,Y.
respectively. If $Y$ is omitted, assume that $X = Y$ and that $f$ is symmetric:
$f(x,y) = f(y,x)$ for all $x,y$ in $X$.
\bprog
? X = [1,2,3]; Y = [2,3,4];
? setbinop((x,y)->x+y, X,Y) \\ set X + Y
%2 = [3, 4, 5, 6, 7]
? setbinop((x,y)->x-y, X,Y) \\ set X - Y
%3 = [-3, -2, -1, 0, 1]
? setbinop((x,y)->x+y, X)   \\ set 2X = X + X
%2 = [2, 3, 4, 5, 6]
@eprog

The library syntax is \fun{GEN}{setbinop}{GEN f, GEN X, GEN Y = NULL}.

\subsec{setintersect$(x,y)$}\kbdsidx{setintersect}\label{se:setintersect}
Intersection of the two sets $x$ and $y$ (see \kbd{setisset}).
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setintersect}{GEN x, GEN y}.

\subsec{setisset$(x)$}\kbdsidx{setisset}\label{se:setisset}
Returns true (1) if $x$ is a set, false (0) if
not. In PARI, a set is a row vector whose entries are strictly
increasing with respect to a (somewhat arbitrary) universal comparison
function. To convert any object into a set (this is most useful for
vectors, of course), use the function \kbd{Set}.
\bprog
? a = [3, 1, 1, 2];
? setisset(a)
%2 = 0
? Set(a)
%3 = [1, 2, 3]
@eprog

The library syntax is \fun{long}{setisset}{GEN x}.

\subsec{setminus$(x,y)$}\kbdsidx{setminus}\label{se:setminus}
Difference of the two sets $x$ and $y$ (see \kbd{setisset}),
i.e.~set of elements of $x$ which do not belong to $y$.
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setminus}{GEN x, GEN y}.

\subsec{setsearch$(S,x,\{\fl=0\})$}\kbdsidx{setsearch}\label{se:setsearch}
Determines whether $x$ belongs to the set $S$ (see \kbd{setisset}).

We first describe the default behaviour, when $\fl$ is zero or omitted. If $x$
belongs to the set $S$, returns the index $j$ such that $S[j]=x$, otherwise
returns 0.
\bprog
? T = [7,2,3,5]; S = Set(T);
? setsearch(S, 2)
%2 = 1
? setsearch(S, 4)      \\ not found
%3 = 0
? setsearch(T, 7)      \\ search in a randomly sorted vector
%4 = 0 \\ WRONG !
@eprog\noindent
If $S$ is not a set, we also allow sorted lists with
respect to the \tet{cmp} sorting function, without repeated entries,
as per \tet{listsort}$(L,1)$; otherwise the result is undefined.
\bprog
? L = List([1,4,2,3,2]); setsearch(L, 4)
%1 = 0 \\ WRONG !
? listsort(L, 1); L    \\ sort L first
%2 = List([1, 2, 3, 4])
? setsearch(L, 4)
%3 = 4                 \\ now correct
@eprog\noindent
If $\fl$ is non-zero, this function returns the index $j$ where $x$ should be
inserted, and $0$ if it already belongs to $S$. This is meant to be used for
dynamically growing (sorted) lists, in conjunction with \kbd{listinsert}.
\bprog
? L = List([1,5,2,3,2]); listsort(L,1); L
%1 = List([1,2,3,5])
? j = setsearch(L, 4, 1)  \\ 4 should have been inserted at index j
%2 = 4
? listinsert(L, 4, j); L
%3 = List([1, 2, 3, 4, 5])
@eprog

The library syntax is \fun{long}{setsearch}{GEN S, GEN x, long flag}.

\subsec{setunion$(x,y)$}\kbdsidx{setunion}\label{se:setunion}
Union of the two sets $x$ and $y$ (see \kbd{setisset}).
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setunion}{GEN x, GEN y}.

\subsec{trace$(x)$}\kbdsidx{trace}\label{se:trace}
This applies to quite general $x$. If $x$ is not a
matrix, it is equal to the sum of $x$ and its conjugate, except for polmods
where it is the trace as an algebraic number.

For $x$ a square matrix, it is the ordinary trace. If $x$ is a
non-square matrix (but not a vector), an error occurs.

The library syntax is \fun{GEN}{gtrace}{GEN x}.

\subsec{vecextract$(x,y,\{z\})$}\kbdsidx{vecextract}\label{se:vecextract}
Extraction of components of the vector or matrix $x$ according to $y$.
In case $x$ is a matrix, its components are the \emph{columns} of $x$. The
parameter $y$ is a component specifier, which is either an integer, a string
describing a range, or a vector.

If $y$ is an integer, it is considered as a mask: the binary bits of $y$ are
read from right to left, but correspond to taking the components from left to
right. For example, if $y=13=(1101)_2$ then the components 1,3 and 4 are
extracted.

If $y$ is a vector (\typ{VEC}, \typ{COL} or \typ{VECSMALL}), which must have
integer entries, these entries correspond to the component numbers to be
extracted, in the order specified.

If $y$ is a string, it can be

\item a single (non-zero) index giving a component number (a negative
index means we start counting from the end).

\item a range of the form \kbd{"$a$..$b$"}, where $a$ and $b$ are
indexes as above. Any of $a$ and $b$ can be omitted; in this case, we take
as default values $a = 1$ and $b = -1$, i.e.~ the first and last components
respectively. We then extract all components in the interval $[a,b]$, in
reverse order if $b < a$.

In addition, if the first character in the string is \kbd{\pow}, the
complement of the given set of indices is taken.

If $z$ is not omitted, $x$ must be a matrix. $y$ is then the \emph{row}
specifier, and $z$ the \emph{column} specifier, where the component specifier
is as explained above.

\bprog
? v = [a, b, c, d, e];
? vecextract(v, 5)         \\@com mask
%1 = [a, c]
? vecextract(v, [4, 2, 1]) \\@com component list
%2 = [d, b, a]
? vecextract(v, "2..4")    \\@com interval
%3 = [b, c, d]
? vecextract(v, "-1..-3")  \\@com interval + reverse order
%4 = [e, d, c]
? vecextract(v, "^2")      \\@com complement
%5 = [a, c, d, e]
? vecextract(matid(3), "2..", "..")
%6 =
[0 1 0]

[0 0 1]
@eprog
The range notations \kbd{v[i..j]} and \kbd{v[\pow i]} (for \typ{VEC} or
\typ{COL}) and \kbd{M[i..j, k..l]} and friends (for \typ{MAT}) implement a
subset of the above, in a simpler and \emph{faster} way, hence should be
preferred in most common situations. The following features are not
implemented in the range notation:

\item reverse order,

\item omitting either $a$ or $b$ in \kbd{$a$..$b$}.

The library syntax is \fun{GEN}{extract0}{GEN x, GEN y, GEN z = NULL}.

\subsec{vecsearch$(v,x,\{\var{cmpf}\})$}\kbdsidx{vecsearch}\label{se:vecsearch}
Determines whether $x$ belongs to the sorted vector or list $v$: return
the (positive) index where $x$ was found, or $0$ if it does not belong to
$v$.

If the comparison function cmpf is omitted, we assume that $v$ is sorted in
increasing order, according to the standard comparison function $<$, thereby
restricting the possible types for $x$ and the elements of $v$ (integers,
fractions or reals).

If \kbd{cmpf} is present, it is understood as a comparison function and we
assume that $v$ is sorted according to it, see \tet{vecsort} for how to
encode comparison functions.
\bprog
? v = [1,3,4,5,7];
? vecsearch(v, 3)
%2 = 2
? vecsearch(v, 6)
%3 = 0 \\ not in the list
? vecsearch([7,6,5], 5) \\ unsorted vector: result undefined
%4 = 0
@eprog

By abuse of notation, $x$ is also allowed to be a matrix, seen as a vector
of its columns; again by abuse of notation, a \typ{VEC} is considered
as part of the matrix, if its transpose is one of the matrix columns.
\bprog
? v = vecsort([3,0,2; 1,0,2]) \\ sort matrix columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsearch(v, [3,1]~)
%2 = 3
? vecsearch(v, [3,1])  \\ can search for x or x~
%3 = 3
? vecsearch(v, [1,2])
%4 = 0 \\ not in the list
@eprog\noindent

The library syntax is \fun{long}{vecsearch}{GEN v, GEN x, GEN cmpf = NULL}.

\subsec{vecsort$(x,\{\var{cmpf}\},\{\fl=0\})$}\kbdsidx{vecsort}\label{se:vecsort}
Sorts the vector $x$ in ascending order, using a mergesort method.
$x$ must be a list, vector or matrix (seen as a vector of its columns).
Note that mergesort is stable, hence the initial ordering of ``equal''
entries (with respect to the sorting criterion) is not changed.

If \kbd{cmpf} is omitted, we use the standard comparison function
\kbd{lex}, thereby restricting the possible types for the elements of $x$
(integers, fractions or reals and vectors of those). If \kbd{cmpf} is
present, it is understood as a comparison function and we sort according to
it. The following possibilities exist:

\item an integer $k$: sort according to the value of the $k$-th
subcomponents of the components of~$x$.

\item a vector: sort lexicographically according to the components listed in
the vector. For example, if $\kbd{cmpf}=\kbd{[2,1,3]}$, sort with respect to
the second component, and when these are equal, with respect to the first,
and when these are equal, with respect to the third.

\item a comparison function (\typ{CLOSURE}), with two arguments $x$ and $y$,
and returning an integer which is $<0$, $>0$ or $=0$ if $x<y$, $x>y$ or
$x=y$ respectively. The \tet{sign} function is very useful in this context:
\bprog
? vecsort([3,0,2; 1,0,2]) \\ sort columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsort(v, (x,y)->sign(y-x))            \\@com reverse sort
? vecsort(v, (x,y)->sign(abs(x)-abs(y)))  \\@com sort by increasing absolute value
? cmpf(x,y) = my(dx = poldisc(x), dy = poldisc(y)); sign(abs(dx) - abs(dy))
? vecsort([x^2+1, x^3-2, x^4+5*x+1], cmpf)
@eprog\noindent
The last example used the named \kbd{cmpf} instead of an anonymous function,
and sorts polynomials with respect to the absolute value of their
discriminant. A more efficient approach would use precomputations to ensure
a given discriminant is computed only once:
\bprog
? DISC = vector(#v, i, abs(poldisc(v[i])));
? perm = vecsort(vector(#v,i,i), (x,y)->sign(DISC[x]-DISC[y]))
? vecextract(v, perm)
@eprog\noindent Similar ideas apply whenever we sort according to the values
of a function which is expensive to compute.

\noindent The binary digits of \fl\ mean:

\item 1: indirect sorting of the vector $x$, i.e.~if $x$ is an
$n$-component vector, returns a permutation of $[1,2,\dots,n]$ which
applied to the components of $x$ sorts $x$ in increasing order.
For example, \kbd{vecextract(x, vecsort(x,,1))} is equivalent to
\kbd{vecsort(x)}.

\item 4: use descending instead of ascending order.

\item 8: remove ``duplicate'' entries with respect to the sorting function
(keep the first occurring entry).  For example:
\bprog
  ? vecsort([Pi,Mod(1,2),z], (x,y)->0, 8)   \\@com make everything compare equal
  %1 = [3.141592653589793238462643383]
  ? vecsort([[2,3],[0,1],[0,3]], 2, 8)
  %2 = [[0, 1], [2, 3]]
@eprog

The library syntax is \fun{GEN}{vecsort0}{GEN x, GEN cmpf = NULL, long flag}.

\subsec{vecsum$(v)$}\kbdsidx{vecsum}\label{se:vecsum}
Return the sum of the component of the vector $v$

The library syntax is \fun{GEN}{vecsum}{GEN v}.

\subsec{vector$(n,\{X\},\{\var{expr}=0\})$}\kbdsidx{vector}\label{se:vector}
Creates a row vector (type
\typ{VEC}) with $n$ components whose components are the expression
\var{expr} evaluated at the integer points between 1 and $n$. If one of the
last two arguments is omitted, fill the vector with zeroes.

Avoid modifying $X$ within \var{expr}; if you do, the formal variable
still runs from $1$ to $n$. In particular, \kbd{vector(n,i,expr)} is not
equivalent to
\bprog
v = vector(n)
for (i = 1, n, v[i] = expr)
@eprog\noindent
as the following example shows:
\bprog
n = 3
v = vector(n); vector(n, i, i++)            ----> [2, 3, 4]
v = vector(n); for (i = 1, n, v[i] = i++)   ----> [2, 0, 4]
@eprog\noindent
%\syn{NO}

\subsec{vectorsmall$(n,\{X\},\{\var{expr}=0\})$}\kbdsidx{vectorsmall}\label{se:vectorsmall}
Creates a row vector of small integers (type
\typ{VECSMALL}) with $n$ components whose components are the expression
\var{expr} evaluated at the integer points between 1 and $n$. If one of the
last two arguments is omitted, fill the vector with zeroes.
%\syn{NO}

\subsec{vectorv$(n,\{X\},\{\var{expr}=0\})$}\kbdsidx{vectorv}\label{se:vectorv}
As \tet{vector}, but returns a column vector (type \typ{COL}).
%\syn{NO}
%SECTION: linear_algebra

\section{Sums, products, integrals and similar functions}
\label{se:sums}

Although the \kbd{gp} calculator is programmable, it is useful to have
a number of preprogrammed loops, including sums, products, and a certain
number of recursions. Also, a number of functions from numerical analysis
like numerical integration and summation of series will be described here.

One of the parameters in these loops must be the control variable, hence a
simple variable name. In the descriptions, the letter $X$ will always denote
any simple variable name, and represents the formal parameter used in the
function. The expression to be summed, integrated, etc. is any legal PARI
expression, including of course expressions using loops.

\misctitle{Library mode}
Since it is easier to program directly the loops in library mode, these
functions are mainly useful for GP programming. On the other hand, numerical
routines code a function (to be integrated, summed, etc.) with two parameters
named
\bprog
  GEN (*eval)(void*,GEN)
  void *E;  \\ context: eval(E, x) must evaluate your function at x.
@eprog\noindent
see the Libpari manual for details.

\misctitle{Numerical integration}\sidx{numerical integration}
Starting with version 2.2.9 the ``double exponential'' univariate
integration method is implemented in \tet{intnum} and its variants. Romberg
integration is still available under the name \kbd{intnumromb}, but
superseded. It is possible to compute numerically integrals to thousands of
decimal places in reasonable time, as long as the integrand is regular. It is
also reasonable to compute numerically integrals in several variables,
although more than two becomes lengthy. The integration domain may be
non-compact, and the integrand may have reasonable singularities at
endpoints. To use \kbd{intnum}, you must split the integral into a sum
of subintegrals where the function has no singularities except at the
endpoints. Polynomials in logarithms are not considered singular, and
neglecting these logs, singularities are assumed to be algebraic (asymptotic
to $C(x-a)^{-\alpha}$ for some $\alpha > -1$ when $x$ is
close to $a$), or to correspond to simple discontinuities of some (higher)
derivative of the function. For instance, the point $0$ is a singularity of
$\text{abs}(x)$.

See also the discrete summation methods below, sharing the prefix \kbd{sum}.


\subsec{derivnum$(X=a,\var{expr})$}\kbdsidx{derivnum}\label{se:derivnum}
Numerical derivation of \var{expr} with respect to $X$ at $X=a$.

\bprog
? derivnum(x=0,sin(exp(x))) - cos(1)
%1 = -1.262177448 E-29
@eprog
A clumsier approach, which would not work in library mode, is
\bprog
? f(x) = sin(exp(x))
? f'(0) - cos(1)
%1 = -1.262177448 E-29
@eprog
When $a$ is a power series, compute \kbd{derivnum(t=a,f)} as $f'(a) =
(f(a))'/a'$.

\synt{derivnum}{void *E, GEN (*eval)(void*,GEN), GEN a, long prec}. Also
available is \fun{GEN}{derivfun}{void *E, GEN (*eval)(void *, GEN), GEN a, long prec}, which also allows power series for $a$.

\subsec{intcirc$(X=a,R,\var{expr},\{\var{tab}\})$}\kbdsidx{intcirc}\label{se:intcirc}
Numerical
integration of $(2i\pi)^{-1}\var{expr}$ with respect to $X$ on the circle
$|X-a| = R$.
In other words, when \var{expr} is a meromorphic
function, sum of the residues in the corresponding disk. \var{tab} is as in
\kbd{intnum}, except that if computed with \kbd{intnuminit} it should be with
the endpoints \kbd{[-1, 1]}.

\bprog
? \p105
? intcirc(s=1, 0.5, zeta(s)) - 1
%1 = -2.398082982 E-104 - 7.94487211 E-107*I
@eprog

\synt{intcirc}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN R,GEN tab, long prec}.

\subsec{intfouriercos$(X=a,b,z,\var{expr},\{\var{tab}\})$}\kbdsidx{intfouriercos}\label{se:intfouriercos}
Numerical
integration of $\var{expr}(X)\cos(2\pi zX)$ from $a$ to $b$, in other words
Fourier cosine transform (from $a$ to $b$) of the function represented by
\var{expr}. Endpoints $a$ and $b$ are coded as in \kbd{intnum}, and are not
necessarily at infinity, but if they are, oscillations (i.e. $[[\pm1],\alpha
I]$) are forbidden.

\synt{intfouriercos}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b, GEN z, GEN tab, long prec}.

\subsec{intfourierexp$(X=a,b,z,\var{expr},\{\var{tab}\})$}\kbdsidx{intfourierexp}\label{se:intfourierexp}
Numerical
integration of $\var{expr}(X)\exp(-2i\pi zX)$ from $a$ to $b$, in other words
Fourier transform (from $a$ to $b$) of the function represented by
\var{expr}. Note the minus sign. Endpoints $a$ and $b$ are coded as in
\kbd{intnum}, and are not necessarily at infinity but if they are,
oscillations (i.e. $[[\pm1],\alpha I]$) are forbidden.

\synt{intfourierexp}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b, GEN z, GEN tab, long prec}.

\subsec{intfouriersin$(X=a,b,z,\var{expr},\{\var{tab}\})$}\kbdsidx{intfouriersin}\label{se:intfouriersin}
Numerical
integration of $\var{expr}(X)\sin(2\pi zX)$ from $a$ to $b$, in other words
Fourier sine transform (from $a$ to $b$) of the function represented by
\var{expr}. Endpoints $a$ and $b$ are coded as in \kbd{intnum}, and are not
necessarily at infinity but if they are, oscillations (i.e. $[[\pm1],\alpha
I]$) are forbidden.

\synt{intfouriersin}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b, GEN z, GEN tab, long prec}.

\subsec{intfuncinit$(X=a,b,\var{expr},\{\fl=0\},\{m=0\})$}\kbdsidx{intfuncinit}\label{se:intfuncinit}
Initialize tables for use with integral transforms such as \kbd{intmellininv},
etc., where $a$ and $b$ are coded as in \kbd{intnum}, $\var{expr}$ is the
function $s(X)$ to which the integral transform is to be applied (which will
multiply the weights of integration) and $m$ is as in \kbd{intnuminit}. If
$\fl$ is nonzero, assumes that $s(-X)=\overline{s(X)}$, which makes the
computation twice as fast. See \kbd{intmellininvshort} for examples of the
use of this function, which is particularly useful when the function $s(X)$
is lengthy to compute, such as a gamma product.

\synt{intfuncinit}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b,long m, long flag, long prec}. Note that the order of $m$ and $\fl$ are reversed compared
to the \kbd{GP} syntax.

\subsec{intlaplaceinv$(X=\var{sig},z,\var{expr},\{\var{tab}\})$}\kbdsidx{intlaplaceinv}\label{se:intlaplaceinv}
Numerical integration of $(2i\pi)^{-1}\var{expr}(X)e^{Xz}$ with respect
to $X$ on the line $\Re(X)=sig$. In other words, inverse Laplace transform
of the function corresponding to \var{expr} at the value $z$.

$sig$ is coded as follows. Either it is a real number $\sigma$, equal to the
abscissa of integration, and then the integrand is assumed to
be slowly decreasing when the imaginary part of the variable tends to
$\pm\infty$. Or it is a two component vector $[\sigma,\alpha]$, where
$\sigma$ is as before, and either $\alpha=0$ for slowly decreasing functions,
or $\alpha>0$ for functions decreasing like $\exp(-\alpha t)$. Note that it
is not necessary to choose the exact value of $\alpha$. \var{tab} is as in
\kbd{intnum}.

It is often a good idea to use this function with a value of $m$ one or two
higher than the one chosen by default (which can be viewed thanks to the
function \kbd{intnumstep}), or to increase the abscissa of integration
$\sigma$. For example:

\bprog
? \p 105
? intlaplaceinv(x=2, 1, 1/x) - 1
time = 350 ms.
%1 = 7.37... E-55 + 1.72... E-54*I \\@com not so good
? m = intnumstep()
%2 = 7
? intlaplaceinv(x=2, 1, 1/x, m+1) - 1
time = 700 ms.
%3 = 3.95... E-97 + 4.76... E-98*I \\@com better
? intlaplaceinv(x=2, 1, 1/x, m+2) - 1
time = 1400 ms.
%4 = 0.E-105 + 0.E-106*I \\@com perfect but slow.
? intlaplaceinv(x=5, 1, 1/x) - 1
time = 340 ms.
%5 = -5.98... E-85 + 8.08... E-85*I \\@com better than \%1
? intlaplaceinv(x=5, 1, 1/x, m+1) - 1
time = 680 ms.
%6 = -1.09... E-106 + 0.E-104*I \\@com perfect, fast.
? intlaplaceinv(x=10, 1, 1/x) - 1
time = 340 ms.
%7 = -4.36... E-106 + 0.E-102*I \\@com perfect, fastest, but why $sig=10$?
? intlaplaceinv(x=100, 1, 1/x) - 1
time = 330 ms.
%7 = 1.07... E-72 + 3.2... E-72*I \\@com too far now...
@eprog

\synt{intlaplaceinv}{void *E, GEN (*eval)(void*,GEN), GEN sig,GEN z, GEN tab, long prec}.

\subsec{intmellininv$(X=\var{sig},z,\var{expr},\{\var{tab}\})$}\kbdsidx{intmellininv}\label{se:intmellininv}
Numerical
integration of $(2i\pi)^{-1}\var{expr}(X)z^{-X}$ with respect to $X$ on the
line $\Re(X)=sig$,  in other words, inverse Mellin transform of
the function corresponding to \var{expr} at the value $z$.

$sig$ is coded as follows. Either it is a real number $\sigma$, equal to the
abscissa of integration, and then the integrated is assumed to decrease
exponentially fast, of the order of $\exp(-t)$ when the imaginary part of the
variable tends to $\pm\infty$. Or it is a two component vector
$[\sigma,\alpha]$, where $\sigma$ is as before, and either $\alpha=0$ for
slowly decreasing functions, or $\alpha>0$ for functions decreasing like
$\exp(-\alpha t)$, such as gamma products. Note that it is not necessary to
choose the exact value of $\alpha$, and that $\alpha=1$ (equivalent to $sig$
alone) is usually sufficient. \var{tab} is as in \kbd{intnum}.

As all similar functions, this function is provided for the convenience of
the user, who could use \kbd{intnum} directly. However it is in general
better to use \kbd{intmellininvshort}.

\bprog
? \p 105
? intmellininv(s=2,4, gamma(s)^3);
time = 1,190 ms. \\@com reasonable.
? \p 308
? intmellininv(s=2,4, gamma(s)^3);
time = 51,300 ms. \\@com slow because of $\Gamma(s)^3$.
@eprog\noindent

\synt{intmellininv}{void *E, GEN (*eval)(void*,GEN), GEN sig, GEN z, GEN tab, long prec}.

\subsec{intmellininvshort$(\var{sig},z,\var{tab})$}\kbdsidx{intmellininvshort}\label{se:intmellininvshort}
Numerical integration
of $(2i\pi)^{-1}s(X)z^{-X}$ with respect to $X$ on the line $\Re(X)=sig$.
In other words, inverse Mellin transform of $s(X)$ at the value $z$.
Here $s(X)$ is implicitly contained in \var{tab} in \kbd{intfuncinit} format,
typically
\bprog
tab = intfuncinit(T = [-1], [1], s(sig + I*T))
@eprog\noindent
or similar commands. Take the example of the inverse Mellin transform of
$\Gamma(s)^3$ given in \kbd{intmellininv}:

\bprog
? \p 105
? oo = [1]; \\@com for clarity
? A = intmellininv(s=2,4, gamma(s)^3);
time = 2,500 ms. \\@com not too fast because of $\Gamma(s)^3$.
\\ @com function of real type, decreasing as $\exp(-3\pi/2\cdot |t|)$
? tab = intfuncinit(t=[-oo, 3*Pi/2],[oo, 3*Pi/2], gamma(2+I*t)^3, 1);
time = 1,370 ms.
? intmellininvshort(2,4, tab) - A
time = 50 ms.
%4 = -1.26... - 3.25...E-109*I \\@com 50 times faster than \kbd{A} and perfect.
? tab2 = intfuncinit(t=-oo, oo, gamma(2+I*t)^3, 1);
? intmellininvshort(2,4, tab2)
%6 = -1.2...E-42 - 3.2...E-109*I  \\@com 63 digits lost
@eprog\noindent
In the computation of \var{tab}, it was not essential to include the
\emph{exact} exponential decrease of $\Gamma(2+it)^3$. But as the last
example shows, a rough indication \emph{must} be given, otherwise slow
decrease is assumed, resulting in catastrophic loss of accuracy.

The library syntax is \fun{GEN}{intmellininvshort}{GEN sig, GEN z, GEN tab, long prec}.

\subsec{intnum$(X=a,b,\var{expr},\{\var{tab}\})$}\kbdsidx{intnum}\label{se:intnum}
Numerical integration
of \var{expr} on $]a,b[$ with respect to $X$. The integrand may have values
belonging to a vector space over the real numbers; in particular, it can be
complex-valued or vector-valued. But it is assumed that the function is regular
on $]a,b[$. If the endpoints $a$ and $b$ are finite and the function is regular
there, the situation is simple:
\bprog
? intnum(x = 0,1, x^2)
%1 = 0.3333333333333333333333333333
? intnum(x = 0,Pi/2, [cos(x), sin(x)])
%2 = [1.000000000000000000000000000, 1.000000000000000000000000000]
@eprog\noindent
An endpoint equal to $\pm\infty$ is coded as the single-component vector
$[\pm1]$. You are welcome to set, e.g \kbd{oo = [1]} or \kbd{INFINITY = [1]},
then using \kbd{+oo}, \kbd{-oo}, \kbd{-INFINITY}, etc. will have the expected
behavior.
\bprog
? oo = [1];  \\@com for clarity
? intnum(x = 1,+oo, 1/x^2)
%2 = 1.000000000000000000000000000
@eprog\noindent
In basic usage, it is assumed that the function does not decrease
exponentially fast at infinity:
\bprog
? intnum(x=0,+oo, exp(-x))
  ***   at top-level: intnum(x=0,+oo,exp(-
  ***                 ^--------------------
  *** exp: exponent (expo) overflow
@eprog\noindent
We shall see in a moment how to avoid the last problem, after describing
the last argument \var{tab}, which is both optional and technical. The
routine uses weights, which are mostly independent of the function being
integrated, evaluated at many sampling points. If \var{tab} is

\item a positive integer $m$, we use $2^m$ sampling points, hopefully
increasing accuracy. But note that the running time is roughly proportional
to $2^m$. One may try consecutive values of $m$ until they give the same
value up to an accepted error. If \var{tab} is omitted, the algorithm guesses
a reasonable value for $m$ depending on the current precision only, which
should be sufficient for regular functions. That value may be obtained from
\tet{intnumstep}, and increased in case of difficulties.

\item a set of integration tables as output by \tet{intnuminit},
they are used directly. This is useful if several integrations of the same
type are performed (on the same kind of interval and functions, for a given
accuracy), in particular for multivariate integrals, since we then skip
expensive precomputations.

\misctitle{Specifying the behavior at endpoints}
This is done as follows. An endpoint $a$ is either given as such (a scalar,
real or complex, or $[\pm1]$ for $\pm\infty$), or as a two component vector
$[a,\alpha]$, to indicate the behavior of the integrand in a neighborhood
of $a$.

If $a$ is finite, the code $[a,\alpha]$ means the function has a
singularity of the form $(x-a)^{\alpha}$, up to logarithms. (If $\alpha \ge
0$, we only assume the function is regular, which is the default assumption.)
If a wrong singularity exponent is used, the result will lose a catastrophic
number of decimals:
\bprog
? intnum(x=0, 1, x^(-1/2))         \\@com assume $x^{-1/2}$ is regular at 0
%1 = 1.999999999999999999990291881
? intnum(x=[0,-1/2], 1, x^(-1/2))  \\@com no, it's not
%2 = 2.000000000000000000000000000
? intnum(x=[0,-1/10], 1, x^(-1/2))
%3 = 1.999999999999999999999946438 \\@com using a wrong exponent is bad
@eprog

If $a$ is $\pm\infty$, which is coded as $[\pm 1]$, the situation is more
complicated, and $[[\pm1],\alpha]$ means:

\item $\alpha=0$ (or no $\alpha$ at all, i.e. simply $[\pm1]$) assumes that the
integrand tends to zero, but not exponentially fast, and not
oscillating such as $\sin(x)/x$.

\item $\alpha>0$ assumes that the function tends to zero exponentially fast
approximately as $\exp(-\alpha x)$. This includes oscillating but quickly
decreasing functions such as $\exp(-x)\sin(x)$.
\bprog
? oo = [1];
? intnum(x=0, +oo, exp(-2*x))
  ***   at top-level: intnum(x=0,+oo,exp(-
  ***                 ^--------------------
  *** exp: exponent (expo) overflow
? intnum(x=0, [+oo, 2], exp(-2*x))
%1 = 0.5000000000000000000000000000 \\@com OK!
? intnum(x=0, [+oo, 4], exp(-2*x))
%2 = 0.4999999999999999999961990984 \\@com wrong exponent $\Rightarrow$ imprecise result
? intnum(x=0, [+oo, 20], exp(-2*x))
%2 = 0.4999524997739071283804510227 \\@com disaster
@eprog

\item $\alpha<-1$ assumes that the function tends to $0$ slowly, like
$x^{\alpha}$. Here it is essential to give the correct $\alpha$, if possible,
but on the other hand $\alpha\le -2$ is equivalent to $\alpha=0$, in other
words to no $\alpha$ at all.

\smallskip The last two codes are reserved for oscillating functions.
Let $k > 0$ real, and $g(x)$ a non-oscillating function tending slowly to $0$
(e.g. like a negative power of $x$), then

\item $\alpha=k * I$ assumes that the function behaves like $\cos(kx)g(x)$.

\item $\alpha=-k* I$ assumes that the function behaves like $\sin(kx)g(x)$.

\noindent Here it is critical to give the exact value of $k$. If the
oscillating part is not a pure sine or cosine, one must expand it into a
Fourier series, use the above codings, and sum the resulting contributions.
Otherwise you will get nonsense. Note that $\cos(kx)$, and similarly
$\sin(kx)$, means that very function, and not a translated version such as
$\cos(kx+a)$.

\misctitle{Note} If $f(x)=\cos(kx)g(x)$ where $g(x)$ tends to zero
exponentially fast as $\exp(-\alpha x)$, it is up to the user to choose
between $[[\pm1],\alpha]$ and $[[\pm1],k* I]$, but a good rule of thumb is that
if the oscillations are much weaker than the exponential decrease, choose
$[[\pm1],\alpha]$, otherwise choose $[[\pm1],k* I]$, although the latter can
reasonably be used in all cases, while the former cannot. To take a specific
example, in the inverse Mellin transform, the integrand is almost always a
product of an exponentially decreasing and an oscillating factor. If we
choose the oscillating type of integral we perhaps obtain the best results,
at the expense of having to recompute our functions for a different value of
the variable $z$ giving the transform, preventing us to use a function such
as \kbd{intmellininvshort}. On the other hand using the exponential type of
integral, we obtain less accurate results, but we skip expensive
recomputations. See \kbd{intmellininvshort} and \kbd{intfuncinit} for more
explanations.

\smallskip

We shall now see many examples to get a feeling for what the various
parameters achieve. All examples below assume precision is set to $105$
decimal digits. We first type
\bprog
? \p 105
? oo = [1]  \\@com for clarity
@eprog

\misctitle{Apparent singularities} Even if the function $f(x)$ represented
by \var{expr} has no singularities, it may be important to define the
function differently near special points. For instance, if $f(x) = 1
/(\exp(x)-1) - \exp(-x)/x$, then $\int_0^\infty f(x)\,dx=\gamma$, Euler's
constant \kbd{Euler}. But

\bprog
? f(x) = 1/(exp(x)-1) - exp(-x)/x
? intnum(x = 0, [oo,1],  f(x)) - Euler
%1 = 6.00... E-67
@eprog\noindent
thus only correct to $67$ decimal digits. This is because close to $0$ the
function $f$ is computed with an enormous loss of accuracy.
A better solution is

\bprog
? f(x) = 1/(exp(x)-1)-exp(-x)/x
? F = truncate( f(t + O(t^7)) ); \\@com expansion around t = 0
? g(x) = if (x > 1e-18, f(x), subst(F,t,x))  \\@com note that $6 \cdot 18 > 105$
? intnum(x = 0, [oo,1],  g(x)) - Euler
%2 = 0.E-106 \\@com perfect
@eprog\noindent
It is up to the user to determine constants such as the $10^{-18}$ and $7$
used above.

\misctitle{True singularities} With true singularities the result is worse.
For instance

\bprog
? intnum(x = 0, 1,  1/sqrt(x)) - 2
%1 = -1.92... E-59 \\@com only $59$ correct decimals

? intnum(x = [0,-1/2], 1,  1/sqrt(x)) - 2
%2 = 0.E-105 \\@com better
@eprog

\misctitle{Oscillating functions}

\bprog
? intnum(x = 0, oo, sin(x) / x) - Pi/2
%1 = 20.78.. \\@com nonsense
? intnum(x = 0, [oo,1], sin(x)/x) - Pi/2
%2 = 0.004.. \\@com bad
? intnum(x = 0, [oo,-I], sin(x)/x) - Pi/2
%3 = 0.E-105 \\@com perfect
? intnum(x = 0, [oo,-I], sin(2*x)/x) - Pi/2  \\@com oops, wrong $k$
%4 = 0.07...
? intnum(x = 0, [oo,-2*I], sin(2*x)/x) - Pi/2
%5 = 0.E-105 \\@com perfect

? intnum(x = 0, [oo,-I], sin(x)^3/x) - Pi/4
%6 = 0.0092... \\@com bad
? sin(x)^3 - (3*sin(x)-sin(3*x))/4
%7 = O(x^17)
@eprog\noindent
We may use the above linearization and compute two oscillating integrals with
``infinite endpoints'' \kbd{[oo, -I]} and \kbd{[oo, -3*I]} respectively, or
notice the obvious change of variable, and reduce to the single integral
${1\over 2}\int_0^\infty \sin(x)/x\,dx$. We finish with some more complicated
examples:

\bprog
? intnum(x = 0, [oo,-I], (1-cos(x))/x^2) - Pi/2
%1 = -0.0004... \\@com bad
? intnum(x = 0, 1, (1-cos(x))/x^2) \
+ intnum(x = 1, oo, 1/x^2) - intnum(x = 1, [oo,I], cos(x)/x^2) - Pi/2
%2 = -2.18... E-106 \\@com OK

? intnum(x = 0, [oo, 1], sin(x)^3*exp(-x)) - 0.3
%3 = 5.45... E-107 \\@com OK
? intnum(x = 0, [oo,-I], sin(x)^3*exp(-x)) - 0.3
%4 = -1.33... E-89 \\@com lost 16 decimals. Try higher $m$:
? m = intnumstep()
%5 = 7 \\@com the value of $m$ actually used above.
? tab = intnuminit(0,[oo,-I], m+1); \\@com try $m$ one higher.
? intnum(x = 0, oo, sin(x)^3*exp(-x), tab) - 0.3
%6 = 5.45... E-107 \\@com OK this time.
@eprog

\misctitle{Warning} Like \tet{sumalt}, \kbd{intnum} often assigns a
reasonable value to diverging integrals. Use these values at your own risk!
For example:

\bprog
? intnum(x = 0, [oo, -I], x^2*sin(x))
%1 = -2.0000000000...
@eprog\noindent
Note the formula
$$ \int_0^\infty \sin(x)/x^s\,dx = \cos(\pi s/2) \Gamma(1-s)\;, $$
a priori valid only for $0 < \Re(s) < 2$, but the right hand side provides an
analytic continuation which may be evaluated at $s = -2$\dots

\misctitle{Multivariate integration}
Using successive univariate integration with respect to different formal
parameters, it is immediate to do naive multivariate integration. But it is
important to use a suitable \kbd{intnuminit} to precompute data for the
\emph{internal} integrations at least!

For example, to compute the double integral on the unit disc $x^2+y^2\le1$
of the function $x^2+y^2$, we can write
\bprog
? tab = intnuminit(-1,1);
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab), tab)
@eprog\noindent
The first \var{tab} is essential, the second optional. Compare:

\bprog
? tab = intnuminit(-1,1);
time = 30 ms.
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2));
time = 54,410 ms. \\@com slow
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab), tab);
time = 7,210 ms.  \\@com faster
@eprog\noindent
However, the \kbd{intnuminit} program is usually pessimistic when it comes to
choosing the integration step $2^{-m}$. It is often possible to improve the
speed by trial and error. Continuing the above example:
\bprog
? test(M) =
{
tab = intnuminit(-1,1, M);
intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2,tab), tab) - Pi/2
}
? m = intnumstep() \\@com what value of $m$ did it take?
%1 = 7
? test(m - 1)
time = 1,790 ms.
%2 = -2.05... E-104 \\@com $4 = 2^2$ times faster and still OK.
? test(m - 2)
time = 430 ms.
%3 = -1.11... E-104 \\@com $16 = 2^4$ times faster and still OK.
? test(m - 3)
time = 120 ms.
%3 = -7.23... E-60 \\@com $64 = 2^6$ times faster, lost $45$ decimals.
@eprog

\synt{intnum}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b,GEN tab, long prec},
where an omitted \var{tab} is coded as \kbd{NULL}.

\subsec{intnuminit$(a,b,\{m=0\})$}\kbdsidx{intnuminit}\label{se:intnuminit}
Initialize tables for integration from
$a$ to $b$, where $a$ and $b$ are coded as in \kbd{intnum}. Only the
compactness, the possible existence of singularities, the speed of decrease
or the oscillations at infinity are taken into account, and not the values.
For instance {\tt intnuminit(-1,1)} is equivalent to {\tt intnuminit(0,Pi)},
and {\tt intnuminit([0,-1/2],[1])} is equivalent to {\tt
intnuminit([-1],[-1,-1/2])}. If $m$ is not given, it is computed according to
the current precision. Otherwise the integration step is $1/2^m$. Reasonable
values of $m$ are $m=6$ or $m=7$ for $100$ decimal digits, and $m=9$ for
$1000$ decimal digits.

The result is technical, but in some cases it is useful to know the output.
Let $x=\phi(t)$ be the change of variable which is used. \var{tab}[1] contains
the integer $m$ as above, either given by the user or computed from the default
precision, and can be recomputed directly using the function \kbd{intnumstep}.
\var{tab}[2] and \var{tab}[3] contain respectively the abscissa and weight
corresponding to $t=0$ ($\phi(0)$ and $\phi'(0)$). \var{tab}[4] and
\var{tab}[5] contain the abscissas and weights corresponding to positive
$t=nh$ for $1\le n\le N$ and $h=1/2^m$ ($\phi(nh)$ and $\phi'(nh)$). Finally
\var{tab}[6] and \var{tab}[7] contain either the abscissas and weights
corresponding to negative $t=nh$ for $-N\le n\le -1$, or may be empty (but
not always) if $\phi(t)$ is an odd function (implicitly we would have
$\var{tab}[6]=-\var{tab}[4]$ and $\var{tab}[7]=\var{tab}[5]$).

The library syntax is \fun{GEN}{intnuminit}{GEN a, GEN b, long m, long prec}.

\subsec{intnuminitgen$(t,a,b,\var{ph},\{m=0\},\{\fl=0\})$}\kbdsidx{intnuminitgen}\label{se:intnuminitgen}
Initialize tables for integrations from $a$ to $b$ using abscissas
$ph(t)$ and weights $ph'(t)$. Note that there is no equal sign after the
variable name $t$ since $t$ always goes from $-\infty$ to $+\infty$, but it
is $ph(t)$ which goes from $a$ to $b$, and this is not checked. If \fl = 1
or 2, multiply the reserved table length by $4^{\fl}$, to avoid corresponding
error.

\synt{intnuminitgen}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b, long m, long flag, long prec}

\subsec{intnumromb$(X=a,b,\var{expr},\{\fl=0\})$}\kbdsidx{intnumromb}\label{se:intnumromb}
Numerical integration of \var{expr} (smooth in $]a,b[$), with respect to
$X$. Suitable for low accuracy; if \var{expr} is very regular (e.g. analytic
in a large region) and high accuracy is desired, try \tet{intnum} first.

Set $\fl=0$ (or omit it altogether) when $a$ and $b$ are not too large, the
function is smooth, and can be evaluated exactly everywhere on the interval
$[a,b]$.

If $\fl=1$, uses a general driver routine for doing numerical integration,
making no particular assumption (slow).

$\fl=2$ is tailored for being used when $a$ or $b$ are infinite. One
\emph{must} have $ab>0$, and in fact if for example $b=+\infty$, then it is
preferable to have $a$ as large as possible, at least $a\ge1$.

If $\fl=3$, the function is allowed to be undefined (but continuous) at $a$
or $b$, for example the function $\sin(x)/x$ at $x=0$.

The user should not require too much accuracy: 18 or 28 decimal digits is OK,
but not much more. In addition, analytical cleanup of the integral must have
been done: there must be no singularities in the interval or at the
boundaries. In practice this can be accomplished with a simple change of
variable. Furthermore, for improper integrals, where one or both of the
limits of integration are plus or minus infinity, the function must decrease
sufficiently rapidly at infinity. This can often be accomplished through
integration by parts. Finally, the function to be integrated should not be
very small (compared to the current precision) on the entire interval. This
can of course be accomplished by just multiplying by an appropriate constant.

Note that \idx{infinity} can be represented with essentially no loss of
accuracy by an appropriate huge number. However beware of real underflow
when dealing with rapidly decreasing functions. For example, in order to
compute the $\int_0^\infty e^{-x^2}\,dx$ to 28 decimal digits, then one can
set infinity equal to 10 for example, and certainly not to \kbd{1e1000}.

\synt{intnumromb}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b, long flag, long prec},
where $\kbd{eval}(x, E)$ returns the value of the function at $x$.
You may store any additional information required by \kbd{eval} in $E$, or set
it to \kbd{NULL}.

\subsec{intnumstep$()$}\kbdsidx{intnumstep}\label{se:intnumstep}
Give the value of $m$ used in all the
\kbd{intnum} and \kbd{sumnum} programs, hence such that the integration
step is equal to $1/2^m$.

The library syntax is \fun{long}{intnumstep}{long prec}.

\subsec{prod$(X=a,b,\var{expr},\{x=1\})$}\kbdsidx{prod}\label{se:prod}
Product of expression
\var{expr}, initialized at $x$, the formal parameter $X$ going from $a$ to
$b$. As for \kbd{sum}, the main purpose of the initialization parameter $x$
is to force the type of the operations being performed. For example if it is
set equal to the integer 1, operations will start being done exactly. If it
is set equal to the real $1.$, they will be done using real numbers having
the default precision. If it is set equal to the power series $1+O(X^k)$ for
a certain $k$, they will be done using power series of precision at most $k$.
These are the three most common initializations.

\noindent As an extreme example, compare

\bprog
? prod(i=1, 100, 1 - X^i);  \\@com this has degree $5050$ !!
time = 128 ms.
? prod(i=1, 100, 1 - X^i, 1 + O(X^101))
time = 8 ms.
%2 = 1 - X - X^2 + X^5 + X^7 - X^12 - X^15 + X^22 + X^26 - X^35 - X^40 + \
X^51 + X^57 - X^70 - X^77 + X^92 + X^100 + O(X^101)
@eprog\noindent
Of course, in  this specific case, it is faster to use \tet{eta},
which is computed using Euler's formula.
\bprog
? prod(i=1, 1000, 1 - X^i, 1 + O(X^1001));
time = 589 ms.
? \ps1000
seriesprecision = 1000 significant terms
? eta(X) - %
time = 8ms.
%4 = O(X^1001)
@eprog

\synt{produit}{GEN a, GEN b, char *expr, GEN x}.

\subsec{prodeuler$(X=a,b,\var{expr})$}\kbdsidx{prodeuler}\label{se:prodeuler}
Product of expression \var{expr},
initialized at 1. (i.e.~to a \emph{real} number equal to 1 to the current
\kbd{realprecision}), the formal parameter $X$ ranging over the prime numbers
between $a$ and $b$.\sidx{Euler product}

\synt{prodeuler}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b, long prec}.

\subsec{prodinf$(X=a,\var{expr},\{\fl=0\})$}\kbdsidx{prodinf}\label{se:prodinf}
\idx{infinite product} of
expression \var{expr}, the formal parameter $X$ starting at $a$. The evaluation
stops when the relative error of the expression minus 1 is less than the
default precision. In particular, non-convergent products result in infinite
loops. The expressions must always evaluate to an element of $\C$.

If $\fl=1$, do the product of the ($1+\var{expr}$) instead.

\synt{prodinf}{void *E, GEN (*eval)(void*,GEN), GEN a, long prec}
($\fl=0$), or \tet{prodinf1} with the same arguments ($\fl=1$).

\subsec{solve$(X=a,b,\var{expr})$}\kbdsidx{solve}\label{se:solve}
Find a real root of expression
\var{expr} between $a$ and $b$, under the condition
$\var{expr}(X=a) * \var{expr}(X=b) \le 0$. (You will get an error message
\kbd{roots must be bracketed in solve} if this does not hold.)
This routine uses Brent's method and can fail miserably if \var{expr} is
not defined in the whole of $[a,b]$ (try \kbd{solve(x=1, 2, tan(x))}).

\synt{zbrent}{void *E,GEN (*eval)(void*,GEN),GEN a,GEN b,long prec}.

\subsec{sum$(X=a,b,\var{expr},\{x=0\})$}\kbdsidx{sum}\label{se:sum}
Sum of expression \var{expr},
initialized at $x$, the formal parameter going from $a$ to $b$. As for
\kbd{prod}, the initialization parameter $x$ may be given to force the type
of the operations being performed.

\noindent As an extreme example, compare

\bprog
? sum(i=1, 10^4, 1/i); \\@com rational number: denominator has $4345$ digits.
time = 236 ms.
? sum(i=1, 5000, 1/i, 0.)
time = 8 ms.
%2 = 9.787606036044382264178477904
@eprog

\synt{somme}{GEN a, GEN b, char *expr, GEN x}.

\subsec{sumalt$(X=a,\var{expr},\{\fl=0\})$}\kbdsidx{sumalt}\label{se:sumalt}
Numerical summation of the series \var{expr}, which should be an
\idx{alternating series}, the formal variable $X$ starting at $a$. Use an
algorithm of Cohen, Villegas and Zagier (\emph{Experiment. Math.} {\bf 9}
(2000), no.~1, 3--12).

If $\fl=1$, use a variant with slightly different polynomials. Sometimes
faster.

The routine is heuristic and a rigorous proof assumes that the values of
\var{expr} are the moments of a positive measure on $[0,1]$. Divergent
alternating series can sometimes be summed by this method, as well as series
which are not exactly alternating (see for example
\secref{se:user_defined}). It should be used to try and guess the value of
an infinite sum. (However, see the example at the end of
\secref{se:userfundef}.)

If the series already converges geometrically,
\tet{suminf} is often a better choice:
\bprog
? \p28
? sumalt(i = 1, -(-1)^i / i)  - log(2)
time = 0 ms.
%1 = -2.524354897 E-29
? suminf(i = 1, -(-1)^i / i)   \\@com Had to hit <C-C>
  ***   at top-level: suminf(i=1,-(-1)^i/i)
  ***                                ^------
  *** suminf: user interrupt after 10min, 20,100 ms.
? \p1000
? sumalt(i = 1, -(-1)^i / i)  - log(2)
time = 90 ms.
%2 = 4.459597722 E-1002

? sumalt(i = 0, (-1)^i / i!) - exp(-1)
time = 670 ms.
%3 = -4.03698781490633483156497361352190615794353338591897830587 E-944
? suminf(i = 0, (-1)^i / i!) - exp(-1)
time = 110 ms.
%4 = -8.39147638 E-1000   \\ @com faster and more accurate
@eprog

\synt{sumalt}{void *E, GEN (*eval)(void*,GEN),GEN a,long prec}. Also
available is \tet{sumalt2} with the same arguments ($\fl = 1$).

\subsec{sumdiv$(n,X,\var{expr})$}\kbdsidx{sumdiv}\label{se:sumdiv}
Sum of expression \var{expr} over the positive divisors of $n$.
This function is a trivial wrapper essentially equivalent to
\bprog
  D = divisors(n);
  for (i = 1, #D, X = D[i]; eval(expr))
@eprog\noindent (except that \kbd{X} is lexically scoped to the \kbd{sumdiv}
loop). If \var{expr} is a multiplicative function, use \tet{sumdivmult}.
%\syn{NO}

\subsec{sumdivmult$(n,d,\var{expr})$}\kbdsidx{sumdivmult}\label{se:sumdivmult}
Sum of \emph{multiplicative} expression \var{expr} over the positive
divisors $d$ of $n$. Assume that \var{expr} evaluates to $f(d)$
where $f$ is multiplicative: $f(1) = 1$ and $f(ab) = f(a)f(b)$ for coprime
$a$ and $b$.
%\syn{NO}

\subsec{suminf$(X=a,\var{expr})$}\kbdsidx{suminf}\label{se:suminf}
\idx{infinite sum} of expression
\var{expr}, the formal parameter $X$ starting at $a$. The evaluation stops
when the relative error of the expression is less than the default precision
for 3 consecutive evaluations. The expressions must always evaluate to a
complex number.

If the series converges slowly, make sure \kbd{realprecision} is low (even 28
digits may be too much). In this case, if the series is alternating or the
terms have a constant sign, \tet{sumalt} and \tet{sumpos} should be used
instead.

\bprog
? \p28
? suminf(i = 1, -(-1)^i / i)   \\@com Had to hit <C-C>
  ***   at top-level: suminf(i=1,-(-1)^i/i)
  ***                                ^------
  *** suminf: user interrupt after 10min, 20,100 ms.
? sumalt(i = 1, -(-1)^i / i) - log(2)
time = 0 ms.
%1 = -2.524354897 E-29
@eprog

\synt{suminf}{void *E, GEN (*eval)(void*,GEN), GEN a, long prec}.

\subsec{sumnum$(X=a,\var{sig},\var{expr},\{\var{tab}\},\{\fl=0\})$}\kbdsidx{sumnum}\label{se:sumnum}
Numerical summation of \var{expr}, the variable $X$ taking integer values
from ceiling of $a$ to $+\infty$, where \var{expr} is assumed to be a
holomorphic function $f(X)$ for $\Re(X)\ge \sigma$.

The parameter $\sigma\in\R$ is coded in the argument \kbd{sig} as follows: it
is either

\item a real number $\sigma$. Then the function $f$ is assumed to
decrease at least as $1/X^2$ at infinity, but not exponentially;

\item a two-component vector $[\sigma,\alpha]$, where $\sigma$ is as
before, $\alpha < -1$. The function $f$ is assumed to decrease like
$X^{\alpha}$. In particular, $\alpha\le-2$ is equivalent to no $\alpha$ at all.

\item a two-component vector $[\sigma,\alpha]$, where $\sigma$ is as
before, $\alpha > 0$. The function $f$ is assumed to decrease like
$\exp(-\alpha X)$. In this case it is essential that $\alpha$ be exactly the
rate of exponential decrease, and it is usually a good idea to increase
the default value of $m$ used for the integration step. In practice, if
the function is exponentially decreasing \kbd{sumnum} is slower and less
accurate than \kbd{sumpos} or \kbd{suminf}, so should not be used.

The function uses the \tet{intnum} routines and integration on the line
$\Re(s) = \sigma$. The optional argument \var{tab} is as in intnum, except it
must be initialized with \kbd{sumnuminit} instead of \kbd{intnuminit}.

When \var{tab} is not precomputed, \kbd{sumnum} can be slower than
\kbd{sumpos}, when the latter is applicable. It is in general faster for
slowly decreasing functions.

Finally, if $\fl$ is nonzero, we assume that the function $f$ to be summed is
of real type, i.e. satisfies $\overline{f(z)}=f(\overline{z})$, which
speeds up the computation.

\bprog
? \p 308
? a = sumpos(n=1, 1/(n^3+n+1));
time = 1,410 ms.
? tab = sumnuminit(2);
time = 1,620 ms. \\@com slower but done once and for all.
? b = sumnum(n=1, 2, 1/(n^3+n+1), tab);
time = 460 ms. \\@com 3 times as fast as \kbd{sumpos}
? a - b
%4 = -1.0... E-306 + 0.E-320*I \\@com perfect.
? sumnum(n=1, 2, 1/(n^3+n+1), tab, 1) - a; \\@com function of real type
time = 240 ms.
%2 = -1.0... E-306 \\@com twice as fast, no imaginary part.
? c = sumnum(n=1, 2, 1/(n^2+1), tab, 1);
time = 170 ms. \\@com fast
? d = sumpos(n=1, 1 / (n^2+1));
time = 2,700 ms. \\@com slow.
? d - c
time = 0 ms.
%5 = 1.97... E-306 \\@com perfect.
@eprog

For slowly decreasing function, we must indicate singularities:
\bprog
? \p 308
? a = sumnum(n=1, 2, n^(-4/3));
time = 9,930 ms. \\@com slow because of the computation of $n^{-4/3}$.
? a - zeta(4/3)
time = 110 ms.
%1 = -2.42... E-107 \\@com lost 200 decimals because of singularity at $\infty$
? b = sumnum(n=1, [2,-4/3], n^(-4/3), /*omitted*/, 1); \\@com of real type
time = 12,210 ms.
? b - zeta(4/3)
%3 = 1.05... E-300 \\@com better
@eprog

Since the \emph{complex} values of the function are used, beware of
determination problems. For instance:
\bprog
? \p 308
? tab = sumnuminit([2,-3/2]);
time = 1,870 ms.
? sumnum(n=1,[2,-3/2], 1/(n*sqrt(n)), tab,1) - zeta(3/2)
time = 690 ms.
%1 = -1.19... E-305 \\@com fast and correct
? sumnum(n=1,[2,-3/2], 1/sqrt(n^3), tab,1) - zeta(3/2)
time = 730 ms.
%2 = -1.55... \\@com nonsense. However
? sumnum(n=1,[2,-3/2], 1/n^(3/2), tab,1) - zeta(3/2)
time = 8,990 ms.
%3 = -1.19... E-305 \\@com perfect, as $1/(n*\sqrt{n})$ above but much slower
@eprog

For exponentially decreasing functions, \kbd{sumnum} is given for
completeness, but one of \tet{suminf} or \tet{sumpos} should always be
preferred. If you experiment with such functions and \kbd{sumnum} anyway,
indicate the exact rate of decrease and increase $m$ by $1$ or $2$:

\bprog
? suminf(n=1, 2^(-n)) - 1
time = 10 ms.
%1 = -1.11... E-308 \\@com fast and perfect
? sumpos(n=1, 2^(-n)) - 1
time = 10 ms.
%2 = -2.78... E-308 \\@com also fast and perfect
? sumnum(n=1,2, 2^(-n)) - 1
%3 = -1.321115060 E320 + 0.E311*I \\@com nonsense
? sumnum(n=1, [2,log(2)], 2^(-n), /*omitted*/, 1) - 1 \\@com of real type
time = 5,860 ms.
%4 = -1.5... E-236 \\@com slow and lost $70$ decimals
? m = intnumstep()
%5 = 9
? sumnum(n=1,[2,log(2)], 2^(-n), m+1, 1) - 1
time = 11,770 ms.
%6 = -1.9... E-305 \\@com now perfect, but slow.
@eprog

\synt{sumnum}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN sig,GEN tab,long flag, long prec}.

\subsec{sumnumalt$(X=a,\var{sig},\var{expr},\{\var{tab}\},\{\fl=0\})$}\kbdsidx{sumnumalt}\label{se:sumnumalt}
Numerical
summation of $(-1)^X\var{expr}(X)$, the variable $X$ taking integer values from
ceiling of $a$ to $+\infty$, where \var{expr} is assumed to be a holomorphic
function for $\Re(X)\ge sig$ (or $sig[1]$).

\misctitle{Warning} This function uses the \kbd{intnum} routines and is
orders of magnitude slower than \kbd{sumalt}. It is only given for
completeness and should not be used in practice.

\misctitle{Warning 2} The expression \var{expr} must \emph{not} include the
$(-1)^X$ coefficient. Thus $\kbd{sumalt}(n=a,(-1)^nf(n))$ is (approximately)
equal to $\kbd{sumnumalt}(n=a,sig,f(n))$.

$sig$ is coded as in \kbd{sumnum}. However for slowly decreasing functions
(where $sig$ is coded as $[\sigma,\alpha]$ with $\alpha<-1$), it is not
really important to indicate $\alpha$. In fact, as for \kbd{sumalt}, the
program will often give meaningful results (usually analytic continuations)
even for divergent series. On the other hand the exponential decrease must be
indicated.

\var{tab} is as in \kbd{intnum}, but if used must be initialized with
\kbd{sumnuminit}. If $\fl$ is nonzero, assumes that the function $f$ to be
summed is of real type, i.e. satisfies $\overline{f(z)}=f(\overline{z})$, and
then twice faster when \var{tab} is precomputed.

\bprog
? \p 308
? tab = sumnuminit(2, /*omitted*/, -1); \\@com abscissa $\sigma=2$, alternating sums.
time = 1,620 ms. \\@com slow, but done once and for all.
? a = sumnumalt(n=1, 2, 1/(n^3+n+1), tab, 1);
time = 230 ms. \\@com similar speed to \kbd{sumnum}
? b = sumalt(n=1, (-1)^n/(n^3+n+1));
time = 0 ms. \\@com infinitely faster!
? a - b
time = 0 ms.
%1 = -1.66... E-308 \\@com perfect
@eprog

\synt{sumnumalt}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN sig, GEN tab, long flag, long prec}.

\subsec{sumnuminit$(\var{sig}, \{m=0\}, \{\var{sgn}=1\})$}\kbdsidx{sumnuminit}\label{se:sumnuminit}
Initialize tables for numerical summation using \kbd{sumnum} (with
$\var{sgn}=1$) or \kbd{sumnumalt} (with $\var{sgn}=-1$), $sig$ is the
abscissa of integration coded as in \kbd{sumnum}, and $m$ is as in
\kbd{intnuminit}.

The library syntax is \fun{GEN}{sumnuminit}{GEN sig, long m, long sgn, long prec}.

\subsec{sumpos$(X=a,\var{expr},\{\fl=0\})$}\kbdsidx{sumpos}\label{se:sumpos}
Numerical summation of the series \var{expr}, which must be a series of
terms having the same sign, the formal variable $X$ starting at $a$. The
algorithm used is Van Wijngaarden's trick for converting such a series into
an alternating one, then we use \tet{sumalt}. For regular functions, the
function \kbd{sumnum} is in general much faster once the initializations
have been made using \kbd{sumnuminit}.

The routine is heuristic and assumes that \var{expr} is more or less a
decreasing function of $X$. In particular, the result will be completely
wrong if \var{expr} is 0 too often. We do not check either that all terms
have the same sign. As \tet{sumalt}, this function should be used to
try and guess the value of an infinite sum.

If $\fl=1$, use slightly different polynomials. Sometimes faster.

\synt{sumpos}{void *E, GEN (*eval)(void*,GEN),GEN a,long prec}. Also
available is \tet{sumpos2} with the same arguments ($\fl = 1$).
%SECTION: sums

\section{Plotting functions}

  Although plotting is not even a side purpose of PARI, a number of plotting
functions are provided. Moreover, a lot of people
\footnote{*}{Among these, special thanks go to Klaus-Peter Nischke who
suggested the recursive plotting and forking/resizing stuff the graphical
window, and Ilya Zakharevich who rewrote the graphic code from scratch
implementing many new primitives (splines, clipping). Nils Skoruppa and Bill
Allombert wrote the \tet{Qt} and \tet{fltk} graphic drivers respectively.}
suggested ideas or submitted patches for this section of the code. There are
three types of graphic functions.

\subsec{High-level plotting functions} (all the functions starting with
\kbd{ploth}) in which the user has little to do but explain what type of plot
he wants, and whose syntax is similar to the one used in the preceding
section.

\subsec{Low-level plotting functions} (called \var{rectplot} functions,
sharing the prefix \kbd{plot}), where every drawing primitive (point, line,
box, etc.) is specified by the user. These low-level functions work as
follows. You have at your disposal 16 virtual windows which are filled
independently, and can then be physically ORed on a single window at
user-defined positions. These windows are numbered from 0 to 15, and must be
initialized before being used by the function \kbd{plotinit}, which specifies
the height and width of the virtual window (called a \var{rectwindow} in the
sequel). At all times, a virtual cursor (initialized at $[0,0]$) is associated
to the window, and its current value can be obtained using the function
\kbd{plotcursor}.

A number of primitive graphic objects (called \var{rect} objects) can then
be drawn in these windows, using a default color associated to that window
(which can be changed using the \kbd{plotcolor} function) and only the part
of the object which is inside the window will be drawn, with the exception of
polygons and strings which are drawn entirely. The ones sharing the prefix
\kbd{plotr} draw relatively to the current position of the virtual cursor,
the others use absolute coordinates. Those having the prefix \kbd{plotrecth}
put in the rectwindow a large batch of rect objects corresponding to the
output of the related \kbd{ploth} function.

   Finally, the actual physical drawing is done using \kbd{plotdraw}. The
rectwindows are preserved so that further drawings using the same windows at
different positions or different windows can be done without extra work. To
erase a window, use \kbd{plotkill}. It is not possible to partially erase a
window: erase it completely, initialize it again, then fill it with the
graphic objects that you want to keep.

   In addition to initializing the window, you may use a scaled window to
avoid unnecessary conversions. For this, use \kbd{plotscale}. As long as this
function is not called, the scaling is simply the number of pixels, the
origin being at the upper left and the $y$-coordinates going downwards.

   Plotting functions are platform independent, but a number of graphical
drivers are available for screen output: X11-windows (hence also for GUI's
based on X11 such as Openwindows and Motif), and the Qt and FLTK graphical
libraries. The physical window opened by \kbd{plotdraw} or any of the
\kbd{ploth*} functions is completely separated from \kbd{gp} (technically, a
\kbd{fork} is done, and the non-graphical memory is immediately freed in the
child process), which means you can go on working in the current \kbd{gp}
session, without having to kill the window first. This window can be closed,
enlarged or reduced using the standard window manager functions. No zooming
procedure is implemented though (yet).

\subsec{Functions for PostScript output} in the same way that \kbd{printtex} allows you to have a \TeX\ output
corresponding to printed results, the functions starting with \kbd{ps} allow
you to have \tet{PostScript} output of the plots. This will not be identical
with the screen output, but sufficiently close. Note that you can use
PostScript output even if you do not have the plotting routines enabled. The
PostScript output is written in a file whose name is derived from the
\tet{psfile} default (\kbd{./pari.ps} if you did not tamper with it). Each
time a new PostScript output is asked for, the PostScript output is appended
to that file. Hence you probably want to remove this file, or change the
value of \kbd{psfile}, in between plots. On the other hand, in this manner,
as many plots as desired can be kept in a single file. \smallskip

\subsec{Library mode} \emph{None of the graphic functions are available
within the PARI library, you must be under \kbd{gp} to use them}. The reason
for that is that you really should not use PARI for heavy-duty graphical work,
there are better specialized alternatives around. This whole set of routines
was only meant as a convenient, but simple-minded, visual aid. If you really
insist on using these in your program (we warned you), the source
(\kbd{plot*.c}) should be readable enough for you to achieve something.


\subsec{plot$(X=a,b,\var{expr},\{\var{Ymin}\},\{\var{Ymax}\})$}\kbdsidx{plot}\label{se:plot}
Crude ASCII plot of the function represented by expression \var{expr}
from $a$ to $b$, with \var{Y} ranging from \var{Ymin} to \var{Ymax}. If
\var{Ymin} (resp. \var{Ymax}) is not given, the minimum (resp. the maximum)
of the computed values of the expression is used instead.

\subsec{plotbox$(w,\var{x2},\var{y2})$}\kbdsidx{plotbox}\label{se:plotbox}
Let $(x1,y1)$ be the current position of the virtual cursor. Draw in the
rectwindow $w$ the outline of the rectangle which is such that the points
$(x1,y1)$ and $(x2,y2)$ are opposite corners. Only the part of the rectangle
which is in $w$ is drawn. The virtual cursor does \emph{not} move.

\subsec{plotclip$(w)$}\kbdsidx{plotclip}\label{se:plotclip}
`clips' the content of rectwindow $w$, i.e remove all parts of the
drawing that would not be visible on the screen. Together with
\tet{plotcopy} this function enables you to draw on a scratchpad before
committing the part you're interested in to the final picture.

\subsec{plotcolor$(w,c)$}\kbdsidx{plotcolor}\label{se:plotcolor}
Set default color to $c$ in rectwindow $w$.
This is only implemented for the X-windows, fltk and Qt graphing engines.
Possible values for $c$ are given by the \tet{graphcolormap} default,
factory setting are

1=black, 2=blue, 3=violetred, 4=red, 5=green, 6=grey, 7=gainsborough.

but this can be considerably extended.

\subsec{plotcopy$(\var{sourcew},\var{destw},\var{dx},\var{dy},\{\fl=0\})$}\kbdsidx{plotcopy}\label{se:plotcopy}
Copy the contents of rectwindow \var{sourcew} to rectwindow \var{destw}
with offset (dx,dy). If flag's bit 1 is set, dx and dy express fractions of
the size of the current output device, otherwise dx and dy are in pixels. dx
and dy are relative positions of northwest corners if other bits of flag
vanish, otherwise of: 2: southwest, 4: southeast, 6: northeast corners

\subsec{plotcursor$(w)$}\kbdsidx{plotcursor}\label{se:plotcursor}
Give as a 2-component vector the current
(scaled) position of the virtual cursor corresponding to the rectwindow $w$.

\subsec{plotdraw$(\var{list}, \{\fl=0\})$}\kbdsidx{plotdraw}\label{se:plotdraw}
Physically draw the rectwindows given in $list$
which must be a vector whose number of components is divisible by 3. If
$list=[w1,x1,y1,w2,x2,y2,\dots]$, the windows $w1$, $w2$, etc.~are
physically placed with their upper left corner at physical position
$(x1,y1)$, $(x2,y2)$,\dots\ respectively, and are then drawn together.
Overlapping regions will thus be drawn twice, and the windows are considered
transparent. Then display the whole drawing in a special window on your
screen. If $\fl \neq 0$, x1, y1 etc. express fractions of the size of the
current output device

\subsec{ploth$(X=a,b,\var{expr},\{\var{flags}=0\},\{n=0\})$}\kbdsidx{ploth}\label{se:ploth}
High precision plot of the function $y=f(x)$ represented by the expression
\var{expr}, $x$ going from $a$ to $b$. This opens a specific window (which is
killed whenever you click on it), and returns a four-component vector giving
the coordinates of the bounding box in the form
$[\var{xmin},\var{xmax},\var{ymin},\var{ymax}]$.

\misctitle{Important note} \kbd{ploth} may evaluate \kbd{expr} thousands of
times; given the relatively low resolution of plotting devices, few
significant digits of the result will be meaningful. Hence you should keep
the current precision to a minimum (e.g.~9) before calling this function.

$n$ specifies the number of reference point on the graph, where a value of 0
means we use the hardwired default values (1000 for general plot, 1500 for
parametric plot, and 8 for recursive plot).

If no $\fl$ is given, \var{expr} is either a scalar expression $f(X)$, in which
case the plane curve $y=f(X)$ will be drawn, or a vector
$[f_1(X),\dots,f_k(X)]$, and then all the curves $y=f_i(X)$ will be drawn in
the same window.

\noindent The binary digits of $\fl$ mean:

\item $1 = \kbd{Parametric}$: \tev{parametric plot}. Here \var{expr} must
be a vector with an even number of components. Successive pairs are then
understood as the parametric coordinates of a plane curve. Each of these are
then drawn.

For instance:
\bprog
ploth(X=0,2*Pi,[sin(X),cos(X)], "Parametric")
ploth(X=0,2*Pi,[sin(X),cos(X)])
ploth(X=0,2*Pi,[X,X,sin(X),cos(X)], "Parametric")
@eprog\noindent draw successively a circle, two entwined sinusoidal curves
and a circle cut by the line $y=x$.

\item $2 = \kbd{Recursive}$: \tev{recursive plot}. If this flag is set,
only \emph{one} curve can be drawn at a time, i.e.~\var{expr} must be either a
two-component vector (for a single parametric curve, and the parametric flag
\emph{has} to be set), or a scalar function. The idea is to choose pairs of
successive reference points, and if their middle point is not too far away
from the segment joining them, draw this as a local approximation to the
curve. Otherwise, add the middle point to the reference points. This is
fast, and usually more precise than usual plot. Compare the results of
\bprog
ploth(X=-1,1, sin(1/X), "Recursive")
ploth(X=-1,1, sin(1/X))
@eprog\noindent
for instance. But beware that if you are extremely unlucky, or choose too few
reference points, you may draw some nice polygon bearing little resemblance
to the original curve. For instance you should \emph{never} plot recursively
an odd function in a symmetric interval around 0. Try
\bprog
ploth(x = -20, 20, sin(x), "Recursive")
@eprog\noindent
to see why. Hence, it's usually a good idea to try and plot the same curve
with slightly different parameters.

The other values toggle various display options:

\item $4 = \kbd{no\_Rescale}$: do not rescale plot according to the
computed extrema. This is used in conjunction with \tet{plotscale} when
graphing multiple functions on a rectwindow (as a \tet{plotrecth} call):
\bprog
  s = plothsizes();
  plotinit(0, s[2]-1, s[2]-1);
  plotscale(0, -1,1, -1,1);
  plotrecth(0, t=0,2*Pi, [cos(t),sin(t)], "Parametric|no_Rescale")
  plotdraw([0, -1,1]);
@eprog\noindent
This way we get a proper circle instead of the distorted ellipse produced by
\bprog
  ploth(t=0,2*Pi, [cos(t),sin(t)], "Parametric")
@eprog

\item $8 = \kbd{no\_X\_axis}$: do not print the $x$-axis.

\item $16 = \kbd{no\_Y\_axis}$: do not print the $y$-axis.

\item $32 = \kbd{no\_Frame}$: do not print frame.

\item $64 = \kbd{no\_Lines}$: only plot reference points, do not join them.

\item $128 = \kbd{Points\_too}$: plot both lines and points.

\item $256 = \kbd{Splines}$: use splines to interpolate the points.

\item $512 = \kbd{no\_X\_ticks}$: plot no $x$-ticks.

\item $1024 = \kbd{no\_Y\_ticks}$: plot no $y$-ticks.

\item $2048 = \kbd{Same\_ticks}$: plot all ticks with the same length.

\item $4096 = \kbd{Complex}$: is a parametric plot but where each member of
\kbd{expr} is considered a complex number encoding the two coordinates of a
point. For instance:
\bprog
ploth(X=0,2*Pi,exp(I*X), "Complex")
ploth(X=0,2*Pi,[(1+I)*X,exp(I*X)], "Complex")
@eprog\noindent will draw respectively a circle and a circle cut by the line
$y=x$.

\subsec{plothraw$(\var{listx},\var{listy},\{\fl=0\})$}\kbdsidx{plothraw}\label{se:plothraw}
Given \var{listx} and \var{listy} two vectors of equal length, plots (in
high precision) the points whose $(x,y)$-coordinates are given in
\var{listx} and \var{listy}. Automatic positioning and scaling is done, but
with the same scaling factor on $x$ and $y$. If $\fl$ is 1, join points,
other non-0 flags toggle display options and should be combinations of bits
$2^k$, $k \geq 3$ as in \kbd{ploth}.

\subsec{plothsizes$(\{\fl=0\})$}\kbdsidx{plothsizes}\label{se:plothsizes}
Return data corresponding to the output window
in the form of a 6-component vector: window width and height, sizes for ticks
in horizontal and vertical directions (this is intended for the \kbd{gnuplot}
interface and is currently not significant), width and height of characters.

If $\fl = 0$, sizes of ticks and characters are in
pixels, otherwise are fractions of the screen size

\subsec{plotinit$(w,\{x\},\{y\},\{\fl=0\})$}\kbdsidx{plotinit}\label{se:plotinit}
Initialize the rectwindow $w$,
destroying any rect objects you may have already drawn in $w$. The virtual
cursor is set to $(0,0)$. The rectwindow size is set to width $x$ and height
$y$; omitting either $x$ or $y$ means we use the full size of the device
in that direction.
If $\fl=0$, $x$ and $y$ represent pixel units. Otherwise, $x$ and $y$
are understood as fractions of the size of the current output device (hence
must be between $0$ and $1$) and internally converted to pixels.

The plotting device imposes an upper bound for $x$ and $y$, for instance the
number of pixels for screen output. These bounds are available through the
\tet{plothsizes} function. The following sequence initializes in a portable
way (i.e independent of the output device) a window of maximal size, accessed
through coordinates in the $[0,1000] \times [0,1000]$ range:

\bprog
s = plothsizes();
plotinit(0, s[1]-1, s[2]-1);
plotscale(0, 0,1000, 0,1000);
@eprog

\subsec{plotkill$(w)$}\kbdsidx{plotkill}\label{se:plotkill}
Erase rectwindow $w$ and free the corresponding memory. Note that if you
want to use the rectwindow $w$ again, you have to use \kbd{plotinit} first
to specify the new size. So it's better in this case to use \kbd{plotinit}
directly as this throws away any previous work in the given rectwindow.

\subsec{plotlines$(w,X,Y,\{\fl=0\})$}\kbdsidx{plotlines}\label{se:plotlines}
Draw on the rectwindow $w$
the polygon such that the (x,y)-coordinates of the vertices are in the
vectors of equal length $X$ and $Y$. For simplicity, the whole
polygon is drawn, not only the part of the polygon which is inside the
rectwindow. If $\fl$ is non-zero, close the polygon. In any case, the
virtual cursor does not move.

$X$ and $Y$ are allowed to be scalars (in this case, both have to).
There, a single segment will be drawn, between the virtual cursor current
position and the point $(X,Y)$. And only the part thereof which
actually lies within the boundary of $w$. Then \emph{move} the virtual cursor
to $(X,Y)$, even if it is outside the window. If you want to draw a
line from $(x1,y1)$ to $(x2,y2)$ where $(x1,y1)$ is not necessarily the
position of the virtual cursor, use \kbd{plotmove(w,x1,y1)} before using this
function.

\subsec{plotlinetype$(w,\var{type})$}\kbdsidx{plotlinetype}\label{se:plotlinetype}
Change the type of lines subsequently plotted in rectwindow $w$.
\var{type} $-2$ corresponds to frames, $-1$ to axes, larger values may
correspond to something else. $w = -1$ changes highlevel plotting. This is
only taken into account by the \kbd{gnuplot} interface.

\subsec{plotmove$(w,x,y)$}\kbdsidx{plotmove}\label{se:plotmove}
Move the virtual cursor of the rectwindow $w$ to position $(x,y)$.

\subsec{plotpoints$(w,X,Y)$}\kbdsidx{plotpoints}\label{se:plotpoints}
Draw on the rectwindow $w$ the
points whose $(x,y)$-coordinates are in the vectors of equal length $X$ and
$Y$ and which are inside $w$. The virtual cursor does \emph{not} move. This
is basically the same function as \kbd{plothraw}, but either with no scaling
factor or with a scale chosen using the function \kbd{plotscale}.

As was the case with the \kbd{plotlines} function, $X$ and $Y$ are allowed to
be (simultaneously) scalar. In this case, draw the single point $(X,Y)$ on
the rectwindow $w$ (if it is actually inside $w$), and in any case
\emph{move} the virtual cursor to position $(x,y)$.

\subsec{plotpointsize$(w,\var{size})$}\kbdsidx{plotpointsize}\label{se:plotpointsize}
Changes the ``size'' of following points in rectwindow $w$. If $w = -1$,
change it in all rectwindows. This only works in the \kbd{gnuplot} interface.

\subsec{plotpointtype$(w,\var{type})$}\kbdsidx{plotpointtype}\label{se:plotpointtype}
Change the type of points subsequently plotted in rectwindow $w$.
$\var{type} = -1$ corresponds to a dot, larger values may correspond to
something else. $w = -1$ changes highlevel plotting. This is only taken into
account by the \kbd{gnuplot} interface.

\subsec{plotrbox$(w,\var{dx},\var{dy})$}\kbdsidx{plotrbox}\label{se:plotrbox}
Draw in the rectwindow $w$ the outline of the rectangle which is such
that the points $(x1,y1)$ and $(x1+dx,y1+dy)$ are opposite corners, where
$(x1,y1)$ is the current position of the cursor. Only the part of the
rectangle which is in $w$ is drawn. The virtual cursor does \emph{not} move.

\subsec{plotrecth$(w,X=a,b,\var{expr},\{\fl=0\},\{n=0\})$}\kbdsidx{plotrecth}\label{se:plotrecth}
Writes to rectwindow $w$ the curve output of
\kbd{ploth}$(w,X=a,b,\var{expr},\fl,n)$. Returns a vector for the bounding box.

\subsec{plotrecthraw$(w,\var{data},\{\var{flags}=0\})$}\kbdsidx{plotrecthraw}\label{se:plotrecthraw}
Plot graph(s) for
\var{data} in rectwindow $w$. $\fl$ has the same significance here as in
\kbd{ploth}, though recursive plot is no more significant.

\var{data} is a vector of vectors, each corresponding to a list a coordinates.
If parametric plot is set, there must be an even number of vectors, each
successive pair corresponding to a curve. Otherwise, the first one contains
the $x$ coordinates, and the other ones contain the $y$-coordinates
of curves to plot.

\subsec{plotrline$(w,\var{dx},\var{dy})$}\kbdsidx{plotrline}\label{se:plotrline}
Draw in the rectwindow $w$ the part of the segment
$(x1,y1)-(x1+dx,y1+dy)$ which is inside $w$, where $(x1,y1)$ is the current
position of the virtual cursor, and move the virtual cursor to
$(x1+dx,y1+dy)$ (even if it is outside the window).

\subsec{plotrmove$(w,\var{dx},\var{dy})$}\kbdsidx{plotrmove}\label{se:plotrmove}
Move the virtual cursor of the rectwindow $w$ to position
$(x1+dx,y1+dy)$, where $(x1,y1)$ is the initial position of the cursor
(i.e.~to position $(dx,dy)$ relative to the initial cursor).

\subsec{plotrpoint$(w,\var{dx},\var{dy})$}\kbdsidx{plotrpoint}\label{se:plotrpoint}
Draw the point $(x1+dx,y1+dy)$ on the rectwindow $w$ (if it is inside
$w$), where $(x1,y1)$ is the current position of the cursor, and in any case
move the virtual cursor to position $(x1+dx,y1+dy)$.

\subsec{plotscale$(w,\var{x1},\var{x2},\var{y1},\var{y2})$}\kbdsidx{plotscale}\label{se:plotscale}
Scale the local coordinates of the rectwindow $w$ so that $x$ goes from
$x1$ to $x2$ and $y$ goes from $y1$ to $y2$ ($x2<x1$ and $y2<y1$ being
allowed). Initially, after the initialization of the rectwindow $w$ using
the function \kbd{plotinit}, the default scaling is the graphic pixel count,
and in particular the $y$ axis is oriented downwards since the origin is at
the upper left. The function \kbd{plotscale} allows to change all these
defaults and should be used whenever functions are graphed.

\subsec{plotstring$(w,x,\{\var{flags}=0\})$}\kbdsidx{plotstring}\label{se:plotstring}
Draw on the rectwindow $w$ the String $x$ (see \secref{se:strings}), at
the current position of the cursor.

\fl\ is used for justification: bits 1 and 2 regulate horizontal alignment:
left if 0, right if 2, center if 1. Bits 4 and 8 regulate vertical
alignment: bottom if 0, top if 8, v-center if 4. Can insert additional small
gap between point and string: horizontal if bit 16 is set, vertical if bit
32 is set (see the tutorial for an example).

\subsec{psdraw$(\var{list}, \{\fl=0\})$}\kbdsidx{psdraw}\label{se:psdraw}
Same as \kbd{plotdraw}, except that the output is a PostScript program
appended to the \kbd{psfile}, and flag!=0 scales the plot from size of the
current output device to the standard PostScript plotting size

\subsec{psploth$(X=a,b,\var{expr},\{\var{flags}=0\},\{n=0\})$}\kbdsidx{psploth}\label{se:psploth}
Same as \kbd{ploth}, except that the output is a PostScript program
appended to the \kbd{psfile}.

\subsec{psplothraw$(\var{listx},\var{listy},\{\fl=0\})$}\kbdsidx{psplothraw}\label{se:psplothraw}
Same as \kbd{plothraw}, except that the output is a PostScript program
appended to the \kbd{psfile}.
%SECTION: graphic

\section{Programming in GP: control statements}
\sidx{programming}\label{se:programming}

  A number of control statements are available in GP. They are simpler and
have a syntax slightly different from their C counterparts, but are quite
powerful enough to write any kind of program. Some of them are specific to
GP, since they are made for number theorists. As usual, $X$ will denote any
simple variable name, and \var{seq} will always denote a sequence of
expressions, including the empty sequence.

\misctitle{Caveat} In constructs like
\bprog
    for (X = a,b, seq)
@eprog\noindent
the variable \kbd{X} is lexically scoped to the loop, leading to possibly
unexpected behavior:
\bprog
    n = 5;
    for (n = 1, 10,
      if (something_nice(), break);
    );
    \\ @com at this point \kbd{n} is 5 !
@eprog\noindent
If the sequence \kbd{seq} modifies the loop index, then the loop
is modified accordingly:
\bprog
    ? for (n = 1, 10, n += 2; print(n))
    3
    6
    9
    12
@eprog


\subsec{break$(\{n=1\})$}\kbdsidx{break}\label{se:break}
Interrupts execution of current \var{seq}, and
immediately exits from the $n$ innermost enclosing loops, within the
current function call (or the top level loop); the integer $n$ must be
positive. If $n$ is greater than the number of enclosing loops, all
enclosing loops are exited.

\subsec{breakpoint$()$}\kbdsidx{breakpoint}\label{se:breakpoint}
Interrupt the program and enter the breakloop. The program continues when
the breakloop is exited.
\bprog
? f(N,x)=my(z=x^2+1);breakpoint();gcd(N,z^2+1-z);
? f(221,3)
  ***   at top-level: f(221,3)
  ***                 ^--------
  ***   in function f: my(z=x^2+1);breakpoint();gcd(N,z
  ***                              ^--------------------
  ***   Break loop: type <Return> to continue; 'break' to go back to GP
break> z
10
break>
%2 = 13
@eprog

\subsec{dbg\_down$(\{n=1\})$}\kbdsidx{dbg_down}\label{se:dbg_down}
(In the break loop) go down n frames. This allows to cancel a previous call to
\kbd{dbg\_up}.

\subsec{dbg\_err$()$}\kbdsidx{dbg_err}\label{se:dbg_err}
In the break loop, return the error data of the current error, if any.
See \tet{iferr} for details about error data.  Compare:
\bprog
? iferr(1/(Mod(2,12019)^(6!)-1),E,Vec(E))
%1 = ["e_INV", "Fp_inv", Mod(119, 12019)]
? 1/(Mod(2,12019)^(6!)-1)
  ***   at top-level: 1/(Mod(2,12019)^(6!)-
  ***                  ^--------------------
  *** _/_: impossible inverse in Fp_inv: Mod(119, 12019).
  ***   Break loop: type 'break' to go back to GP prompt
break> Vec(dbg_err())
["e_INV", "Fp_inv", Mod(119, 12019)]
@eprog

\subsec{dbg\_up$(\{n=1\})$}\kbdsidx{dbg_up}\label{se:dbg_up}
(In the break loop) go up n frames. This allows to inspect data of the
parent function. To cancel a \tet{dbg_up} call, use \tet{dbg_down}

\subsec{dbg\_x$(A\{,n\})$}\kbdsidx{dbg_x}\label{se:dbg_x}
Print the inner structure of \kbd{A}, complete if \kbd{n} is omitted, up
to level \kbd{n} otherwise. This is useful for debugging. This is similar to
\b{x} but does not require \kbd{A} to be an history entry. In particular,
it can be used in the break loop.

\subsec{for$(X=a,b,\var{seq})$}\kbdsidx{for}\label{se:for}
Evaluates \var{seq}, where
the formal variable $X$ goes from $a$ to $b$. Nothing is done if $a>b$.
$a$ and $b$ must be in $\R$.

\subsec{forcomposite$(n=a,\{b\},\var{seq})$}\kbdsidx{forcomposite}\label{se:forcomposite}
Evaluates \var{seq},
where the formal variable $n$ ranges over the composite numbers between the
non-negative real numbers $a$ to $b$, including $a$ and $b$ if they are
composite. Nothing is done if $a>b$.
\bprog
? forcomposite(n = 0, 10, print(n))
4
6
8
9
10
@eprog\noindent Omitting $b$ means we will run through all composites $\geq a$,
starting an infinite loop; it is expected that the user will break out of
the loop himself at some point, using \kbd{break} or \kbd{return}.

Note that the value of $n$ cannot be modified within \var{seq}:
\bprog
? forcomposite(n = 2, 10, n = [])
 ***   at top-level: forcomposite(n=2,10,n=[])
 ***                                      ^---
 ***   index read-only: was changed to [].
@eprog

\subsec{fordiv$(n,X,\var{seq})$}\kbdsidx{fordiv}\label{se:fordiv}
Evaluates \var{seq}, where
the formal variable $X$ ranges through the divisors of $n$
(see \tet{divisors}, which is used as a subroutine). It is assumed that
\kbd{factor} can handle $n$, without negative exponents. Instead of $n$,
it is possible to input a factorization matrix, i.e. the output of
\kbd{factor(n)}.

This routine uses \kbd{divisors} as a subroutine, then loops over the
divisors. In particular, if $n$ is an integer, divisors are sorted by
increasing size.

To avoid storing all divisors, possibly using a lot of memory, the following
(much slower) routine loops over the divisors using essentially constant
space:
\bprog
FORDIV(N)=
{ my(P, E);

  P = factor(N); E = P[,2]; P = P[,1];
  forvec( v = vector(#E, i, [0,E[i]]),
  X = factorback(P, v)
  \\ ...
);
}
? for(i=1,10^5, FORDIV(i))
time = 3,445 ms.
? for(i=1,10^5, fordiv(i, d, ))
time = 490 ms.
@eprog

\subsec{forell$(E,a,b,\var{seq})$}\kbdsidx{forell}\label{se:forell}
Evaluates \var{seq}, where the formal variable $E = [\var{name}, M, G]$
ranges through all elliptic curves of conductors from $a$ to $b$. In this
notation \var{name} is the curve name in Cremona's elliptic  curve  database,
$M$ is the minimal model, $G$ is a $\Z$-basis of the free part of the
Mordell-Weil group $E(\Q)$.
\bprog
? forell(E, 1, 500, my([name,M,G] = E); \
    if (#G > 1, print(name)))
389a1
433a1
446d1
@eprog\noindent
The \tet{elldata} database must be installed and contain data for the
specified conductors.

\synt{forell}{void *data, long (*call)(void*,GEN), long a, long b}.

\subsec{forpart$(X=k,\var{seq},\{a=k\},\{n=k\})$}\kbdsidx{forpart}\label{se:forpart}
Evaluate \var{seq} over the partitions $X=[x_1,\dots x_n]$ of the
integer $k$, i.e.~increasing sequences $x_1\leq x_2\dots \leq x_n$ of sum
$x_1+\dots + x_n=k$. By convention, $0$ admits only the empty partition and
negative numbers have no partitions. A partition is given by a
\typ{VECSMALL}, where parts are sorted in nondecreasing order:
\bprog
? forpart(X=3, print(X))
Vecsmall([3])
Vecsmall([1, 2])
Vecsmall([1, 1, 1])
@eprog\noindent Optional parameters $n$ and $a$ are as follows:

\item $n=\var{nmax}$ (resp. $n=[\var{nmin},\var{nmax}]$) restricts
partitions to length less than $\var{nmax}$ (resp. length between
$\var{nmin}$ and $nmax$), where the \emph{length} is the number of nonzero
entries.

\item $a=\var{amax}$ (resp. $a=[\var{amin},\var{amax}]$) restricts the parts
to integers less than $\var{amax}$ (resp. between $\var{amin}$ and
$\var{amax}$).

By default, parts are positive and we remove zero entries unless $amin\leq0$,
in which case $X$ is of constant length $\var{nmax}$.
\bprog
\\ at most 3 non-zero parts, all <= 4
? forpart(v=5,print(Vec(v)),4,3)
[1, 4]
[2, 3]
[1, 1, 3]
[1, 2, 2]

\\ between 2 and 4 parts less than 5, fill with zeros
? forpart(v=5,print(Vec(v)),[0,5],[2,4])
[0, 0, 1, 4]
[0, 0, 2, 3]
[0, 1, 1, 3]
[0, 1, 2, 2]
[1, 1, 1, 2]
@eprog\noindent
The behavior is unspecified if $X$ is modified inside the loop.

\synt{forpart}{void *data, long (*call)(void*,GEN), long k, GEN a, GEN n}.

\subsec{forprime$(p=a,\{b\},\var{seq})$}\kbdsidx{forprime}\label{se:forprime}
Evaluates \var{seq},
where the formal variable $p$ ranges over the prime numbers between the real
numbers $a$ to $b$, including $a$ and $b$ if they are prime. More precisely,
the value of
$p$ is incremented to \kbd{nextprime($p$ + 1)}, the smallest prime strictly
larger than $p$, at the end of each iteration. Nothing is done if $a>b$.
\bprog
? forprime(p = 4, 10, print(p))
5
7
@eprog\noindent Omitting $b$ means we will run through all primes $\geq a$,
starting an infinite loop; it is expected that the user will break out of
the loop himself at some point, using \kbd{break} or \kbd{return}.

Note that the value of $p$ cannot be modified within \var{seq}:
\bprog
? forprime(p = 2, 10, p = [])
 ***   at top-level: forprime(p=2,10,p=[])
 ***                                   ^---
 ***   prime index read-only: was changed to [].
@eprog

\subsec{forstep$(X=a,b,s,\var{seq})$}\kbdsidx{forstep}\label{se:forstep}
Evaluates \var{seq},
where the formal variable $X$ goes from $a$ to $b$, in increments of $s$.
Nothing is done if $s>0$ and $a>b$ or if $s<0$ and $a<b$. $s$ must be in
$\R^*$ or a vector of steps $[s_1,\dots,s_n]$. In the latter case, the
successive steps are used in the order they appear in $s$.

\bprog
? forstep(x=5, 20, [2,4], print(x))
5
7
11
13
17
19
@eprog

\subsec{forsubgroup$(H=G,\{\var{bound}\},\var{seq})$}\kbdsidx{forsubgroup}\label{se:forsubgroup}
Evaluates \var{seq} for
each subgroup $H$ of the \emph{abelian} group $G$ (given in
SNF\sidx{Smith normal form} form or as a vector of elementary divisors).

If \var{bound} is present, and is a positive integer, restrict the output to
subgroups of index less than \var{bound}. If \var{bound} is a vector
containing a single positive integer $B$, then only subgroups of index
exactly equal to $B$ are computed

The subgroups are not ordered in any
obvious way, unless $G$ is a $p$-group in which case Birkhoff's algorithm
produces them by decreasing index. A \idx{subgroup} is given as a matrix
whose columns give its generators on the implicit generators of $G$. For
example, the following prints all subgroups of index less than 2 in $G =
\Z/2\Z g_1 \times \Z/2\Z g_2$:

\bprog
? G = [2,2]; forsubgroup(H=G, 2, print(H))
[1; 1]
[1; 2]
[2; 1]
[1, 0; 1, 1]
@eprog\noindent
The last one, for instance is generated by $(g_1, g_1 + g_2)$. This
routine is intended to treat huge groups, when \tet{subgrouplist} is not an
option due to the sheer size of the output.

For maximal speed the subgroups have been left as produced by the algorithm.
To print them in canonical form (as left divisors of $G$ in HNF form), one
can for instance use
\bprog
? G = matdiagonal([2,2]); forsubgroup(H=G, 2, print(mathnf(concat(G,H))))
[2, 1; 0, 1]
[1, 0; 0, 2]
[2, 0; 0, 1]
[1, 0; 0, 1]
@eprog\noindent
Note that in this last representation, the index $[G:H]$ is given by the
determinant. See \tet{galoissubcyclo} and \tet{galoisfixedfield} for
applications to \idx{Galois} theory.

\synt{forsubgroup}{void *data, long (*call)(void*,GEN), GEN G, GEN bound}.

\subsec{forvec$(X=v,\var{seq},\{\fl=0\})$}\kbdsidx{forvec}\label{se:forvec}
Let $v$ be an $n$-component
vector (where $n$ is arbitrary) of two-component vectors $[a_i,b_i]$
for $1\le i\le n$. This routine evaluates \var{seq}, where the formal
variables $X[1],\dots, X[n]$ go from $a_1$ to $b_1$,\dots, from $a_n$ to
$b_n$, i.e.~$X$ goes from $[a_1,\dots,a_n]$ to $[b_1,\dots,b_n]$ with respect
to the lexicographic ordering. (The formal variable with the highest index
moves the fastest.) If $\fl=1$, generate only nondecreasing vectors $X$, and
if $\fl=2$, generate only strictly increasing vectors $X$.

The type of $X$ is the same as the type of $v$: \typ{VEC} or \typ{COL}.

\subsec{if$(a,\{\var{seq1}\},\{\var{seq2}\})$}\kbdsidx{if}\label{se:if}
Evaluates the expression sequence \var{seq1} if $a$ is non-zero, otherwise
the expression \var{seq2}. Of course, \var{seq1} or \var{seq2} may be empty:

\kbd{if ($a$,\var{seq})} evaluates \var{seq} if $a$ is not equal to zero
(you don't have to write the second comma), and does nothing otherwise,

\kbd{if ($a$,,\var{seq})} evaluates \var{seq} if $a$ is equal to zero, and
does nothing otherwise. You could get the same result using the \kbd{!}
(\kbd{not}) operator: \kbd{if (!$a$,\var{seq})}.

The value of an \kbd{if} statement is the value of the branch that gets
evaluated: for instance
\bprog
x = if(n % 4 == 1, y, z);
@eprog\noindent sets $x$ to $y$ if $n$ is $1$ modulo $4$, and to $z$
otherwise.

Successive 'else' blocks can be abbreviated in a single compound \kbd{if}
as follows:
\bprog
if (test1, seq1,
    test2, seq2,
    ...
    testn, seqn,
    seqdefault);
@eprog\noindent is equivalent to
\bprog
if (test1, seq1
         , if (test2, seq2
                    , ...
                      if (testn, seqn, seqdefault)...));
@eprog For instance, this allows to write traditional switch / case
constructions:
\bprog
if (x == 0, do0(),
    x == 1, do1(),
    x == 2, do2(),
    dodefault());
@eprog

\misctitle{Remark}
The boolean operators \kbd{\&\&} and \kbd{||} are evaluated
according to operator precedence as explained in \secref{se:operators}, but,
contrary to other operators, the evaluation of the arguments is stopped
as soon as the final truth value has been determined. For instance
\bprog
if (x != 0 && f(1/x), ...)
@eprog
\noindent is a perfectly safe statement.

\misctitle{Remark} Functions such as \kbd{break} and \kbd{next} operate on
\emph{loops}, such as \kbd{for$xxx$}, \kbd{while}, \kbd{until}. The \kbd{if}
statement is \emph{not} a loop. (Obviously!)

\subsec{iferr$(\var{seq1},E,\var{seq2}\{,\var{pred}\})$}\kbdsidx{iferr}\label{se:iferr}
Evaluates the expression sequence \var{seq1}. If an error occurs,
set the formal parameter \var{E} set to the error data.
If \var{pred} is not present or evaluates to true, catch the error
and evaluate \var{seq2}. Both \var{pred} and \var{seq2} can reference \var{E}.
The error type is given by \kbd{errname(E)}, and other data can be
accessed using the \tet{component} function. The code \var{seq2} should check
whether the error is the one expected. In the negative the error can be
rethrown using \tet{error(E)} (and possibly caught by an higher \kbd{iferr}
instance). The following uses \kbd{iferr} to implement Lenstra's ECM factoring
 method
\bprog
? ecm(N, B = 1000!, nb = 100)=
  {
    for(a = 1, nb,
      iferr(ellmul(ellinit([a,1]*Mod(1,N)), [0,1]*Mod(1,N), B),
        E, return(gcd(lift(component(E,2)),N)),
        errname(E)=="e_INV" && type(component(E,2)) == "t_INTMOD"))
  }
? ecm(2^101-1)
%2 = 7432339208719
@eprog
The return value of \kbd{iferr} itself is the value of \var{seq2} if an
error occurs, and the value of \var{seq1} otherwise. We now describe the
list of valid error types, and the associated error data \var{E}; in each
case, we list in order the components of \var{E}, accessed via
\kbd{component(E,1)}, \kbd{component(E,2)}, etc.

 \misctitle{Internal errors, ``system'' errors}

 \item \kbd{"e\_ARCH"}. A requested feature $s$ is not available on this
 architecture or operating system.
 \var{E} has one component (\typ{STR}): the missing feature name $s$.

 \item \kbd{"e\_BUG"}. A bug in the PARI library, in function $s$.
 \var{E} has one component (\typ{STR}): the function name $s$.

 \item \kbd{"e\_FILE"}. Error while trying to open a file.
 \var{E} has two components, 1 (\typ{STR}): the file type (input, output,
 etc.), 2 (\typ{STR}): the file name.

 \item \kbd{"e\_IMPL"}. A requested feature $s$ is not implemented.
 \var{E} has one component, 1 (\typ{STR}): the feature name $s$.

 \item \kbd{"e\_PACKAGE"}. Missing optional package $s$.
 \var{E} has one component, 1 (\typ{STR}): the package name $s$.

 \misctitle{Syntax errors, type errors}

 \item \kbd{"e\_DIM"}. The dimensions of arguments $x$ and $y$ submitted
 to function $s$ does not match up.
 E.g., multiplying matrices of inconsistent dimension, adding vectors of
 different lengths,\dots
 \var{E} has three component, 1 (\typ{STR}): the function name $s$, 2: the
 argument $x$, 3: the argument $y$.

 \item \kbd{"e\_FLAG"}. A flag argument is out of bounds in function $s$.
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_NOTFUNC"}. Generated by the PARI evaluator; tried to use a
\kbd{GEN} $x$ which is not a \typ{CLOSURE} in a function call syntax (as in
\kbd{f = 1; f(2);}).
 \var{E} has one component, 1: the offending \kbd{GEN} $x$.

 \item \kbd{"e\_OP"}. Impossible operation between two objects than cannot
 be typecast to a sensible common domain for deeper reasons than a type
 mismatch, usually for arithmetic reasons. As in \kbd{O(2) + O(3)}: it is
 valid to add two \typ{PADIC}s, provided the underlying prime is the same; so
 the addition is not forbidden a priori for type reasons, it only becomes so
 when inspecting the objects and trying to perform the operation.
 \var{E} has three components, 1 (\typ{STR}): the operator name \var{op},
 2: first argument, 3: second argument.

 \item \kbd{"e\_TYPE"}. An argument $x$ of function $s$ had an unexpected type.
 (As in \kbd{factor("blah")}.)
 \var{E} has two components, 1 (\typ{STR}): the function name $s$,
 2: the offending argument $x$.

 \item \kbd{"e\_TYPE2"}. Forbidden operation between two objects than cannot be
 typecast to a sensible common domain, because their types do not match up.
 (As in \kbd{Mod(1,2) + Pi}.)
 \var{E} has three components, 1 (\typ{STR}): the operator name \var{op},
 2: first argument, 3: second argument.

 \item \kbd{"e\_PRIORITY"}. Object $o$ in function $s$ contains
 variables whose priority is incompatible with the expected operation.
 E.g.~\kbd{Pol([x,1], 'y)}: this raises an error because it's not possible to
 create a polynomial whose coefficients involve variables with higher priority
 than the main variable. $E$ has four components: 1 (\typ{STR}): the function
 name $s$, 2: the offending argument $o$, 3 (\typ{STR}): an operator
 $\var{op}$ describing the priority error, 4 (\typ{POL}):
 the variable $v$ describing the priority error. The argument
 satisfies $\kbd{variable}(x)~\var{op} \kbd{variable}(v)$.

 \item \kbd{"e\_VAR"}. The variables of arguments $x$ and $y$ submitted
 to function $s$ does not match up. E.g., considering the algebraic number
 \kbd{Mod(t,t\pow2+1)} in \kbd{nfinit(x\pow2+1)}.
 \var{E} has three component, 1 (\typ{STR}): the function name $s$, 2
 (\typ{POL}): the argument $x$, 3 (\typ{POL}): the argument $y$.

 \misctitle{Overflows}

 \item \kbd{"e\_COMPONENT"}. Trying to access an inexistent component in a
 vector/matrix/list in a function: the index is less than $1$ or greater
 than the allowed length.
 \var{E} has four components,
 1 (\typ{STR}): the function name
 2 (\typ{STR}): an operator $\var{op}$ ($<$ or $>$),
 2 (\typ{GEN}): a numerical limit $l$ bounding the allowed range,
 3 (\kbd{GEN}): the index $x$. It satisfies $x$ \var{op} $l$.

 \item \kbd{"e\_DOMAIN"}. An argument is not in the function's domain.
 \var{E} has five components, 1 (\typ{STR}): the function name,
 2 (\typ{STR}): the mathematical name of the out-of-domain argument
 3 (\typ{STR}): an operator $\var{op}$ describing the domain error,
 4 (\typ{GEN}): the numerical limit $l$ describing the domain error,
 5 (\kbd{GEN}): the out-of-domain argument $x$. The argument satisfies $x$
 \var{op} $l$, which prevents it from belonging to the function's domain.

 \item \kbd{"e\_MAXPRIME"}. A function using the precomputed list of prime
 numbers ran out of primes.
 \var{E} has one component, 1 (\typ{INT}): the requested prime bound, which
 overflowed \kbd{primelimit} or $0$ (bound is unknown).

 \item \kbd{"e\_MEM"}. A call to \tet{pari_malloc} or \tet{pari_realloc}
 failed. \var{E} has no component.

 \item \kbd{"e\_OVERFLOW"}. An object in function $s$ becomes too large to be
 represented within PARI's hardcoded limits. (As in \kbd{2\pow2\pow2\pow10} or
 \kbd{exp(1e100)}, which overflow in \kbd{lg} and \kbd{expo}.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_PREC"}. Function $s$ fails because input accuracy is too low.
 (As in \kbd{floor(1e100)} at default accuracy.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_STACK"}. The PARI stack overflows.
 \var{E} has no component.

 \misctitle{Errors triggered intentionally}

 \item \kbd{"e\_ALARM"}. A timeout, generated by the \tet{alarm} function.
 \var{E} has one component (\typ{STR}): the error message to print.

 \item \kbd{"e\_USER"}. A user error, as triggered by
 \tet{error}($g_1,\dots,g_n)$.
 \var{E} has one component, 1 (\typ{VEC}): the vector of $n$ arguments given
 to \kbd{error}.

 \misctitle{Mathematical errors}

 \item \kbd{"e\_CONSTPOL"}. An argument of function $s$ is a constant
 polynomial, which does not make sense. (As in \kbd{galoisinit(Pol(1))}.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_COPRIME"}. Function $s$ expected coprime arguments,
 and did receive $x,y$, which were not.
 \var{E} has three component, 1 (\typ{STR}): the function name $s$,
 2: the argument $x$, 3: the argument $y$.

 \item \kbd{"e\_INV"}. Tried to invert a non-invertible object $x$ in
 function $s$.
 \var{E} has two components, 1 (\typ{STR}): the function name $s$,
 2: the non-invertible $x$. If $x = \kbd{Mod}(a,b)$
 is a \typ{INTMOD} and $a$ is not $0$ mod $b$, this allows to factor
 the modulus, as \kbd{gcd}$(a,b)$ is a non-trivial divisor of $b$.

 \item \kbd{"e\_IRREDPOL"}. Function $s$ expected an irreducible polynomial,
 and did receive $T$, which was not. (As in \kbd{nfinit(x\pow2-1)}.)
 \var{E} has two component, 1 (\typ{STR}): the function name $s$,
 2 (\typ{POL}): the polynomial $x$.

 \item \kbd{"e\_MISC"}. Generic uncategorized error.
 \var{E} has one component (\typ{STR}): the error message to print.

 \item \kbd{"e\_MODULUS"}. moduli $x$ and $y$ submitted to function $s$ are
 inconsistent. As in
 \bprog
   nfalgtobasis(nfinit(t^3-2), Mod(t,t^2+1)
 @eprog\noindent
 \var{E} has three component, 1 (\typ{STR}): the function $s$,
 2: the argument $x$, 3: the argument $x$.

 \item \kbd{"e\_NEGVAL"}. An argument of function $s$ is a power series with
 negative valuation, which does not make sense. (As in \kbd{cos(1/x)}.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_PRIME"}. Function $s$ expected a prime number,
 and did receive $p$, which was not. (As in \kbd{idealprimedec(nf, 4)}.)
 \var{E} has two component, 1 (\typ{STR}): the function name $s$,
 2: the argument $p$.

 \item \kbd{"e\_ROOTS0"}. An argument of function $s$ is a zero polynomial,
 and we need to consider its roots. (As in \kbd{polroots(0)}.) \var{E} has
 one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_SQRTN"}. Trying to compute an $n$-th root of $x$, which does
 not exist, in function $s$. (As in \kbd{sqrt(Mod(-1,3))}.)
 \var{E} has two components, 1 (\typ{STR}): the function name $s$,
 2: the argument $x$.

\subsec{next$(\{n=1\})$}\kbdsidx{next}\label{se:next}
Interrupts execution of current $seq$,
resume the next iteration of the innermost enclosing loop, within the
current function call (or top level loop). If $n$ is specified, resume at
the $n$-th enclosing loop. If $n$ is bigger than the number of enclosing
loops, all enclosing loops are exited.

\subsec{return$(\{x=0\})$}\kbdsidx{return}\label{se:return}
Returns from current subroutine, with
result $x$. If $x$ is omitted, return the \kbd{(void)} value (return no
result, like \kbd{print}).

\subsec{until$(a,\var{seq})$}\kbdsidx{until}\label{se:until}
Evaluates \var{seq} until $a$ is not
equal to 0 (i.e.~until $a$ is true). If $a$ is initially not equal to 0,
\var{seq} is evaluated once (more generally, the condition on $a$ is tested
\emph{after} execution of the \var{seq}, not before as in \kbd{while}).

\subsec{while$(a,\var{seq})$}\kbdsidx{while}\label{se:while}
While $a$ is non-zero, evaluates the expression sequence \var{seq}. The
test is made \emph{before} evaluating the $seq$, hence in particular if $a$
is initially equal to zero the \var{seq} will not be evaluated at all.
%SECTION: programming/control

\section{Programming in GP: other specific functions}
\label{se:gp_program}

  In addition to the general PARI functions, it is necessary to have some
functions which will be of use specifically for \kbd{gp}, though a few of these can
be accessed under library mode. Before we start describing these, we recall
the difference between \emph{strings} and \emph{keywords} (see
\secref{se:strings}): the latter don't get expanded at all, and you can type
them without any enclosing quotes. The former are dynamic objects, where
everything outside quotes gets immediately expanded.


\subsec{Strprintf$(\var{fmt},\{x\}*)$}\kbdsidx{Strprintf}\label{se:Strprintf}
Returns a string built from the remaining arguments according to the
format fmt. The format consists of ordinary characters (not \%), printed
unchanged, and conversions specifications. See \kbd{printf}.
%\syn{NO}

\subsec{addhelp$(\var{sym},\var{str})$}\kbdsidx{addhelp}\label{se:addhelp}
Changes the help message for the symbol \kbd{sym}. The string \var{str}
is expanded on the spot and stored as the online help for \kbd{sym}. It is
recommended to document global variables and user functions in this way,
although \kbd{gp} will not protest if you don't.

You can attach a help text to an alias, but it will never be
shown: aliases are expanded by the \kbd{?} help operator and we get the help
of the symbol the alias points to. Nothing prevents you from modifying the
help of built-in PARI functions. But if you do, we would like to hear why you
needed it!

Without \tet{addhelp}, the standard help for user functions consists of its
name and definition.
\bprog
gp> f(x) = x^2;
gp> ?f
f =
  (x)->x^2

@eprog\noindent Once addhelp is applied to $f$, the function code is no
longer included. It can still be consulted by typing the function name:
\bprog
gp> addhelp(f, "Square")
gp> ?f
Square

gp> f
%2 = (x)->x^2
@eprog

The library syntax is \fun{void}{addhelp}{const char *sym, const char *str}.

\subsec{alarm$(\{s = 0\},\{\var{code}\})$}\kbdsidx{alarm}\label{se:alarm}
If \var{code} is omitted, trigger an \var{e\_ALARM} exception after $s$
seconds, cancelling any previously set alarm; stop a pending alarm if $s =
0$ or is omitted.

Otherwise, if $s$ is positive, the function evaluates \var{code},
aborting after $s$ seconds. The return value is the value of \var{code} if
it ran to completion before the alarm timeout, and a \typ{ERROR} object
otherwise.
\bprog
  ? p = nextprime(10^25); q = nextprime(10^26); N = p*q;
  ? E = alarm(1, factor(N));
  ? type(E)
  %3 = "t_ERROR"
  ? print(E)
  %4 = error("alarm interrupt after 964 ms.")
  ? alarm(10, factor(N));   \\ enough time
  %5 =
  [ 10000000000000000000000013 1]

  [100000000000000000000000067 1]
@eprog\noindent Here is a more involved example: the function
\kbd{timefact(N,sec)} below tries to factor $N$ and gives up after \var{sec}
seconds, returning a partial factorisation.
\bprog
\\ Time-bounded partial factorization
default(factor_add_primes,1);
timefact(N,sec)=
{
  F = alarm(sec, factor(N));
  if (type(F) == "t_ERROR", factor(N, 2^24), F);
}
@eprog\noindent We either return the factorization directly, or replace the
\typ{ERROR} result by a simple bounded factorization \kbd{factor(N, 2\pow 24)}.
Note the \tet{factor_add_primes} trick: any prime larger than $2^{24}$
discovered while attempting the initial factorization is stored and
remembered. When the alarm rings, the subsequent bounded factorization finds
it right away.

\misctitle{Caveat} It is not possible to set a new alarm \emph{within}
another \kbd{alarm} code: the new timer erases the parent one.

\subsec{alias$(\var{newsym},\var{sym})$}\kbdsidx{alias}\label{se:alias}
Defines the symbol \var{newsym} as an alias for the the symbol \var{sym}:
\bprog
? alias("det", "matdet");
? det([1,2;3,4])
%1 = -2
@eprog\noindent
You are not restricted to ordinary functions, as in the above example:
to alias (from/to) member functions, prefix them with `\kbd{\_.}';
to alias operators, use their internal name, obtained by writing
\kbd{\_} in lieu of the operators argument: for instance, \kbd{\_!} and
\kbd{!\_} are the internal names of the factorial and the
logical negation, respectively.
\bprog
? alias("mod", "_.mod");
? alias("add", "_+_");
? alias("_.sin", "sin");
? mod(Mod(x,x^4+1))
%2 = x^4 + 1
? add(4,6)
%3 = 10
? Pi.sin
%4 = 0.E-37
@eprog
Alias expansion is performed directly by the internal GP compiler.
Note that since alias is performed at compilation-time, it does not
require any run-time processing, however it only affects GP code
compiled \emph{after} the alias command is evaluated. A slower but more
flexible alternative is to use variables. Compare
\bprog
? fun = sin;
? g(a,b) = intnum(t=a,b,fun(t));
? g(0, Pi)
%3 = 2.0000000000000000000000000000000000000
? fun = cos;
? g(0, Pi)
%5 = 1.8830410776607851098 E-39
@eprog\noindent
with
\bprog
? alias(fun, sin);
? g(a,b) = intnum(t=a,b,fun(t));
? g(0,Pi)
%2 = 2.0000000000000000000000000000000000000
? alias(fun, cos);  \\ Oops. Does not affect *previous* definition!
? g(0,Pi)
%3 = 2.0000000000000000000000000000000000000
? g(a,b) = intnum(t=a,b,fun(t)); \\ Redefine, taking new alias into account
? g(0,Pi)
%5 = 1.8830410776607851098 E-39
@eprog

A sample alias file \kbd{misc/gpalias} is provided with
the standard distribution.

The library syntax is \fun{void}{alias0}{const char *newsym, const char *sym}.

\subsec{allocatemem$(\{s=0\})$}\kbdsidx{allocatemem}\label{se:allocatemem}
This special operation changes the stack size \emph{after}
initialization. $x$ must be a non-negative integer. If $x > 0$, a new stack
of at least $x$ bytes is allocated. We may allocate more than $x$ bytes if
$x$ is way too small, or for alignment reasons: the current formula is
$\max(16*\ceil{x/16}, 500032)$ bytes.

If $x=0$, the size of the new stack is twice the size of the old one. The
old stack is discarded.

\misctitle{Warning} This function should be typed at the \kbd{gp} prompt in
interactive usage, or left by itself at the start of batch files.
It cannot be used meaningfully in loop-like constructs, or as part of a
larger expression sequence, e.g
\bprog
   allocatemem(); x = 1;   \\@com This will not set \kbd{x}!
@eprog\noindent
In fact, all loops are immediately exited, user functions terminated, and
the rest of the sequence following \kbd{allocatemem()} is silently
discarded, as well as all pending sequences of instructions. We just go on
reading the next instruction sequence from the file we're in (or from the
user). In particular, we have the following possibly unexpected behavior: in
\bprog
   read("file.gp"); x = 1
@eprog\noindent were \kbd{file.gp} contains an \kbd{allocatemem} statement,
the \kbd{x = 1} is never executed, since all pending instructions in the
current sequence are discarded.

The technical reason is that this routine moves the stack, so temporary
objects created during the current expression evaluation are not correct
anymore. (In particular byte-compiled expressions, which are allocated on
the stack.) To avoid accessing obsolete pointers to the old stack, this
routine ends by a \kbd{longjmp}.

\misctitle{Remark} If the operating system cannot allocate the desired
$x$ bytes, a loop halves the allocation size until it succeeds:
\bprog
? allocatemem(5*10^10)
 ***   Warning: not enough memory, new stack 50000000000.
 ***   Warning: not enough memory, new stack 25000000000.
 ***   Warning: not enough memory, new stack 12500000000.
 ***   Warning: new stack size = 6250000000 (5960.464 Mbytes).
@eprog

\subsec{apply$(f, A)$}\kbdsidx{apply}\label{se:apply}
Apply the \typ{CLOSURE} \kbd{f} to the entries of \kbd{A}. If \kbd{A}
is a scalar, return \kbd{f(A)}. If \kbd{A} is a polynomial or power series,
apply \kbd{f} on all coefficients. If \kbd{A} is a vector or list, return
the elements $f(x)$ where $x$ runs through \kbd{A}. If \kbd{A} is a matrix,
return the matrix whose entries are the $f(\kbd{A[i,j]})$.
\bprog
? apply(x->x^2, [1,2,3,4])
%1 = [1, 4, 9, 16]
? apply(x->x^2, [1,2;3,4])
%2 =
[1 4]

[9 16]
? apply(x->x^2, 4*x^2 + 3*x+ 2)
%3 = 16*x^2 + 9*x + 4
@eprog\noindent Note that many functions already act componentwise on
vectors or matrices, but they almost never act on lists; in this
case, \kbd{apply} is a good solution:
\bprog
? L = List([Mod(1,3), Mod(2,4)]);
? lift(L)
  ***   at top-level: lift(L)
  ***                 ^-------
  *** lift: incorrect type in lift.
? apply(lift, L);
%2 = List([1, 2])
@eprog
\misctitle{Remark} For $v$ a \typ{VEC}, \typ{COL}, \typ{LIST} or \typ{MAT},
the alternative set-notations
\bprog
[g(x) | x <- v, f(x)]
[x | x <- v, f(x)]
[g(x) | x <- v]
@eprog\noindent
are available as shortcuts for
\bprog
apply(g, select(f, Vec(v)))
select(f, Vec(v))
apply(g, Vec(v))
@eprog\noindent respectively:
\bprog
? L = List([Mod(1,3), Mod(2,4)]);
? [ lift(x) | x<-L ]
%2 = [1, 2]
@eprog

\synt{genapply}{void *E, GEN (*fun)(void*,GEN), GEN a}.

\subsec{default$(\{\var{key}\},\{\var{val}\})$}\kbdsidx{default}\label{se:default}
Returns the default corresponding to keyword \var{key}. If \var{val} is
present, sets the default to \var{val} first (which is subject to string
expansion first). Typing \kbd{default()} (or \b{d}) yields the complete
default list as well as their current values. See \secref{se:defaults} for an
introduction to GP defaults, \secref{se:gp_defaults} for a
list of available defaults, and \secref{se:meta} for some shortcut
alternatives. Note that the shortcuts are meant for interactive use and
usually display more information than \kbd{default}.

The library syntax is \fun{GEN}{default0}{const char *key = NULL, const char *val = NULL}.

\subsec{errname$(E)$}\kbdsidx{errname}\label{se:errname}
Returns the type of the error message \kbd{E} as a string.

The library syntax is \fun{GEN}{errname}{GEN E}.

\subsec{error$(\{\var{str}\}*)$}\kbdsidx{error}\label{se:error}
Outputs its argument list (each of
them interpreted as a string), then interrupts the running \kbd{gp} program,
returning to the input prompt. For instance
\bprog
error("n = ", n, " is not squarefree!")
@eprog\noindent
 % \syn{NO}

\subsec{extern$(\var{str})$}\kbdsidx{extern}\label{se:extern}
The string \var{str} is the name of an external command (i.e.~one you
would type from your UNIX shell prompt). This command is immediately run and
its output fed into \kbd{gp}, just as if read from a file.

\subsec{externstr$(\var{str})$}\kbdsidx{externstr}\label{se:externstr}
The string \var{str} is the name of an external command (i.e.~one you
would type from your UNIX shell prompt). This command is immediately run and
its output is returned as a vector of GP strings, one component per output
line.

\subsec{getabstime$()$}\kbdsidx{getabstime}\label{se:getabstime}
Returns the time (in milliseconds) elapsed since \kbd{gp} startup. This
provides a reentrant version of \kbd{gettime}:
\bprog
my (t = getabstime());
...
print("Time: ", getabstime() - t);
@eprog

The library syntax is \fun{long}{getabstime}{}.

\subsec{getenv$(s)$}\kbdsidx{getenv}\label{se:getenv}
Return the value of the environment variable \kbd{s} if it is defined, otherwise return 0.

The library syntax is \fun{GEN}{gp_getenv}{const char *s}.

\subsec{getheap$()$}\kbdsidx{getheap}\label{se:getheap}
Returns a two-component row vector giving the
number of objects on the heap and the amount of memory they occupy in long
words. Useful mainly for debugging purposes.

The library syntax is \fun{GEN}{getheap}{}.

\subsec{getrand$()$}\kbdsidx{getrand}\label{se:getrand}
Returns the current value of the seed used by the
pseudo-random number generator \tet{random}. Useful mainly for debugging
purposes, to reproduce a specific chain of computations. The returned value
is technical (reproduces an internal state array), and can only be used as an
argument to \tet{setrand}.

The library syntax is \fun{GEN}{getrand}{}.

\subsec{getstack$()$}\kbdsidx{getstack}\label{se:getstack}
Returns the current value of $\kbd{top}-\kbd{avma}$, i.e.~the number of
bytes used up to now on the stack. Useful mainly for debugging purposes.

The library syntax is \fun{long}{getstack}{}.

\subsec{gettime$()$}\kbdsidx{gettime}\label{se:gettime}
Returns the time (in milliseconds) elapsed since either the last call to
\kbd{gettime}, or to the beginning of the containing GP instruction (if
inside \kbd{gp}), whichever came last.

For a reentrant version, see \tet{getabstime}.

The library syntax is \fun{long}{gettime}{}.

\subsec{global$(\var{list} \var{of} \var{variables})$}\kbdsidx{global}\label{se:global}
Obsolete. Scheduled for deletion.
% \syn{NO}

\subsec{inline$(x,...,z)$}\kbdsidx{inline}\label{se:inline}
(Experimental) declare $x,\ldots, z$ as inline variables. Such variables
behave like lexically scoped variable (see my()) but with unlimited scope.
It is however possible to exit the scope by using \kbd{uninline()}.
When used in a GP script, it is recommended to call \kbd{uninline()} before
the script's end to avoid inline variables leaking outside the script.

\subsec{input$()$}\kbdsidx{input}\label{se:input}
Reads a string, interpreted as a GP expression,
from the input file, usually standard input (i.e.~the keyboard). If a
sequence of expressions is given, the result is the result of the last
expression of the sequence. When using this instruction, it is useful to
prompt for the string by using the \kbd{print1} function. Note that in the
present version 2.19 of \kbd{pari.el}, when using \kbd{gp} under GNU Emacs (see
\secref{se:emacs}) one \emph{must} prompt for the string, with a string
which ends with the same prompt as any of the previous ones (a \kbd{"? "}
will do for instance).

\subsec{install$(\var{name},\var{code},\{\var{gpname}\},\{\var{lib}\})$}\kbdsidx{install}\label{se:install}
Loads from dynamic library \var{lib} the function \var{name}. Assigns to it
the name \var{gpname} in this \kbd{gp} session, with \emph{prototype}
\var{code} (see below). If \var{gpname} is omitted, uses \var{name}.
If \var{lib} is omitted, all symbols known to \kbd{gp} are available: this
includes the whole of \kbd{libpari.so} and possibly others (such as
\kbd{libc.so}).

Most importantly, \kbd{install} gives you access to all non-static functions
defined in the PARI library. For instance, the function \kbd{GEN addii(GEN
x, GEN y)} adds two PARI integers, and is not directly accessible under
\kbd{gp} (it is eventually called by the \kbd{+} operator of course):
\bprog
? install("addii", "GG")
? addii(1, 2)
%1 = 3
@eprog\noindent
It also allows to add external functions to the \kbd{gp} interpreter.
For instance, it makes the function \tet{system} obsolete:
\bprog
? install(system, vs, sys,/*omitted*/)
? sys("ls gp*")
gp.c            gp.h            gp_rl.c
@eprog\noindent This works because \kbd{system} is part of \kbd{libc.so},
which is linked to \kbd{gp}. It is also possible to compile a shared library
yourself and provide it to gp in this way: use \kbd{gp2c}, or do it manually
(see the \kbd{modules\_build} variable in \kbd{pari.cfg} for hints).

Re-installing a function will print a warning and update the prototype code
if needed. However, it will not reload a symbol from the library, even if the
latter has been recompiled.

\misctitle{Prototype} We only give a simplified description here, covering
most functions, but there are many more possibilities. The full documentation
is available in \kbd{libpari.dvi}, see
\bprog
  ??prototype
@eprog

\item First character \kbd{i}, \kbd{l}, \kbd{v} : return type int / long /
void. (Default: \kbd{GEN})

\item One letter for each mandatory argument, in the same order as they appear
in the argument list: \kbd{G} (\kbd{GEN}), \kbd{\&}
(\kbd{GEN*}), \kbd{L} (\kbd{long}), \kbd{s} (\kbd{char *}), \kbd{n}
(variable).

 \item \kbd{p} to supply \kbd{realprecision} (usually \kbd{long prec} in the
 argument list), \kbd{P} to supply \kbd{seriesprecision} (usually \kbd{long
 precdl}).

 \noindent We also have special constructs for optional arguments and default
 values:

 \item \kbd{DG} (optional \kbd{GEN}, \kbd{NULL} if omitted),

 \item \kbd{D\&} (optional \kbd{GEN*}, \kbd{NULL} if omitted),

 \item \kbd{Dn} (optional variable, $-1$ if omitted),

For instance the prototype corresponding to
\bprog
  long issquareall(GEN x, GEN *n = NULL)
@eprog\noindent is \kbd{lGD\&}.

\misctitle{Caution} This function may not work on all systems, especially
when \kbd{gp} has been compiled statically. In that case, the first use of an
installed function will provoke a Segmentation Fault (this should never
happen with a dynamically linked executable). If you intend to use this
function, please check first on some harmless example such as the one above
that it works properly on your machine.

The library syntax is \fun{void}{gpinstall}{const char *name, const char *code, const char *gpname, const char *lib}.

\subsec{kill$(\var{sym})$}\kbdsidx{kill}\label{se:kill}
Restores the symbol \kbd{sym} to its ``undefined'' status, and deletes any
help messages associated to \kbd{sym} using \kbd{addhelp}. Variable names
remain known to the interpreter and keep their former priority: you cannot
make a variable ``less important" by killing it!
\bprog
? z = y = 1; y
%1 = 1
? kill(y)
? y            \\ restored to ``undefined'' status
%2 = y
? variable()
%3 = [x, y, z] \\ but the variable name y is still known, with y > z !
@eprog\noindent
For the same reason, killing a user function (which is an ordinary
variable holding a \typ{CLOSURE}) does not remove its name from the list of
variable names.

If the symbol is associated to a variable --- user functions being an
important special case ---, one may use the \idx{quote} operator
\kbd{a = 'a} to reset variables to their starting values. However, this
will not delete a help message associated to \kbd{a}, and is also slightly
slower than \kbd{kill(a)}.
\bprog
? x = 1; addhelp(x, "foo"); x
%1 = 1
? x = 'x; x   \\ same as 'kill', except we don't delete help.
%2 = x
? ?x
foo
@eprog\noindent
On the other hand, \kbd{kill} is the only way to remove aliases and installed
functions.
\bprog
? alias(fun, sin);
? kill(fun);

? install(addii, GG);
? kill(addii);
@eprog

The library syntax is \fun{void}{kill0}{const char *sym}.

\subsec{print$(\{\var{str}\}*)$}\kbdsidx{print}\label{se:print}
Outputs its (string) arguments in raw format, ending with a newline.
%\syn{NO}

\subsec{print1$(\{\var{str}\}*)$}\kbdsidx{print1}\label{se:print1}
Outputs its (string) arguments in raw
format, without ending with a newline. Note that you can still embed newlines
within your strings, using the \b{n} notation~!
%\syn{NO}

\subsec{printf$(\var{fmt},\{x\}*)$}\kbdsidx{printf}\label{se:printf}
This function is based on the C library command of the same name.
It prints its arguments according to the format \var{fmt}, which specifies how
subsequent arguments are converted for output. The format is a
character string composed of zero or more directives:

\item ordinary characters (not \kbd{\%}), printed unchanged,

\item conversions specifications (\kbd{\%} followed by some characters)
which fetch one argument from the list and prints it according to the
specification.

More precisely, a conversion specification consists in a \kbd{\%}, one or more
optional flags (among \kbd{\#}, \kbd{0}, \kbd{-}, \kbd{+}, ` '), an optional
decimal digit string specifying a minimal field width, an optional precision
in the form of a period (`\kbd{.}') followed by a decimal digit string, and
the conversion specifier (among \kbd{d},\kbd{i}, \kbd{o}, \kbd{u},
\kbd{x},\kbd{X}, \kbd{p}, \kbd{e},\kbd{E}, \kbd{f}, \kbd{g},\kbd{G}, \kbd{s}).

\misctitle{The flag characters} The character \kbd{\%} is followed by zero or
more of the following flags:

\item \kbd{\#}: The value is converted to an ``alternate form''. For
\kbd{o} conversion (octal), a \kbd{0} is prefixed to the string. For \kbd{x}
and \kbd{X} conversions (hexa), respectively \kbd{0x} and \kbd{0X} are
prepended. For other conversions, the flag is ignored.

\item \kbd{0}: The value should be zero padded. For
\kbd{d},
\kbd{i},
\kbd{o},
\kbd{u},
\kbd{x},
\kbd{X}
\kbd{e},
\kbd{E},
\kbd{f},
\kbd{F},
\kbd{g}, and
\kbd{G} conversions, the value is padded on the left with zeros rather than
blanks. (If the \kbd{0} and \kbd{-} flags both appear, the \kbd{0} flag is
ignored.)

\item \kbd{-}: The value is left adjusted on the field boundary. (The
default is right justification.) The value is padded on the right with
blanks, rather than on the left with blanks or zeros. A \kbd{-} overrides a
\kbd{0} if both are given.

\item \kbd{` '} (a space): A blank is left before a positive number
produced by a signed conversion.

\item \kbd{+}: A sign (+ or -) is placed before a number produced by a
signed conversion. A \kbd{+} overrides a space if both are used.

\misctitle{The field width} An optional decimal digit string (whose first
digit is non-zero) specifying a \emph{minimum} field width. If the value has
fewer characters than the field width, it is padded with spaces on the left
(or right, if the left-adjustment flag has been given). In no case does a
small field width cause truncation of a field; if the value is wider than
the field width, the field is expanded to contain the conversion result.
Instead of a decimal digit string, one may write \kbd{*} to specify that the
field width is given in the next argument.

\misctitle{The precision} An optional precision in the form of a period
(`\kbd{.}') followed by a decimal digit string. This gives
the number of digits to appear after the radix character for \kbd{e},
\kbd{E}, \kbd{f}, and \kbd{F} conversions, the maximum number of significant
digits for \kbd{g} and \kbd{G} conversions, and the maximum number of
characters to be printed from an \kbd{s} conversion.
Instead of a decimal digit string, one may write \kbd{*} to specify that the
field width is given in the next argument.

\misctitle{The length modifier} This is ignored under \kbd{gp}, but
necessary for \kbd{libpari} programming. Description given here for
completeness:

\item \kbd{l}: argument is a \kbd{long} integer.

\item \kbd{P}: argument is a \kbd{GEN}.

\misctitle{The conversion specifier} A character that specifies the type of
conversion to be applied.

\item \kbd{d}, \kbd{i}: A signed integer.

\item \kbd{o}, \kbd{u}, \kbd{x}, \kbd{X}: An unsigned integer, converted
to unsigned octal (\kbd{o}), decimal (\kbd{u}) or hexadecimal (\kbd{x} or
\kbd{X}) notation. The letters \kbd{abcdef} are used for \kbd{x}
conversions;  the letters \kbd{ABCDEF} are used for \kbd{X} conversions.

\item \kbd{e}, \kbd{E}: The (real) argument is converted in the style
\kbd{[ -]d.ddd e[ -]dd}, where there is one digit before the decimal point,
and the number of digits after it is equal to the precision; if the
precision is missing, use the current \kbd{realprecision} for the total
number of printed digits. If the precision is explicitly 0, no decimal-point
character appears. An \kbd{E} conversion uses the letter \kbd{E} rather
than \kbd{e} to introduce the exponent.

\item \kbd{f}, \kbd{F}: The (real) argument is converted in the style
\kbd{[ -]ddd.ddd}, where the number of digits after the decimal point
is equal to the precision; if the precision is missing, use the current
\kbd{realprecision} for the total number of printed digits. If the precision
is explicitly 0, no decimal-point character appears. If a decimal point
appears, at least one digit appears before it.

\item \kbd{g}, \kbd{G}: The (real) argument is converted in style
\kbd{e} or \kbd{f} (or \kbd{E} or \kbd{F} for \kbd{G} conversions)
\kbd{[ -]ddd.ddd}, where the total number of digits printed
is equal to the precision; if the precision is missing, use the current
\kbd{realprecision}. If the precision is explicitly 0, it is treated as 1.
Style \kbd{e} is used when
the decimal exponent is $< -4$, to print \kbd{0.}, or when the integer
part cannot be decided given the known significant digits, and the \kbd{f}
format otherwise.

\item \kbd{c}: The integer argument is converted to an unsigned char, and the
resulting character is written.

\item \kbd{s}: Convert to a character string. If a precision is given, no
more than the specified number of characters are written.

\item \kbd{p}: Print the address of the argument in hexadecimal (as if by
\kbd{\%\#x}).

\item \kbd{\%}: A \kbd{\%} is written. No argument is converted. The complete
conversion specification is \kbd{\%\%}.

\noindent Examples:

\bprog
? printf("floor: %d, field width 3: %3d, with sign: %+3d\n", Pi, 1, 2);
floor: 3, field width 3:   1, with sign:  +2

? printf("%.5g %.5g %.5g\n",123,123/456,123456789);
123.00 0.26974 1.2346 e8

? printf("%-2.5s:%2.5s:%2.5s\n", "P", "PARI", "PARIGP");
P :PARI:PARIG

\\ min field width and precision given by arguments
? x = 23; y=-1/x; printf("x=%+06.2f y=%+0*.*f\n", x, 6, 2, y);
x=+23.00 y=-00.04

\\ minimum fields width 5, pad left with zeroes
? for (i = 2, 5, printf("%05d\n", 10^i))
00100
01000
10000
100000  \\@com don't truncate fields whose length is larger than the minimum width
? printf("%.2f  |%06.2f|", Pi,Pi)
3.14  |  3.14|
@eprog\noindent All numerical conversions apply recursively to the entries
of vectors and matrices:
\bprog
? printf("%4d", [1,2,3]);
[   1,   2,   3]
? printf("%5.2f", mathilbert(3));
[ 1.00  0.50  0.33]

[ 0.50  0.33  0.25]

[ 0.33  0.25  0.20]
@eprog
\misctitle{Technical note} Our implementation of \tet{printf}
deviates from the C89 and C99 standards in a few places:

\item whenever a precision is missing, the current \kbd{realprecision} is
used to determine the number of printed digits (C89: use 6 decimals after
the radix character).

\item in conversion style \kbd{e}, we do not impose that the
exponent has at least two digits; we never write a \kbd{+} sign in the
exponent; 0 is printed in a special way, always as \kbd{0.E\var{exp}}.

\item in conversion style \kbd{f}, we switch to style \kbd{e} if the
exponent is greater or equal to the precision.

\item in conversion \kbd{g} and \kbd{G}, we do not remove trailing zeros
 from the fractional part of the result; nor a trailing decimal point;
 0 is printed in a special way, always as \kbd{0.E\var{exp}}.
%\syn{NO}

\subsec{printsep$(\var{sep},\{\var{str}\}*)$}\kbdsidx{printsep}\label{se:printsep}
Outputs its (string) arguments in raw format, ending with a newline.
Successive entries are separated by \var{sep}:
\bprog
? printsep(":", 1,2,3,4)
1:2:3:4
@eprog
%\syn{NO}

\subsec{printsep1$(\var{sep},\{\var{str}\}*)$}\kbdsidx{printsep1}\label{se:printsep1}
Outputs its (string) arguments in raw format, without ending with a
newline.  Successive entries are separated by \var{sep}:
\bprog
? printsep1(":", 1,2,3,4);print("|")
1:2:3:4
@eprog
%\syn{NO}

\subsec{printtex$(\{\var{str}\}*)$}\kbdsidx{printtex}\label{se:printtex}
Outputs its (string) arguments in \TeX\ format. This output can then be
used in a \TeX\ manuscript.
The printing is done on the standard output. If you want to print it to a
file you should use \kbd{writetex} (see there).

Another possibility is to enable the \tet{log} default
(see~\secref{se:defaults}).
You could for instance do:\sidx{logfile}
%
\bprog
default(logfile, "new.tex");
default(log, 1);
printtex(result);
@eprog
%\syn{NO}

\subsec{quit$(\{\var{status} = 0\})$}\kbdsidx{quit}\label{se:quit}
Exits \kbd{gp} and return to the system with exit status
\kbd{status}, a small integer. A non-zero exit status normally indicates
abnormal termination. (Note: the system actually sees only
\kbd{status} mod $256$, see your man pages for \kbd{exit(3)} or \kbd{wait(2)}).

\subsec{read$(\{\var{filename}\})$}\kbdsidx{read}\label{se:read}
Reads in the file
\var{filename} (subject to string expansion). If \var{filename} is
omitted, re-reads the last file that was fed into \kbd{gp}. The return
value is the result of the last expression evaluated.

If a GP \tet{binary file} is read using this command (see
\secref{se:writebin}), the file is loaded and the last object in the file
is returned.

In case the file you read in contains an \tet{allocatemem} statement (to be
generally avoided), you should leave \kbd{read} instructions by themselves,
and not part of larger instruction sequences.

\subsec{readstr$(\{\var{filename}\})$}\kbdsidx{readstr}\label{se:readstr}
Reads in the file \var{filename} and return a vector of GP strings,
each component containing one line from the file. If \var{filename} is
omitted, re-reads the last file that was fed into \kbd{gp}.

\subsec{readvec$(\{\var{filename}\})$}\kbdsidx{readvec}\label{se:readvec}
Reads in the file
\var{filename} (subject to string expansion). If \var{filename} is
omitted, re-reads the last file that was fed into \kbd{gp}. The return
value is a vector whose components are the evaluation of all sequences
of instructions contained in the file. For instance, if \var{file} contains
\bprog
1
2
3
@eprog\noindent
then we will get:
\bprog
? \r a
%1 = 1
%2 = 2
%3 = 3
? read(a)
%4 = 3
? readvec(a)
%5 = [1, 2, 3]
@eprog
In general a sequence is just a single line, but as usual braces and
\kbd{\bs} may be used to enter multiline sequences.

The library syntax is \fun{GEN}{gp_readvec_file}{const char *filename}.
The underlying library function
\fun{GEN}{gp_readvec_stream}{FILE *f} is usually more flexible.

\subsec{select$(f, A, \{\fl = 0\})$}\kbdsidx{select}\label{se:select}
We first describe the default behavior, when $\fl$ is 0 or omitted.
Given a vector or list \kbd{A} and a \typ{CLOSURE} \kbd{f}, \kbd{select}
returns the elements $x$ of \kbd{A} such that $f(x)$ is non-zero. In other
words, \kbd{f} is seen as a selection function returning a boolean value.
\bprog
? select(x->isprime(x), vector(50,i,i^2+1))
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
? select(x->(x<100), %)
%2 = [2, 5, 17, 37]
@eprog\noindent returns the primes of the form $i^2+1$ for some $i\leq 50$,
then the elements less than 100 in the preceding result. The \kbd{select}
function also applies to a matrix \kbd{A}, seen as a vector of columns, i.e. it
selects columns instead of entries, and returns the matrix whose columns are
the selected ones.

\misctitle{Remark} For $v$ a \typ{VEC}, \typ{COL}, \typ{LIST} or \typ{MAT},
the alternative set-notations
\bprog
[g(x) | x <- v, f(x)]
[x | x <- v, f(x)]
[g(x) | x <- v]
@eprog\noindent
are available as shortcuts for
\bprog
apply(g, select(f, Vec(v)))
select(f, Vec(v))
apply(g, Vec(v))
@eprog\noindent respectively:
\bprog
? [ x | x <- vector(50,i,i^2+1), isprime(x) ]
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
@eprog

\noindent If $\fl = 1$, this function returns instead the \emph{indices} of
the selected elements, and not the elements themselves (indirect selection):
\bprog
? V = vector(50,i,i^2+1);
? select(x->isprime(x), V, 1)
%2 = Vecsmall([1, 2, 4, 6, 10, 14, 16, 20, 24, 26, 36, 40])
? vecextract(V, %)
%3 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
@eprog\noindent
The following function lists the elements in $(\Z/N\Z)^*$:
\bprog
? invertibles(N) = select(x->gcd(x,N) == 1, [1..N])
@eprog

\noindent Finally
\bprog
? select(x->x, M)
@eprog\noindent selects the non-0 entries in \kbd{M}. If the latter is a
\typ{MAT}, we extract the matrix of non-0 columns. Note that \emph{removing}
entries instead of selecting them just involves replacing the selection
function \kbd{f} with its negation:
\bprog
? select(x->!isprime(x), vector(50,i,i^2+1))
@eprog

\synt{genselect}{void *E, long (*fun)(void*,GEN), GEN a}. Also available
is \fun{GEN}{genindexselect}{void *E, long (*fun)(void*, GEN), GEN a},
corresponding to $\fl = 1$.

\subsec{setrand$(n)$}\kbdsidx{setrand}\label{se:setrand}
Reseeds the random number generator using the seed $n$. No value is
returned. The seed is either a technical array output by \kbd{getrand}, or a
small positive integer, used to generate deterministically a suitable state
array. For instance, running a randomized computation starting by
\kbd{setrand(1)} twice will generate the exact same output.

The library syntax is \fun{void}{setrand}{GEN n}.

\subsec{system$(\var{str})$}\kbdsidx{system}\label{se:system}
\var{str} is a string representing a system command. This command is
executed, its output written to the standard output (this won't get into your
logfile), and control returns to the PARI system. This simply calls the C
\kbd{system} command.

\subsec{trap$(\{e\}, \{\var{rec}\}, \var{seq})$}\kbdsidx{trap}\label{se:trap}
THIS FUNCTION IS OBSOLETE: use \tet{iferr}, which has a nicer and much
more powerful interface. For compatibility's sake we now describe the
\emph{obsolete} function \tet{trap}.

This function tries to
evaluate \var{seq}, trapping runtime error $e$, that is effectively preventing
it from aborting computations in the usual way; the recovery sequence
\var{rec} is executed if the error occurs and the evaluation of \var{rec}
becomes the result of the command. If $e$ is omitted, all exceptions are
trapped. See \secref{se:errorrec} for an introduction to error recovery
under \kbd{gp}.

\bprog
? \\@com trap division by 0
? inv(x) = trap (e_INV, INFINITY, 1/x)
? inv(2)
%1 = 1/2
? inv(0)
%2 = INFINITY
@eprog\noindent
Note that \var{seq} is effectively evaluated up to the point that produced
the error, and the recovery sequence is evaluated starting from that same
context, it does not "undo" whatever happened in the other branch (restore
the evaluation context):
\bprog
? x = 1; trap (, /* recover: */ x, /* try: */ x = 0; 1/x)
%1 = 0
@eprog

\misctitle{Note} The interface is currently not adequate for trapping
individual exceptions. In the current version \vers, the following keywords
are recognized, but the name list will be expanded and changed in the
future (all library mode errors can be trapped: it's a matter of defining
the keywords to \kbd{gp}):

\kbd{e\_ALARM}: alarm time-out

\kbd{e\_ARCH}: not available on this architecture or operating system

\kbd{e\_STACK}: the PARI stack overflows

\kbd{e\_INV}: impossible inverse

\kbd{e\_IMPL}: not yet implemented

\kbd{e\_OVERFLOW}: all forms of arithmetic overflow, including length
or exponent overflow (when a larger value is supplied than the
implementation can handle).

\kbd{e\_SYNTAX}: syntax error

\kbd{e\_MISC}: miscellaneous error

\kbd{e\_TYPE}: wrong type

\kbd{e\_USER}: user error (from the \kbd{error} function)

The library syntax is \fun{GEN}{trap0}{const char *e = NULL, GEN rec = NULL, GEN seq = NULL}.

\subsec{type$(x)$}\kbdsidx{type}\label{se:type}
This is useful only under \kbd{gp}. Returns the internal type name of
the PARI object $x$ as a  string. Check out existing type names with the
metacommand \b{t}. For example \kbd{type(1)} will return "\typ{INT}".

The library syntax is \fun{GEN}{type0}{GEN x}.
The macro \kbd{typ} is usually simpler to use since it returns a
\kbd{long} that can easily be matched with the symbols \typ{*}. The name
\kbd{type} was avoided since it is a reserved identifier for some compilers.

\subsec{uninline$()$}\kbdsidx{uninline}\label{se:uninline}
(Experimental) Exit the scope of all current \kbd{inline} variables.

\subsec{version$()$}\kbdsidx{version}\label{se:version}
Returns the current version number as a \typ{VEC} with three integer
components (major version number, minor version number and patchlevel);
if your sources were obtained through our version control system, this will
be followed by further more precise arguments, including
e.g.~a~\kbd{git} \emph{commit hash}.

This function is present in all versions of PARI following releases 2.3.4
(stable) and 2.4.3 (testing).

Unless you are working with multiple development versions, you probably only
care about the 3 first numeric components. In any case, the \kbd{lex} function
offers a clever way to check against a particular version number, since it will
compare each successive vector entry, numerically or as strings, and will not
mind if the vectors it compares have different lengths:
\bprog
   if (lex(version(), [2,3,5]) >= 0,
     \\ code to be executed if we are running 2.3.5 or more recent.
   ,
     \\ compatibility code
   );
@eprog\noindent On a number of different machines, \kbd{version()} could return either of
\bprog
 %1 = [2, 3, 4]    \\ released version, stable branch
 %1 = [2, 4, 3]    \\ released version, testing branch
 %1 = [2, 6, 1, 15174, ""505ab9b"] \\ development
@eprog

In particular, if you are only working with released versions, the first
line of the gp introductory message can be emulated by
\bprog
   [M,m,p] = version();
   printf("GP/PARI CALCULATOR Version %s.%s.%s", M,m,p);
 @eprog\noindent If you \emph{are} working with many development versions of
 PARI/GP, the 4th and/or 5th components can be profitably included in the
 name of your logfiles, for instance.

 \misctitle{Technical note} For development versions obtained via \kbd{git},
 the 4th and 5th components are liable to change eventually, but we document
 their current meaning for completeness. The 4th component counts the number
 of reachable commits in the branch (analogous to \kbd{svn}'s revision
 number), and the 5th is the \kbd{git} commit hash. In particular, \kbd{lex}
 comparison still orders correctly development versions with respect to each
 others or to released versions (provided we stay within a given branch,
 e.g. \kbd{master})!

The library syntax is \fun{GEN}{pari_version}{}.

\subsec{warning$(\{\var{str}\}*)$}\kbdsidx{warning}\label{se:warning}
Outputs the message ``user warning''
and the argument list (each of them interpreted as a string).
If colors are enabled, this warning will be in a different color,
making it easy to distinguish.
\bprog
warning(n, " is very large, this might take a while.")
@eprog
% \syn{NO}

\subsec{whatnow$(\var{key})$}\kbdsidx{whatnow}\label{se:whatnow}
If keyword \var{key} is the name of a function that was present in GP
version 1.39.15 or lower, outputs the new function name and syntax, if it
changed at all ($387$ out of $560$ did).

\subsec{write$(\var{filename},\{\var{str}\}*)$}\kbdsidx{write}\label{se:write}
Writes (appends) to \var{filename} the remaining arguments, and appends a
newline (same output as \kbd{print}).
%\syn{NO}

\subsec{write1$(\var{filename},\{\var{str}\}*)$}\kbdsidx{write1}\label{se:write1}
Writes (appends) to \var{filename} the remaining arguments without a
trailing newline (same output as \kbd{print1}).
%\syn{NO}

\subsec{writebin$(\var{filename},\{x\})$}\kbdsidx{writebin}\label{se:writebin}
Writes (appends) to
\var{filename} the object $x$ in binary format. This format is not human
readable, but contains the exact internal structure of $x$, and is much
faster to save/load than a string expression, as would be produced by
\tet{write}. The binary file format includes a magic number, so that such a
file can be recognized and correctly input by the regular \tet{read} or \b{r}
function. If saved objects refer to (polynomial) variables that are not
defined in the new session, they will be displayed in a funny way (see
\secref{se:kill}). Installed functions and history objects can not be saved
via this function.

If $x$ is omitted, saves all user variables from the session, together with
their names. Reading such a ``named object'' back in a \kbd{gp} session will set
the corresponding user variable to the saved value. E.g after
\bprog
x = 1; writebin("log")
@eprog\noindent
reading \kbd{log} into a clean session will set \kbd{x} to $1$.
The relative variables priorities (see \secref{se:priority}) of new variables
set in this way remain the same (preset variables retain their former
priority, but are set to the new value). In particular, reading such a
session log into a clean session will restore all variables exactly as they
were in the original one.

Just as a regular input file, a binary file can be compressed
using \tet{gzip}, provided the file name has the standard \kbd{.gz}
extension.\sidx{binary file}

In the present implementation, the binary files are architecture dependent
and compatibility with future versions of \kbd{gp} is not guaranteed. Hence
binary files should not be used for long term storage (also, they are
larger and harder to compress than text files).

The library syntax is \fun{void}{gpwritebin}{const char *filename, GEN x = NULL}.

\subsec{writetex$(\var{filename},\{\var{str}\}*)$}\kbdsidx{writetex}\label{se:writetex}
As \kbd{write}, in \TeX\ format.
%\syn{NO}
%SECTION: programming/specific

\section{Parallel programming}

These function are only available if PARI was configured using \kbd{Configure
--mt=\dots}. Two multithread interfaces are supported:

\item POSIX threads

\item Message passing interface (MPI)

As a rule, POSIX threads are well-suited for single systems, while MPI is used
by most clusters. However the parallel GP interface does not depend on the
chosen multithread interface: a properly written GP program will work
identically with both.


\subsec{parapply$(f, x)$}\kbdsidx{parapply}\label{se:parapply}
Parallel evaluation of \kbd{f} on the elements of \kbd{x}.
The function \kbd{f} must not access global variables or variables
declared with local(), and must be free of side effects.
\bprog
parapply(factor,[2^256 + 1, 2^193 - 1])
@eprog
factors $2^{256} + 1$ and $2^{193} - 1$ in parallel.
\bprog
{
  my(E = ellinit([1,3]), V = vector(12,i,randomprime(2^200)));
  parapply(p->ellcard(E,p), V)
}
@eprog
computes the order of $E(\F_p)$ for $12$ random primes of $200$ bits.

The library syntax is \fun{GEN}{parapply}{GEN f, GEN x}.

\subsec{pareval$(x)$}\kbdsidx{pareval}\label{se:pareval}
Parallel evaluation of the elements of \kbd{x}, where \kbd{x} is a
vector of closures. The closures must be of arity $0$, must not access
global variables or variables declared with \kbd{local} and must be
free of side effects.

The library syntax is \fun{GEN}{pareval}{GEN x}.

\subsec{parfor$(i=a,\{b\},\var{expr1},\{j\},\{\var{expr2}\})$}\kbdsidx{parfor}\label{se:parfor}
Evaluates the sequence \kbd{expr2} (dependent on $i$ and $j$) for $i$
between $a$ and $b$, in random order, computed in parallel; in this sequence
\kbd{expr2}, substitute the variable $j$ by the value of \kbd{expr1}
(dependent on $i$). If $b$ is omitted, the loop will not stop.

It is allowed for \kbd{expr2} to exit the loop using
\kbd{break}/\kbd{next}/\kbd{return}; however in that case, \kbd{expr2} will
still be evaluated for all remaining value of $i$ less than the current one,
unless a subsequent \kbd{break}/\kbd{next}/\kbd{return} happens.
%\syn{NO}

\subsec{parforprime$(p=a,\{b\},\var{expr1},\{j\},\{\var{expr2}\})$}\kbdsidx{parforprime}\label{se:parforprime}
Evaluates the sequence \kbd{expr2} (dependent on $p$ and $j$) for $p$
prime between $a$ and $b$, in random order, computed in parallel. Substitute
for $j$ the value of \kbd{expr1} (dependent on $p$).
If $b$ is omitted, the loop will not stop.

It is allowed fo \kbd{expr2} to exit the loop using
\kbd{break}/\kbd{next}/\kbd{return}, however in that case, \kbd{expr2} will
still be evaluated for all remaining value of $p$ less than the current one,
unless a subsequent \kbd{break}/\kbd{next}/\kbd{return} happens.
%\syn{NO}

\subsec{parselect$(f, A, \{\fl = 0\})$}\kbdsidx{parselect}\label{se:parselect}
Selects elements of $A$ according to the selection function $f$, done in
parallel.  If \fl is $1$, return the indices of those elements (indirect
selection) The function \kbd{f} must not access global variables or
variables declared with local(), and must be free of side effects.

The library syntax is \fun{GEN}{parselect}{GEN f, GEN A, long flag }.

\subsec{parsum$(i=a,b,\var{expr},\{x\})$}\kbdsidx{parsum}\label{se:parsum}
Sum of expression \var{expr}, initialized at $x$, the formal parameter
going from $a$ to $b$, evaluated in parallel in random order.
The expression \kbd{expr} must not access global variables or
variables declared with \kbd{local()}, and must be free of side effects.
\bprog
parsum(i=1,1000,ispseudoprime(2^prime(i)-1))
@eprog
returns the numbers of prime numbers among the first $1000$ Mersenne numbers.
%\syn{NO}

\subsec{parvector$(N,i,\var{expr})$}\kbdsidx{parvector}\label{se:parvector}
As \kbd{vector(N,i,expr)} but the evaluations of \kbd{expr} are done in
parallel. The expression \kbd{expr} must not access global variables or
variables declared with \kbd{local()}, and must be free of side effects.
\bprog
parvector(10,i,quadclassunit(2^(100+i)+1).no)
@eprog\noindent
computes the class numbers in parallel.
%\syn{NO}
%SECTION: programming/parallel

\section{GP defaults}
\label{se:gp_defaults} This section documents the GP defaults


\subsec{TeXstyle}\kbdsidx{TeXstyle}\label{se:def,TeXstyle}
The bits of this default allow
\kbd{gp} to use less rigid TeX formatting commands in the logfile. This
default is only taken into account when $\kbd{log} = 3$. The bits of
\kbd{TeXstyle} have the following meaning

2: insert \kbd{\bs right} / \kbd{\bs left} pairs where appropriate.

4: insert discretionary breaks in polynomials, to enhance the probability of
a good line break.

The default value is \kbd{0}.

\subsec{breakloop}\kbdsidx{breakloop}\label{se:def,breakloop}
If true, enables the ``break loop'' debugging mode, see
\secref{se:break_loop}.

The default value is \kbd{1} if we are running an interactive \kbd{gp}
session, and \kbd{0} otherwise.

\subsec{colors}\kbdsidx{colors}\label{se:def,colors}
This default is only usable if \kbd{gp}
is running within certain color-capable terminals. For instance \kbd{rxvt},
\kbd{color\_xterm} and modern versions of \kbd{xterm} under X Windows, or
standard Linux/DOS text consoles. It causes \kbd{gp} to use a small palette of
colors for its output. With xterms, the colormap used corresponds to the
resources \kbd{Xterm*color$n$} where $n$ ranges from $0$ to $15$ (see the
file \kbd{misc/color.dft} for an example). Accepted values for this
default are strings \kbd{"$a_1$,\dots,$a_k$"} where $k\le7$ and each
$a_i$ is either

\noindent\item the keyword \kbd{no} (use the default color, usually
black on transparent background)

\noindent\item an integer between 0 and 15 corresponding to the
aforementioned colormap

\noindent\item a triple $[c_0,c_1,c_2]$ where $c_0$ stands for foreground
color, $c_1$ for background color, and $c_2$ for attributes (0 is default, 1
is bold, 4 is underline).

The output objects thus affected are respectively error messages,
history numbers, prompt, input line, output, help messages, timer (that's
seven of them). If $k < 7$, the remaining $a_i$ are assumed to be $no$. For
instance
%
\bprog
default(colors, "9, 5, no, no, 4")
@eprog
\noindent
typesets error messages in color $9$, history numbers in color $5$, output in
color $4$, and does not affect the rest.

A set of default colors for dark (reverse video or PC console) and light
backgrounds respectively is activated when \kbd{colors} is set to
\kbd{darkbg}, resp.~\kbd{lightbg} (or any proper prefix: \kbd{d} is
recognized as an abbreviation for \kbd{darkbg}). A bold variant of
\kbd{darkbg}, called \kbd{boldfg}, is provided if you find the former too
pale.

\emacs In the present version, this default is incompatible with PariEmacs.
Changing it will just fail silently (the alternative would be to display
escape sequences as is, since Emacs will refuse to interpret them).
You must customize color highlighting from the PariEmacs side, see its
documentation.

The default value is \kbd{""} (no colors).

\subsec{compatible}\kbdsidx{compatible}\label{se:def,compatible}
The GP function names and syntax
have changed tremendously between versions 1.xx and 2.00. To help you cope
with this we provide some kind of backward compatibility, depending on the
value of this default:

\quad \kbd{compatible} = 0: no backward compatibility. In this mode, a very
handy function, to be described in \secref{se:whatnow}, is \kbd{whatnow},
which tells you what has become of your favorite functions, which \kbd{gp}
suddenly can't seem to remember.

\quad \kbd{compatible} = 1: warn when using obsolete functions, but
otherwise accept them. The output uses the new conventions though, and
there may be subtle incompatibilities between the behavior of former and
current functions, even when they share the same name (the current function
is used in such cases, of course!). We thought of this one as a transitory
help for \kbd{gp} old-timers. Thus, to encourage switching to \kbd{compatible}=0,
it is not possible to disable the warning.

\quad \kbd{compatible} = 2: use only the old function naming scheme (as
used up to version 1.39.15), but \emph{taking case into account}. Thus
\kbd{I} (${}=\sqrt{-1}$) is not the same as \kbd{i} (user variable, unbound
by default), and you won't get an error message using \kbd{i} as a loop
index as used to be the case.

\quad \kbd{compatible} = 3: try to mimic exactly the former behavior. This
is not always possible when functions have changed in a fundamental way.
But these differences are usually for the better (they were meant to,
anyway), and will probably not be discovered by the casual user.

One adverse side effect is that any user functions and aliases that have
been defined \emph{before} changing \kbd{compatible} will get erased if this
change modifies the function list, i.e.~if you move between groups
$\{0,1\}$ and $\{2,3\}$ (variables are unaffected). We of course strongly
encourage you to try and get used to the setting \kbd{compatible}=0.

Note that the default \tet{new_galois_format} is another compatibility setting,
which is completely independent of \kbd{compatible}.

The default value is \kbd{0}.

\subsec{datadir}\kbdsidx{datadir}\label{se:def,datadir}
The name of directory containing the optional data files. For now,
this includes the \kbd{elldata}, \kbd{galdata}, \kbd{galpol}, \kbd{seadata}
packages.

The default value is \datadir (the location of installed precomputed data,
can be specified via \kbd{Configure --datadir=}).

\subsec{debug}\kbdsidx{debug}\label{se:def,debug}
Debugging level. If it is non-zero, some extra messages may be printed,
according to what is going on (see~\b{g}).

The default value is \kbd{0} (no debugging messages).

\subsec{debugfiles}\kbdsidx{debugfiles}\label{se:def,debugfiles}
File usage debugging level. If it is non-zero, \kbd{gp} will print
information on file descriptors in use, from PARI's point of view
(see~\b{gf}).

The default value is \kbd{0} (no debugging messages).

\subsec{debugmem}\kbdsidx{debugmem}\label{se:def,debugmem}
Memory debugging level. If it is non-zero, \kbd{gp} will regularly print
information on memory usage. If it's greater than 2, it will indicate any
important garbage collecting and the function it is taking place in
(see~\b{gm}).

\noindent {\bf Important Note:} As it noticeably slows down the performance,
the first functionality (memory usage) is disabled if you're not running a
version compiled for debugging (see Appendix~A).

The default value is \kbd{0} (no debugging messages).

\subsec{echo}\kbdsidx{echo}\label{se:def,echo}
This toggle is either 1 (on) or 0 (off). When \kbd{echo}
mode is on, each command is reprinted before being executed. This can be
useful when reading a file with the \b{r} or \kbd{read} commands. For
example, it is turned on at the beginning of the test files used to check
whether \kbd{gp} has been built correctly (see \b{e}).

The default value is \kbd{0} (no echo).

\subsec{factor\_add\_primes}\kbdsidx{def,factor_add_primes}\label{se:def,factor_add_primes}
This toggle is either 1 (on) or 0 (off). If on,
the integer factorization machinery calls \tet{addprimes} on primes
factor that were difficult to find (larger than $2^24$), so they are
automatically tried first in other factorizations. If a routine is performing
(or has performed) a factorization and is interrupted by an error or via
Control-C, this lets you recover the prime factors already found. The
downside is that a huge \kbd{addprimes} table unrelated to the current
computations will slow down arithmetic functions relying on integer
factorization; one should then empty the table using \tet{removeprimes}.

The default value is \kbd{0}.

\subsec{factor\_proven}\kbdsidx{def,factor_proven}\label{se:def,factor_proven}
This toggle is either 1 (on) or 0 (off). By
default, the factors output by the integer factorization machinery are
only pseudo-primes, not proven primes. If this toggle is
set, a primality proof is done for each factor and all results depending on
integer factorization are fully proven. This flag does not affect partial
factorization when it is explicitly requested. It also does not affect the
private table managed by \tet{addprimes}: its entries are included as is in
factorizations, without being tested for primality.

The default value is \kbd{0}.

\subsec{format}\kbdsidx{format}\label{se:def,format}
Of the form x$.n$, where x (conversion style)
is a letter in $\{\kbd{e},\kbd{f},\kbd{g}\}$, and $n$ (precision) is an
integer; this affects the way real numbers are printed:

\item If the conversion style is \kbd{e}, real numbers are printed in
\idx{scientific format}, always with an explicit exponent,
e.g.~\kbd{3.3 E-5}.

\item In style \kbd{f}, real numbers are generally printed in \idx{fixed
floating point format} without exponent, e.g.~\kbd{0.000033}. A large
real number, whose integer part is not well defined (not enough significant
digits), is printed in style~\kbd{e}. For instance \kbd{10.\pow 100} known to
ten significant digits is always printed in style \kbd{e}.

\item In style \kbd{g}, non-zero real numbers are printed in \kbd{f} format,
except when their decimal exponent is $< -4$, in which case they are printed in
\kbd{e} format. Real zeroes (of arbitrary exponent) are printed in \kbd{e}
format.

The precision $n$ is the number of significant digits printed for real
numbers, except if $n<0$ where all the significant digits will be printed
(initial default 28, or 38 for 64-bit machines). For more powerful formatting
possibilities, see \tet{printf} and \tet{Strprintf}.

The default value is \kbd{"g.28"} and \kbd{"g.38"} on 32-bit and
64-bit machines, respectively.

\subsec{graphcolormap}\kbdsidx{graphcolormap}\label{se:def,graphcolormap}
A vector of colors, to be
used by hi-res graphing routines. Its length is arbitrary, but it must
contain at least 3 entries: the first 3 colors are used for background,
frame/ticks and axes respectively. All colors in the colormap may be freely
used in \tet{plotcolor} calls.

A color is either given as in the default by character strings or by an RGB
code. For valid character strings, see the standard \kbd{rgb.txt} file in X11
distributions, where we restrict to lowercase letters and remove all
whitespace from color names. An RGB code is a vector with 3 integer entries
between 0 and 255. For instance \kbd{[250, 235, 215]} and
\kbd{"antiquewhite"} represent the same color. RGB codes are cryptic but
often easier to generate.

The default value is [\kbd{"white"}, \kbd{"black"}, \kbd{"blue"},
\kbd{"violetred"}, \kbd{"red"}, \kbd{"green"}, \kbd{"grey"},
\kbd{"gainsboro"}].

\subsec{graphcolors}\kbdsidx{graphcolors}\label{se:def,graphcolors}
Entries in the
\tet{graphcolormap} that will be used to plot multi-curves. The successive
curves are drawn in colors

\kbd{graphcolormap[graphcolors[1]]}, \kbd{graphcolormap[graphcolors[2]]},
  \dots

cycling when the \kbd{graphcolors} list is exhausted.

The default value is \kbd{[4,5]}.

\subsec{help}\kbdsidx{help}\label{se:def,help}
Name of the external help program to use from within \kbd{gp} when
extended help is invoked, usually through a \kbd{??} or \kbd{???} request
(see \secref{se:exthelp}), or \kbd{M-H} under readline (see
\secref{se:readline}).

The default value is the path to the \kbd{gphelp} script we install.

\subsec{histfile}\kbdsidx{histfile}\label{se:def,histfile}
Name of a file where
\kbd{gp} will keep a history of all \emph{input} commands (results are
omitted). If this file exists when the value of \kbd{histfile} changes,
it is read in and becomes part of the session history. Thus, setting this
default in your gprc saves your readline history between sessions. Setting
this default to the empty string \kbd{""} changes it to
\kbd{$<$undefined$>$}

The default value is \kbd{$<$undefined$>$} (no history file).

\subsec{histsize}\kbdsidx{histsize}\label{se:def,histsize}
\kbd{gp} keeps a history of the last
\kbd{histsize} results computed so far, which you can recover using the
\kbd{\%} notation (see \secref{se:history}). When this number is exceeded,
the oldest values are erased. Tampering with this default is the only way to
get rid of the ones you do not need anymore.

The default value is \kbd{5000}.

\subsec{lines}\kbdsidx{lines}\label{se:def,lines}
If set to a positive value, \kbd{gp} prints at
most that many lines from each result, terminating the last line shown with
\kbd{[+++]} if further material has been suppressed. The various \kbd{print}
commands (see \secref{se:gp_program}) are unaffected, so you can always type
\kbd{print(\%)} or \b{a} to view the full result. If the actual screen width
cannot be determined, a ``line'' is assumed to be 80 characters long.

The default value is \kbd{0}.

\subsec{linewrap}\kbdsidx{linewrap}\label{se:def,linewrap}
If set to a positive value, \kbd{gp} wraps every single line after
printing that many characters.

The default value is \kbd{0} (unset).

\subsec{log}\kbdsidx{log}\label{se:def,log}
This can be either 0 (off) or 1, 2, 3
(on, see below for the various modes). When logging mode is turned on, \kbd{gp}
opens a log file, whose exact name is determined by the \kbd{logfile}
default. Subsequently, all the commands and results will be written to that
file (see \b{l}). In case a file with this precise name already existed, it
will not be erased: your data will be \emph{appended} at the end.

The specific positive values of \kbd{log} have the following meaning

1: plain logfile

2: emit color codes to the logfile (if \kbd{colors} is set).

3: write LaTeX output to the logfile (can be further customized using
\tet{TeXstyle}).

The default value is \kbd{0}.

\subsec{logfile}\kbdsidx{logfile}\label{se:def,logfile}
Name of the log file to be used when the \kbd{log} toggle is on.
Environment and time expansion are performed.

The default value is \kbd{"pari.log"}.

\subsec{nbthreads}\kbdsidx{nbthreads}\label{se:def,nbthreads}
Number of threads to use for parallel computing.
The exact meaning an default depend on the \kbd{mt} engine used:

\item \kbd{single}: not used (always one thread).

\item \kbd{pthread}: number of threads (unlimited, default: number of core)

\item \kbd{mpi}: number of MPI process to use (limited to the number allocated by \kbd{mpirun},
default: use all allocated process).

\subsec{new\_galois\_format}\kbdsidx{def,new_galois_format}\label{se:def,new_galois_format}
This toggle is either 1 (on) or 0 (off). If on,
the \tet{polgalois} command will use a different, more
consistent, naming scheme for Galois groups. This default is provided to
ensure that scripts can control this behavior and do not break unexpectedly.

The default value is \kbd{0}. This value will change to $1$ (set) in the next
major version.

\subsec{output}\kbdsidx{output}\label{se:def,output}
There are three possible values: 0
(=~\var{raw}), 1 (=~\var{prettymatrix}), or 3
(=~\var{external} \var{prettyprint}). This
means that, independently of the default \kbd{format} for reals which we
explained above, you can print results in three ways:

\item \tev{raw format}, i.e.~a format which is equivalent to what you
input, including explicit multiplication signs, and everything typed on a
line instead of two dimensional boxes. This can have several advantages, for
instance it allows you to pick the result with a mouse or an editor, and to
paste it somewhere else.

\item \tev{prettymatrix format}: this is identical to raw format, except
that matrices are printed as boxes instead of horizontally. This is
prettier, but takes more space and cannot be used for input. Column vectors
are still printed horizontally.

\item \tev{external prettyprint}: pipes all \kbd{gp}
output in TeX format to an external prettyprinter, according to the value of
\tet{prettyprinter}. The default script (\tet{tex2mail}) converts its input
to readable two-dimensional text.

Independently of the setting of this default, an object can be printed
in any of the three formats at any time using the commands \b{a} and \b{m}
and \b{B} respectively.

The default value is \kbd{1} (\var{prettymatrix}).

\subsec{parisize}\kbdsidx{parisize}\label{se:def,parisize}
\kbd{gp}, and in fact any program using the PARI
library, needs a \tev{stack} in which to do its computations. \kbd{parisize}
is the stack size, in bytes. It is strongly recommended you increase this
default (using the \kbd{-s} command-line switch, or a \tet{gprc}) if you can
afford it. Don't increase it beyond the actual amount of RAM installed on
your computer or \kbd{gp} will spend most of its time paging.

In case of emergency, you can use the \tet{allocatemem} function to
increase \kbd{parisize}, once the session is started.

The default value is 4M, resp.~8M on a 32-bit, resp.~64-bit machine.

\subsec{path}\kbdsidx{path}\label{se:def,path}
This is a list of directories, separated by colons ':'
(semicolons ';' in the DOS world, since colons are preempted for drive names).
When asked to read a file whose name is not given by an absolute path
(does not start with \kbd{/}, \kbd{./} or \kbd{../}), \kbd{gp} will look for
it in these directories, in the order they were written in \kbd{path}. Here,
as usual, \kbd{.} means the current directory, and \kbd{..} its immediate
parent. Environment expansion is performed.

The default value is \kbd{".:\til:\til/gp"} on UNIX systems,
\kbd{".;C:\bs;C:\bs GP"} on DOS, OS/2 and Windows, and \kbd{"."} otherwise.

\subsec{prettyprinter}\kbdsidx{prettyprinter}\label{se:def,prettyprinter}
The name of an external prettyprinter to use when
\kbd{output} is~3 (alternate prettyprinter). Note that the default
\tet{tex2mail} looks much nicer than the built-in ``beautified
format'' ($\kbd{output} = 2$).

The default value is \kbd{"tex2mail -TeX -noindent -ragged -by\_par"}.

\subsec{primelimit}\kbdsidx{primelimit}\label{se:def,primelimit}
\kbd{gp} precomputes a list of
all primes less than \kbd{primelimit} at initialization time, and can build
fast sieves on demand to quickly iterate over primes up to the \emph{square}
of \kbd{primelimit}. These are used by many arithmetic functions, usually for
trial division purposes. The maximal value is $2^{32} - 2049$ (resp $2^{64} -
2049$) on a 32-bit (resp.~64-bit) machine, but values beyond $10^8$,
allowing to iterate over primes up to $10^{16}$, do not seem useful.

Since almost all arithmetic functions eventually require some table of prime
numbers, PARI guarantees that the first 6547 primes, up to and
including 65557, are precomputed, even if \kbd{primelimit} is $1$.

This default is only used on startup: changing it will not recompute a new
table.

\misctitle{Deprecated feature} \kbd{primelimit} was used in some
situations by algebraic number theory functions using the
\tet{nf_PARTIALFACT} flag (\tet{nfbasis}, \tet{nfdisc}, \tet{nfinit}, \dots):
this assumes that all primes $p > \kbd{primelimit}$ have a certain
property (the equation order is $p$-maximal). This is never done by default,
and must be explicitly set by the user of such functions. Nevertheless,
these functions now provide a more flexible interface, and their use
of the global default \kbd{primelimit} is deprecated.

\misctitle{Deprecated feature} \kbd{factor(N, 0)} was used to partially
factor integers by removing all prime factors $\leq$ \kbd{primelimit}.
Don't use this, supply an explicit bound: \kbd{factor(N, bound)},
which avoids relying on an unpredictable global variable.

The default value is \kbd{500k}.

\subsec{prompt}\kbdsidx{prompt}\label{se:def,prompt}
A string that will be printed as
prompt. Note that most usual escape sequences are available there: \b{e} for
Esc, \b{n} for Newline, \dots, \kbd{\bs\bs} for \kbd{\bs}. Time expansion is
performed.

This string is sent through the library function \tet{strftime} (on a
Unix system, you can try \kbd{man strftime} at your shell prompt). This means
that \kbd{\%} constructs have a special meaning, usually related to the time
and date. For instance, \kbd{\%H} = hour (24-hour clock) and \kbd{\%M} =
minute [00,59] (use \kbd{\%\%} to get a real \kbd{\%}).

If you use \kbd{readline}, escape sequences in your prompt will result in
display bugs. If you have a relatively recent \kbd{readline} (see the comment
at the end of \secref{se:def,colors}), you can brace them with special sequences
(\kbd{\bs[} and \kbd{\bs]}), and you will be safe. If these just result in
extra spaces in your prompt, then you'll have to get a more recent
\kbd{readline}. See the file \kbd{misc/gprc.dft} for an example.

\emacs {\bf Caution}: PariEmacs needs to know about the prompt pattern to
separate your input from previous \kbd{gp} results, without ambiguity. It is
not a trivial problem to adapt automatically this regular expression to an
arbitrary prompt (which can be self-modifying!). See PariEmacs's
documentation.

The default value is \kbd{"? "}.

\subsec{prompt\_cont}\kbdsidx{def,prompt_cont}\label{se:def,prompt_cont}
A string that will be printed
to prompt for continuation lines (e.g. in between braces, or after a
line-terminating backslash). Everything that applies to \kbd{prompt}
applies to \kbd{prompt\_cont} as well.

The default value is \kbd{""}.

\subsec{psfile}\kbdsidx{psfile}\label{se:def,psfile}
Name of the default file where
\kbd{gp} is to dump its PostScript drawings (these are appended, so that no
previous data are lost). Environment and time expansion are performed.

The default value is \kbd{"pari.ps"}.

\subsec{readline}\kbdsidx{readline}\label{se:def,readline}
Switches readline line-editing
facilities on and off. This may be useful if you are running \kbd{gp} in a Sun
\tet{cmdtool}, which interacts badly with readline. Of course, until readline
is switched on again, advanced editing features like automatic completion
and editing history are not available.

The default value is \kbd{1}.

\subsec{realprecision}\kbdsidx{realprecision}\label{se:def,realprecision}
The number of significant digits used to convert exact inputs given to
transcendental functions (see \secref{se:trans}), or to create
absolute floating point constants (input as \kbd{1.0} or \kbd{Pi} for
instance). Unless you tamper with the \tet{format} default, this is also
the number of significant digits used to print a \typ{REAL} number;
\kbd{format} will override this latter behaviour, and allow you to have a
large internal precision while outputting few digits for instance.

Note that PARI's internal precision works on a word basis (by increments of
32 or 64 bits), hence may be a little larger than the number of decimal
digits you expected. For instance to get 2 decimal digits you need one word
of precision which, on a 64-bit machine, actually gives you 19 digits ($19 <
\log_{10}(2^{64}) < 20$). The value returned when typing
\kbd{default(realprecision)} is the internal number of significant digits,
not the number of printed digits:
\bprog
? default(realprecision, 2)
      realprecision = 19 significant digits (2 digits displayed)
? default(realprecision)
%1 = 19
@eprog
The default value is \kbd{38}, resp.~\kbd{28}, on a 64-bit, resp~.32-bit,
machine.

\subsec{recover}\kbdsidx{recover}\label{se:def,recover}
This toggle is either 1 (on) or 0 (off). If you change this to $0$, any
error becomes fatal and causes the gp interpreter to exit immediately. Can be
useful in batch job scripts.

The default value is \kbd{1}.

\subsec{secure}\kbdsidx{secure}\label{se:def,secure}
This toggle is either 1 (on) or 0 (off). If on, the \tet{system} and
\tet{extern} command are disabled. These two commands are potentially
dangerous when you execute foreign scripts since they let \kbd{gp} execute
arbitrary UNIX commands. \kbd{gp} will ask for confirmation before letting
you (or a script) unset this toggle.

The default value is \kbd{0}.

\subsec{seriesprecision}\kbdsidx{seriesprecision}\label{se:def,seriesprecision}
Number of significant terms
when converting a polynomial or rational function to a power series
(see~\b{ps}).

The default value is \kbd{16}.

\subsec{simplify}\kbdsidx{simplify}\label{se:def,simplify}
This toggle is either 1 (on) or 0 (off). When the PARI library computes
something, the type of the
result is not always the simplest possible. The only type conversions which
the PARI library does automatically are rational numbers to integers (when
they are of type \typ{FRAC} and equal to integers), and similarly rational
functions to polynomials (when they are of type \typ{RFRAC} and equal to
polynomials). This feature is useful in many cases, and saves time, but can
be annoying at times. Hence you can disable this and, whenever you feel like
it, use the function \kbd{simplify} (see Chapter 3) which allows you to
simplify objects to the simplest possible types recursively (see~\b{y}).
\sidx{automatic simplification}

The default value is \kbd{1}.

\subsec{sopath}\kbdsidx{sopath}\label{se:def,sopath}
This is a list of directories, separated by colons ':'
(semicolons ';' in the DOS world, since colons are preempted for drive names).
When asked to \tet{install} an external symbol from a shared library whose
name is not given by an absolute path (does not start with \kbd{/}, \kbd{./}
or \kbd{../}), \kbd{gp} will look for it in these directories, in the order
they were written in \kbd{sopath}. Here, as usual, \kbd{.} means the current
directory, and \kbd{..} its immediate parent. Environment expansion is
performed.

The default value is \kbd{""}, corresponding to an empty list of
directories: \tet{install} will use the library name as input (and look in
the current directory if the name is not an absolute path).

\subsec{strictargs}\kbdsidx{strictargs}\label{se:def,strictargs}
This toggle is either 1 (on) or 0 (off). If on, all arguments to \emph{new}
user functions are mandatory unless the function supplies an explicit default
value.
Otherwise arguments have the default value $0$.

In this example,
\bprog
  fun(a,b=2)=a+b
@eprog
\kbd{a} is mandatory, while \kbd{b} is optional. If \kbd{strictargs} is on:
\bprog
? fun()
 ***   at top-level: fun()
 ***                 ^-----
 ***   in function fun: a,b=2
 ***                    ^-----
 ***   missing mandatory argument 'a' in user function.
@eprog
This applies to functions defined while \kbd{strictargs} is on. Changing \kbd{strictargs}
does not affect the behavior of previously defined functions.

The default value is \kbd{0}.

\subsec{strictmatch}\kbdsidx{strictmatch}\label{se:def,strictmatch}
This toggle is either 1 (on) or 0 (off). If on, unused characters after a
sequence has been
processed will produce an error. Otherwise just a warning is printed. This
can be useful when you are unsure how many parentheses you have to close
after complicated nested loops. Please do not use this; find a decent
text-editor instead.

The default value is \kbd{1}.

\subsec{threadsize}\kbdsidx{threadsize}\label{se:def,threadsize}
In parallel mode, each thread needs its own private \tev{stack} in which
to do its computations, see \kbd{parisize}. This value determines the size
in bytes of the stacks of each thread, so the total memory allocated will be
$\kbd{parisize}+\kbd{nbthreads}\times\kbd{threadsize}$.

If set to $0$, the value used is the same as \kbd{parisize}.

The default value is $0$.

\subsec{timer}\kbdsidx{timer}\label{se:def,timer}
This toggle is either 1 (on) or 0 (off). Every instruction sequence
in the gp calculator (anything ended by a newline in your input) is timed,
to some accuracy depending on the hardware and operating system. When
\tet{timer} is on, each such timing is printed immediately before the
output as follows:
\bprog
? factor(2^2^7+1)
time = 108 ms.     \\ this line omitted if 'timer' is 0
%1 =
[     59649589127497217 1]

[5704689200685129054721 1]
@eprog\noindent (See also \kbd{\#} and \kbd{\#\#}.)

The time measured is the user \idx{CPU time}, \emph{not} including the time
for printing the results. If the time is negligible ($< 1$ ms.), nothing is
printed: in particular, no timing should be printed when defining a user
function or an alias, or installing a symbol from the library.

The default value is \kbd{0} (off).
%SECTION: default

\vfill\eject
